(()=>{var __webpack_modules__={6525:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7537);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1667);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(1340), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(4000), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(8385), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(5331), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(8198), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(6096), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(8752), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_7___ = new URL(/* asset import */ __webpack_require__(7769), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_8___ = new URL(/* asset import */ __webpack_require__(1733), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_9___ = new URL(/* asset import */ __webpack_require__(7193), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_10___ = new URL(/* asset import */ __webpack_require__(5680), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_11___ = new URL(/* asset import */ __webpack_require__(2182), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_12___ = new URL(/* asset import */ __webpack_require__(4902), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_13___ = new URL(/* asset import */ __webpack_require__(7933), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500&family=Open+Sans:ital,wght@0,400;0,700;1,400&display=swap);"]);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);\nvar ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_5___);\nvar ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_6___);\nvar ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_7___);\nvar ___CSS_LOADER_URL_REPLACEMENT_8___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_8___);\nvar ___CSS_LOADER_URL_REPLACEMENT_9___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_9___);\nvar ___CSS_LOADER_URL_REPLACEMENT_10___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_10___);\nvar ___CSS_LOADER_URL_REPLACEMENT_11___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_11___);\nvar ___CSS_LOADER_URL_REPLACEMENT_12___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_12___);\nvar ___CSS_LOADER_URL_REPLACEMENT_13___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_13___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, "a{text-decoration:none;color:#333}.btn,.btn-secondary{display:flex;justify-content:center;align-items:center;color:#fff;background-color:#191a15;border:none;border-radius:2rem;font-family:\\"Montserrat\\",sans-serif;font-size:1rem;padding:.5rem 1.2rem;cursor:pointer;transition:.5s all ease-in-out}.btn__disabled{background-color:rgba(0,0,0,0);border:1px solid #a1a1a1;color:#a1a1a1;pointer-events:none}.btn:disabled,.btn-secondary:disabled{background-color:rgba(0,0,0,0);border:1px solid #a1a1a1;color:#a1a1a1;pointer-events:none}.btn-secondary{background-color:#fff;border:2px solid #332a7c;color:#332a7c}.video-btn{padding:0 1rem 0 .2rem;border-color:#fff;box-shadow:rgba(0,0,0,.2) 0px 12px 28px 0px,rgba(0,0,0,.1) 0px 2px 4px 0px,rgba(255,255,255,.05) 0px 0px 0px 1px inset}.video-btn:hover{box-shadow:0px 1px 4px 1px rgba(50,50,71,.15)}.video-btn .video-icon{font-size:3rem;padding-right:.5rem}.btn-play{width:3.5rem;height:3.5rem;padding:0;background-color:#fff;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15)}.btn-level{box-shadow:0px 1px 4px 1px rgba(50,50,71,.15);border:2px solid rgba(0,0,0,0)}.btn-level:hover{background-color:#ffddb0}.btn-level.btn-active{border-color:#332a7c;color:#191a15}.btn-level{box-shadow:0px 1px 4px 1px rgba(50,50,71,.15)}.btn-level-1{background-color:#fcfcff}.btn-level-2{background-color:#f4f4ff}.btn-level-3{background-color:#f0f0ff}.btn-level-4{background-color:#eaeaff}.btn-level-5{background-color:#e4e4ff}.btn-level-6{background-color:#dedeff}.user-words-btn{background-color:#332a7c;color:#ffddb0;position:relative}.user-words-btn.btn-active{background-color:#ffddb0;color:#332a7c}.user-words-btn::after{content:\\"\\";position:absolute;font-family:Material Icons Outlined;font-size:1.3rem;font-weight:300;font-style:normal;background:#ffddb0;color:#332a7c;padding:.5rem;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15);border-radius:30px;right:-15px;top:-6px}.user-words-btn:hover{color:#332a7c}.btn:disabled,.btn-secondary:disabled{background-color:rgba(0,0,0,0);border:1px solid #a1a1a1;color:#a1a1a1}.btn-add,.btn-learn{padding:.5rem;width:3rem;height:3rem}h1,h2,h3,h4{font-family:\\"Montserrat\\",sans-serif}h1{font-size:4.7rem}@media(max-width: 768px){h1{font-size:3.5rem}}h2{font-size:2.4rem}.user-icon{background-color:rgba(0,0,0,0);font-size:45px;border-radius:50%;transition:all .5s}.user-icon:hover{background-color:#ffddb0}.modal-overlay{font-family:\\"Montserrat\\",sans-serif;position:fixed;left:0;top:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;background-color:rgba(41,41,41,.6);cursor:pointer;z-index:5}.modal-overlay:hover .modal-close-btn{background-color:#191a15}.modal-wrapper{position:absolute;width:50%;height:auto;z-index:6;cursor:default;background-color:#fff;padding:3rem;border-radius:1rem}.modal-close-btn{display:flex;justify-content:center;align-items:center;width:52px;height:52px;position:absolute;right:-52px;top:-52px;border-radius:50px;cursor:pointer;transition:.3s ease-in-out;z-index:6}.modal-close-btn:hover{background-color:#fff}.modal_wrapper:hover .modal-close-btn{background-color:rgba(0,0,0,0)}.modal-err-message{text-align:center;padding-bottom:1.2rem;color:red}.modal-message{color:#332a7c;text-align:center;font-size:1.2rem;font-weight:600}.form-wrapper form{display:flex;flex-direction:column;flex-wrap:nowrap;align-content:center;align-items:center;justify-content:center;row-gap:1.5rem}.form-wrapper .input-wrapper{width:90%;text-align:center}.form-wrapper input{height:3rem;width:100%;border-bottom:1px solid;padding:0 .5rem;font-size:1.2rem;font-family:\\"Montserrat\\",sans-serif}.form-wrapper input:focus-visible{outline:none}.form-wrapper .btn-submit{margin-top:1rem}.error-message,.error-in-form{color:red}*,*:before,*:after{padding:0;margin:0;border:0;box-sizing:border-box}.body{font-family:\\"Open Sans\\",sans-serif;font-size:16px;color:#333;margin:0 auto;padding:0 2.5rem;display:flex;flex-direction:column;align-content:stretch;flex-wrap:nowrap;max-width:1440px;min-height:100vh}@media(max-width: 768px){.body{padding:0 1rem}}.header{display:flex;justify-content:space-between;align-items:center;font-family:\\"Montserrat\\",sans-serif;font-weight:400;font-size:1rem;line-height:1.2;height:75px;margin:auto;width:100%;z-index:1;padding:0 2rem}.logo{font-size:1.5rem;line-height:1.4;font-weight:800}@media(max-width: 768px){.logo{line-height:1.1}}@media(max-width: 425px){.logo{font-size:1.2rem;line-height:1.1}}@media(max-width: 600px){.header-menu{position:fixed;display:flex;align-items:center;justify-content:center;width:320px;height:100vh;top:0;background-color:#fff;right:-320px;z-index:2;font-size:32px;line-height:51.2px;overflow-x:hidden;transition:all .8s ease-in-out}}.menu-items{display:flex;justify-content:center;align-items:center;list-style:none}@media(max-width: 600px){.menu-items{flex-direction:column;justify-content:center;align-items:center;line-height:48px;gap:43px}}.menu-item-link{cursor:pointer;font-weight:600;padding:29px}.menu-item-link:hover{border-bottom:2px solid #191a15;padding-bottom:27px}.auth{display:flex;justify-content:center;align-items:center;gap:1rem}.burger-icon{display:none}@media(max-width: 600px){.burger-icon{display:inline-block;position:relative;width:30px;height:22px;margin:0 1rem;z-index:9;cursor:pointer;transition:.5s}}@media(max-width: 600px){.burger-line{display:inline-block;position:absolute;background-color:#191a15;height:2px;width:100%;top:50%;transform:translateY(-50%)}.burger-line::before{display:inline-block;position:absolute;background-color:#191a15;height:2px;width:100%;top:50%;transform:translateY(-50%);content:\\"\\";margin-top:10px;background-color:#191a15}.burger-line::after{display:inline-block;position:absolute;background-color:#191a15;height:2px;width:100%;top:50%;transform:translateY(-50%);content:\\"\\";margin-top:-10px;background-color:#191a15}}.clicked{transform:rotate(90deg);z-index:99}.opened{right:0}.footer{display:flex;justify-content:space-between;align-items:center;font-family:\\"Montserrat\\",sans-serif;font-weight:400;font-size:.9rem;line-height:1.1;min-height:90px;margin:auto;width:100%;background-color:#191a15;color:#fff;padding:0 20px;flex-wrap:wrap}@media(max-width: 600px){.footer{flex-direction:column;gap:1rem;padding:.5rem 0}}.team-github{display:flex;justify-content:center;align-items:center;flex-wrap:wrap;gap:1rem}.team-github a{color:#fff}.rs-logo img{width:7rem}.main{flex-grow:1}.audio-call{position:absolute;width:100%;height:100vh;top:0;left:0;right:0;background:linear-gradient(180deg, #7d5db0, #b06d9a 72%, #c584a4);color:rgba(255,255,255,.7);display:flex;align-items:center;margin:0 auto;flex-direction:column;padding:80px 10px 0 10px}.audio-call .container{margin:0 auto;width:100%;max-width:1250px}.audio-call .level-select{display:flex;flex-direction:column;align-items:center;justify-content:center;row-gap:2rem}.audio-call .select-block{text-align:center}@media screen and (max-width: 1030px){.audio-call .select-block{max-width:500px}}.audio-call .select-block .select-block__title{padding:1rem}.audio-call .selected{color:#fff;border:1px solid #fff}.audio-call a,.audio-call button{margin:.2rem;border:1px solid rgba(255,255,255,.2);border-radius:3px;cursor:pointer;display:inline-block;line-height:1;color:inherit;min-width:162px;padding:19px 15px 21px;transition:all .15s ease;background-color:rgba(0,0,0,0)}.audio-call a:hover,.audio-call button:hover{color:#fff;border:1px solid #fff}.audio-call .stage{text-align:center}.audio-call .stage__img{border-radius:50%;height:13rem;width:13rem;margin:1rem auto;display:block}.audio-call .answers{margin:3rem 0;display:flex;align-items:center;flex-wrap:wrap;justify-content:center;gap:2rem}.audio-call .answer{font-size:1.5rem;display:flex;gap:.5rem;cursor:pointer}.audio-call .answer :hover{color:#fff}.audio-call .answer .checked{color:green;border:1px solid;border-radius:50%;height:2rem;width:2rem;line-height:2rem;font-size:1.5rem;background-color:#b7d693}.audio-call .word{display:flex;align-items:center;justify-content:center;font-size:2.5rem}.audio-call .speaker-button{border:none;border-radius:50%;padding:0;margin:0;min-width:0px;border-color:rgba(0,0,0,0)}.audio-call .speaker-button:hover{border:none}.audio-call .speaker-button svg{padding:.2rem}.audio-call .speaker-button svg:hover path{fill:#3c3e3d !important}.audio-call .speaker-button_min{padding:0 1rem}.audio-call .speaker-button_min svg{width:3rem;height:3rem}.audio-call .game__result{display:flex;flex-direction:column;align-items:center;background-color:#fff;border:1px solid #e6e9ee;border-radius:8px;box-sizing:border-box;max-width:500px;min-height:646px;padding:42px 16px;text-align:center;width:100%}.audio-call .result__score{color:#37383c;font-size:34px;font-weight:300;align-self:center}.audio-call .game__lists{margin-top:30px}.audio-call .result__true,.audio-call .result__false{display:flex;flex-direction:column;align-items:flex-start;font-size:12px;font-weight:700;line-height:1.33;text-transform:uppercase;list-style:none}.audio-call .result__true{color:#28c38a;margin:1rem 0}.audio-call .result__false{color:#ed593b}.audio-call .result__word{display:flex;gap:10px;align-items:center;color:#37383c;font-size:16px;line-height:1.25;text-transform:lowercase;font-weight:500;margin-top:5px}.audio-call .result__word-en{font-weight:700}.audio-call .result__voice{width:33px;height:33px;cursor:pointer}.audio-call .result__voice svg{width:2rem;height:2rem}.audio-call .close-button{border-radius:50%;width:4rem;height:4rem;text-align:center;line-height:22px;font-size:2rem;min-width:min-content}.audio-call .mute-button{margin:4px;font-size:3rem}.audio-call .result__button{margin-top:1rem;border:2px solid #28c38a;color:#3c3e3d;font-size:1.2rem}.audio-call .result__button:hover{background-color:#28c38a;border:2px solid #28c38a}.audio-call .buttons-wrapper{width:100%;display:flex;align-items:center;justify-content:space-between}.body--sprint{position:relative;max-width:100%;min-height:100vh;padding:0;background-color:#0d3848;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + "),url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + "),url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ");background-repeat:no-repeat,no-repeat,no-repeat;background-size:100%,auto,auto;background-position:bottom,0 0,100% 0}.body--sprint h2{font-size:24px}.body--sprint .header{position:absolute;top:0;max-width:1360px;padding:0 2rem;background-color:rgba(0,0,0,0);z-index:10;align-self:center;color:#fff;border:none}.body--sprint .logo a{color:#fff}.body--sprint .menu-item-link{color:#fff}.body--sprint .menu-item-link:hover{border-bottom:2px solid #fff}.body--sprint .btn-secondary{color:#000}.body--sprint .enter-cabinet-link{color:#fff}.body--sprint .main{padding:75px 0;display:flex;min-height:100vh}.body--sprint .footer{display:none}.body--sprint .burger-line{background-color:#fff}.body--sprint .burger-line::after{background-color:#fff}.body--sprint .burger-line::before{background-color:#fff}.body--sprint .opened{background-color:#0d3848}.sprint{position:relative;display:flex;align-items:center;justify-content:center;padding:20px 0;color:#fff;width:100%}.sprint .sprint__select-title{font-size:2.4rem}.sprint__select{display:flex;flex-direction:column;align-items:center;min-width:50%}.sprint__select-descr{margin-top:2rem}.sprint__select-text{margin-top:2rem}.sprint__levels{margin-top:20px;display:flex;justify-content:space-between;width:100%;gap:.4rem}.sprint__level{display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:162px;height:55px;border-radius:3px;border:1px solid #fff;cursor:pointer}.sprint__close{position:absolute;top:10px;right:20px;width:40px;height:40px;border-radius:40px;z-index:1;margin:20px auto;cursor:pointer}.sprint__close::before{content:\\"+\\";color:#fff;position:absolute;z-index:2;transform:rotate(45deg);font-size:50px;line-height:1;top:-5px;left:6px;transition:all .3s cubic-bezier(0.77, 0, 0.2, 0.85)}.sprint__close::after{content:\\"\\";position:absolute;top:0;left:0;width:100%;height:100%;border-radius:100%;background:#fff;z-index:1;transition:all .3s cubic-bezier(0.77, 0, 0.2, 0.85);transform:scale(0.01)}.sprint__close:hover:after{transform:scale(1)}.sprint__close:hover:before{transform:scale(0.8) rotate(45deg);color:#0d3848}.timer{display:flex;justify-content:center;align-items:center;position:relative}.timer__time{font-size:30px;font-weight:lighter;width:160px;position:absolute;display:flex;align-items:center;justify-content:center}.timer__svg{transform:rotate(90deg) scaleX(-1)}.circle_animation{stroke-dasharray:440;stroke-dashoffset:0;transition:all 1s linear}.sprint__ready{display:flex;flex-direction:column}.timer--control{position:absolute;top:20px;left:20px}.sprint__control{display:flex;flex-direction:column;align-items:center;position:relative}.control__sound{position:absolute;right:0;width:23px;height:24px;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ");background-repeat:no-repeat;cursor:pointer}.control__sound--off{background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ")}.control__container{position:relative;display:flex;flex-direction:column;align-items:center;width:500px;padding:30px;margin-top:10px;border:1px solid #fff;border-radius:10px;background-color:rgba(255,255,255,.06)}.control__voice{position:absolute;right:20px;top:20px;width:33px;height:33px;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ");background-repeat:no-repeat;background-position:center;cursor:pointer}.control__voice:hover{background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ")}.control__series-list{display:flex;justify-content:center;gap:20px}.control__series{width:26px;height:26px;border-radius:50%;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_7___ + ");background-position:50%;background-repeat:no-repeat;background-size:contain}.control__series--active{background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_8___ + ")}.control__multiply{margin-top:10px}.control__parrots{display:flex;width:204px;height:57px;margin-top:30px;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_9___ + ");background-repeat:no-repeat;background-position:bottom}.control__parrot{position:relative;top:6px}.control__word-en{font-size:36px;margin-top:20px}.control__word-ru{font-size:24px;color:rgba(255,255,255,.6)}.control__buttons{display:flex;gap:20px;margin-top:40px;padding-bottom:40px}.control__button{position:relative;border-radius:4px;color:#fff;font-size:20px;font-weight:400;height:50px;text-align:center;width:183px;cursor:pointer}.control__button::before{bottom:-45px;color:#7e919f;display:block;font-size:28px;position:absolute}.control__button--false{background-color:#ed593b}.control__button--false::before{content:\\"←\\";left:40%}.control__button--true{background-color:#28c38a}.control__button--true::before{content:\\"→\\";right:40%}.sprint__result{display:flex;flex-direction:column;align-items:center;background-color:#fff;border:1px solid #e6e9ee;border-radius:8px;box-sizing:border-box;max-width:500px;max-height:500px;padding:42px 16px;text-align:center;width:100%;overflow-y:auto}.result__score{color:#37383c;font-size:34px;font-weight:300;align-self:center}.sprint__lists{margin-top:30px}.result__true,.result__false{display:flex;flex-direction:column;align-items:flex-start;font-size:12px;font-weight:700;line-height:1.33;text-transform:uppercase;list-style:none}.result__true{color:#28c38a;margin-top:20px}.result__false{color:#ed593b}.result__word{display:flex;gap:10px;align-items:center;color:#37383c;font-size:16px;line-height:1.25;text-transform:lowercase;font-weight:500;margin-top:5px}.result__word-en{font-weight:700}.result__voice{width:33px;height:33px;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_10___ + ");background-repeat:no-repeat;background-position:center;cursor:pointer}.result__voice:hover{background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_6___ + ")}.result__restart-btn{background-color:rgba(37,130,231,.08);border-radius:4px;color:#2582e7;cursor:pointer;font-size:14px;font-weight:600;line-height:1.43;margin-top:24px;padding:10px 42px;text-align:center}.result__restart-btn:hover{background-color:rgba(37,130,231,.12)}.sprint__restart-message{font-size:14px;width:60%;color:#ed593b;margin-top:10px}.textbook{display:flex;position:relative;align-items:stretch;width:100%;margin-top:-2px}@media(max-width: 600px){.textbook{flex-direction:column}}.aside{padding:2rem 1rem;width:15%;flex-shrink:0;font-family:\\"Montserrat\\",sans-serif}@media(max-width: 600px){.aside{width:100%}}@media(max-width: 425px){.aside{padding:1rem .2rem}}.sidebar-content{position:-webkit-sticky;position:sticky;top:0;display:flex;flex-direction:column;justify-content:center;align-items:center;padding-right:1.5rem;gap:.7rem}@media(max-width: 600px){.sidebar-content{flex-direction:row;flex-wrap:wrap;justify-content:flex-start}}@media(max-width: 425px){.sidebar-content{gap:.3rem;padding:0;justify-content:center;row-gap:1.8rem}}.sidebar-text{font-size:1.2rem;font-weight:600;text-align:center}@media(max-width: 600px){.sidebar-text{font-size:1rem}}@media(max-width: 425px){.sidebar-text{display:none}}.btn-level{display:flex;justify-content:center;align-items:center;height:5.6rem;width:5.6rem;border-radius:50%;padding:2.5rem;font-size:2.5rem;font-weight:700;cursor:pointer;transition:.3s ease-in-out}@media(max-width: 600px){.btn-level{height:3.2rem;width:3.2rem;padding:0;font-size:1.5rem}}.userbook-mark{display:flex;position:absolute;bottom:3.8rem;right:2.4rem;background:#ffddb0;color:#332a7c;border-radius:30px;padding:.5rem;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15)}.userbook-mark .material-icons-outlined{font-size:1.3rem}@media(max-width: 600px){.userbook-mark{bottom:2rem;right:1rem}}@media(max-width: 425px){.userbook-mark{right:9.1rem}}.text-book-page{background-color:#ffddb0;box-shadow:inset -1px -1px 3px rgba(255,255,255,.75),inset 1px 1px 2px rgba(7,7,69,.15);border-radius:30px;display:flex;flex-direction:column;padding:0 2.5rem 1.5rem;width:85%;border:3px solid #fff;margin-bottom:1.5rem}@media(max-width: 600px){.text-book-page{width:100%}}@media(max-width: 425px){.text-book-page{padding:1rem}}.text-book-page-head{display:flex;padding:2.5rem;align-items:center;gap:1.5rem;margin-right:auto}@media(max-width: 600px){.text-book-page-head{padding:2.5rem 1.2rem}}@media(max-width: 425px){.text-book-page-head{flex-direction:column;gap:.5rem;padding:1.5rem;margin:0}}.cards-wrapper{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap;row-gap:1rem}.card{padding:1.2rem;background:#fff;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15);border-radius:30px;display:flex;flex-direction:column;width:32rem;height:25rem}@media(max-width: 425px){.card{width:100%;height:auto}}.card-main-info-wrapper{display:flex;align-items:center;font-family:\\"Montserrat\\",sans-serif;padding-bottom:1.5rem}@media(max-width: 425px){.card-main-info-wrapper{flex-direction:column;padding-bottom:1rem}}.btn-play{margin-left:-2rem}.btn-play:hover{background-color:#ffddb0}.btn-play svg{width:25px;height:25px}.btn-play svg path{fill:#191a15;stroke:#191a15}.btn-play svg:hover{fill:#332a7c}.btn-play svg:hover path{fill:#332a7c;stroke:#332a7c}@media(max-width: 425px){.btn-play{margin-left:0;margin-top:-2rem}}.card-img{width:10rem;height:8rem;border-radius:30px}@media(max-width: 425px){.card-img{width:100%;height:10rem}}.card-word-info{padding-left:.8rem}@media(max-width: 425px){.card-word-info{text-align:center}}.word{font-size:1.8rem;font-weight:700}.word-transcription{font-size:1rem;color:#a1a1a1;padding-bottom:.8rem}.word-translate{font-size:1.3rem}.user-btns{margin-left:auto;display:flex;flex-direction:column;gap:.5rem;align-items:center}@media(max-width: 425px){.user-btns{flex-direction:row;margin:auto;padding-top:1rem}}.answers{font-size:.8rem}.hard-word-btn{border-color:#332a7c;background-color:#332a7c}.hard-word-btn .btn-icon{color:#ffddb0}.learn-word-btn{border-color:#ffddb0;background-color:#ffddb0}.learn-word-btn .btn-icon{color:#332a7c}.word-mean-translate,.word-ex-translate{color:#a1a1a1;line-height:1.6;font-style:italic}.word-mean-translate{padding-bottom:1rem}.pagination{display:flex;justify-content:center;align-items:center;padding:2.5rem 1rem 0}.page-input{margin:0 3rem;width:2rem;font-size:1.5rem;font-weight:600;font-family:\\"Montserrat\\",sans-serif;border-bottom:1px solid;text-align:center}.page-input:focus-visible{outline:none}@media(max-width: 425px){.page-input{margin:0 .5rem}}.page-input::-webkit-outer-spin-button,.page-input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}.page-input{-moz-appearance:textfield}.user-page{background-color:#ffddb0;box-shadow:inset -1px -1px 3px rgba(255,255,255,.75),inset 1px 1px 2px rgba(7,7,69,.15);border-radius:30px;background-color:#f4f4ff;display:flex;flex-direction:column;padding:2rem 1rem 1rem;gap:1.5rem}.user-sidebar{display:flex;gap:1.5rem;flex-direction:column;width:36%;padding:2.5rem 1.5rem 1.5rem}@media(max-width: 425px){.user-sidebar{width:100%;padding:0 1rem 1.5rem;align-items:center}}.user-section{display:flex;padding-bottom:1rem;gap:2.5rem}@media(max-width: 768px){.user-section{gap:0}}@media(max-width: 425px){.user-section{flex-direction:column}}.enter-cabinet-link{color:#191a15;font-weight:600}.exit-cabinet-btn{width:10rem}.hero-section{display:flex;justify-content:center;align-items:center;flex-direction:column;padding:3rem;background:center/cover no-repeat url(" + ___CSS_LOADER_URL_REPLACEMENT_11___ + ");border-radius:30px;box-shadow:inset -1px -1px 3px rgba(255,255,255,.75),inset 1px 1px 2px rgba(7,7,69,.15)}@media(max-width: 1025px){.hero-section{padding:1.5rem;padding-top:2.5rem}}@media(max-width: 768px){.hero-section{padding:3.5rem 2rem}}@media(max-width: 425px){.hero-section{padding:2.5rem 1.5rem}}.hero-section-header{width:50%;text-align:center;line-height:1;padding-bottom:2rem}@media(max-width: 1025px){.hero-section-header{width:60%}}@media(max-width: 768px){.hero-section-header{width:100%}}@media(max-width: 425px){.hero-section-header{width:100%}}.hero-section-text{text-align:center;width:60%;padding-bottom:1.5rem}@media(max-width: 425px){.hero-section-text{width:100%}}.advantages-section{display:flex;padding:0;margin-top:4.5rem;gap:1rem;flex-wrap:wrap;justify-content:center}.advantage_wrapper{padding:1.2rem;background:#fff;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15);border-radius:30px;text-align:center;padding:1rem;width:23%}@media(max-width: 1025px){.advantage_wrapper{width:48%}}@media(max-width: 600px){.advantage_wrapper{width:100%}}.advantage-header{position:relative;font-size:2rem;padding-bottom:1rem;padding-top:1rem}.advantage-header::after{position:absolute;content:\\"\\";height:2px;background-color:#191a15;width:30%;bottom:0;left:34.5%}.advantage-image{width:100%;border-radius:30px}.advantage-text{padding-top:1rem;padding-bottom:1rem}.info-section{display:flex;justify-content:space-between;align-items:center;padding:4.5rem 0}.info-text-wrapper{width:40%;padding:0 4.5rem}.info-header{font-size:1.5rem;padding-bottom:2rem}.info-text{list-style:none;padding-bottom:.7rem;display:flex;align-items:center}.info-text-icon{padding-right:.5rem}.info-image{background-color:#ffddb0;box-shadow:inset -1px -1px 3px rgba(255,255,255,.75),inset 1px 1px 2px rgba(7,7,69,.15);border-radius:30px;background:center/cover no-repeat url(" + ___CSS_LOADER_URL_REPLACEMENT_12___ + ");width:50%;height:25rem}.team-section{padding:4.5rem 0;display:flex;align-items:center;flex-direction:column;margin-bottom:2.5rem}.team-section-header{text-align:center}.team-members{display:flex;gap:1.5rem;padding-top:2.5rem;flex-wrap:wrap;justify-content:center}@media(max-width: 1025px){.team-members{width:100%}}.team-member{padding:1.2rem;background:#fff;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15);border-radius:30px;padding:1rem;width:30%;display:flex;justify-content:flex-start;flex-direction:column;align-items:center}@media(max-width: 600px){.team-member{width:100%}}.team-member-name{font-size:1.6rem;padding:1rem 0 0}.team-member-img{width:100%;border-radius:30px}.member-duty{font-size:.9rem;line-height:2;padding-bottom:1rem;color:#a1a1a1}.member-actions{text-align:center;padding-bottom:1rem;flex-grow:1}.member-actions ul{text-align:left;display:flex;flex-direction:column;align-items:center;justify-content:space-between;height:100%}.member-actions li{list-style:none;padding-bottom:.3rem;text-align:center}.git-icon{width:50px;height:50px;margin-top:auto;background-image:url(" + ___CSS_LOADER_URL_REPLACEMENT_13___ + ");filter:none;transition:all .5s;border-radius:50%;background-color:#fff}.git-icon:hover{filter:invert(1)}.charts{display:flex;align-items:center;justify-content:space-around;flex-wrap:wrap;width:100%;padding:20px}@media(max-width: 1025px){.charts{gap:1.5rem}}@media(max-width: 425px){.charts{width:100%}}.chart{width:35%;height:300px}@media(max-width: 425px){.chart{width:100%;height:max-content}}.todaystat-wrapper{padding:1.2rem;background:#fff;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15);border-radius:30px;padding:1.6rem;font-family:\\"Montserrat\\",sans-serif;width:62%;display:flex;justify-content:space-around}.todaystat-wrapper .word-wrapper{width:100%}@media(max-width: 425px){.todaystat-wrapper{width:100%;padding:.5rem}}.wrapper_daily-stat{display:flex;justify-content:center;align-items:center;flex-direction:column;width:100%;font-size:1.3rem;color:#191a15;font-family:\\"Montserrat\\",sans-serif;gap:1rem}.daystat-wrapper{padding:1.2rem;background:#fff;box-shadow:0px 1px 4px 1px rgba(50,50,71,.15);border-radius:30px;font-family:\\"Montserrat\\",sans-serif;display:flex;justify-content:space-around;align-items:center;width:100%;padding-bottom:1.5rem}@media(max-width: 768px){.daystat-wrapper{flex-wrap:wrap;gap:1rem}.daystat-wrapper .word-wrapper{width:48%}}@media(max-width: 425px){.daystat-wrapper{flex-wrap:nowrap;flex-direction:column;gap:1rem}.daystat-wrapper .word-wrapper{width:100%}}.data-wrapper-row1,.data-wrapper-row2{display:flex;padding:1rem;gap:1rem;flex-direction:column;width:50%;justify-content:space-between}@media(max-width: 425px){.data-wrapper-row1,.data-wrapper-row2{padding:5px}}.data-wrapper-row1{align-items:center}.stat-data-item{display:flex;justify-content:space-between;align-items:center;padding-bottom:.5rem}.date-row{padding-right:6.5rem;padding-top:1.6rem;padding-left:2rem;text-align:center}@media(max-width: 425px){.date-row{padding-right:2.8rem}}@media(max-width: 425px){.date-row{padding-top:2.8rem}}.first-day-text{line-height:1.2}.first-day-date{font-size:1.6rem;font-weight:700;line-height:1.6}@media(max-width: 425px){.first-day-date{font-size:1rem}}.word-text{font-size:1.2rem;font-weight:700;padding-bottom:.5rem}.stat-data-param{padding-right:1rem;font-family:\\"Open Sans\\",sans-serif;font-size:.9rem}.stat-data-value{font-weight:600;font-size:.9rem}.date-text{font-size:1.2rem;font-weight:700}@media(max-width: 768px){.date-text{width:48%}}@media(max-width: 425px){.date-text{width:100%}}", "",{"version":3,"sources":["webpack://./src/styles/fonts.scss","webpack://./src/styles/components.scss","webpack://./src/styles/variables.scss","webpack://./src/styles/mixins.scss","webpack://./src/styles/modal.scss","webpack://./src/styles/form.scss","webpack://./src/styles/body.scss","webpack://./src/styles/header.scss","webpack://./src/styles/footer.scss","webpack://./src/styles/main.scss","webpack://./src/styles/audio-call.scss","webpack://./src/styles/sprint.scss","webpack://./src/styles/textBook.scss","webpack://./src/styles/userPage.scss","webpack://./src/styles/mainPage.scss","webpack://./src/styles/charts.scss","webpack://./src/styles/statPage.scss"],"names":[],"mappings":"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","sourcesContent":["@import url(\'https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500&family=Open+Sans:ital,wght@0,400;0,700;1,400&display=swap\');\\r\\n","a {\\r\\n  text-decoration: none;\\r\\n  color: $text-color;\\r\\n}\\r\\n\\r\\n.btn {\\r\\n  @include display-flex-center;\\r\\n  color: $white-color;\\r\\n  background-color: $dark-color;\\r\\n  border: none;\\r\\n  border-radius: 2rem;\\r\\n  font-family: $headers-font;\\r\\n  font-size: 1rem;\\r\\n  padding: 0.5rem 1.2rem;\\r\\n  cursor: pointer;\\r\\n  transition: 0.5s all ease-in-out;\\r\\n  &__disabled {\\r\\n    background-color: transparent;\\r\\n    border: 1px solid $mid-grey;\\r\\n    color: $mid-grey;\\r\\n    pointer-events: none;\\r\\n  }\\r\\n  &:disabled {\\r\\n    background-color: transparent;\\r\\n    border: 1px solid $mid-grey;\\r\\n    color: $mid-grey;\\r\\n    pointer-events: none;\\r\\n  }\\r\\n}\\r\\n\\r\\n.btn-secondary {\\r\\n  @extend .btn;\\r\\n  background-color: $white-color;\\r\\n  border: 2px solid $accent-color;\\r\\n  color: $accent-color;\\r\\n}\\r\\n\\r\\n.video-btn {\\r\\n  padding: 0 1rem 0 0.2rem;\\r\\n  border-color: $white-color;\\r\\n  box-shadow: rgba(0, 0, 0, 0.2) 0px 12px 28px 0px,\\r\\n    rgba(0, 0, 0, 0.1) 0px 2px 4px 0px,\\r\\n    rgba(255, 255, 255, 0.05) 0px 0px 0px 1px inset;\\r\\n  &:hover {\\r\\n    box-shadow: $box-shadow;\\r\\n  }\\r\\n  .video-icon {\\r\\n    font-size: 3rem;\\r\\n    padding-right: 0.5rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.btn-play {\\r\\n  width: 3.5rem;\\r\\n  height: 3.5rem;\\r\\n  padding: 0;\\r\\n  background-color: $white-color;\\r\\n  box-shadow: $box-shadow;\\r\\n}\\r\\n\\r\\n//level buttons\\r\\n.btn-level {\\r\\n  box-shadow: $box-shadow;\\r\\n  border: 2px solid transparent;\\r\\n  &:hover {\\r\\n    background-color: $secondary-color;\\r\\n  }\\r\\n  &.btn-active {\\r\\n    border-color: $accent-color;\\r\\n    color: $dark-color;\\r\\n  }\\r\\n}\\r\\n\\r\\n//level buttons\\r\\n.btn-level {\\r\\n  box-shadow: $box-shadow;\\r\\n}\\r\\n\\r\\n.btn-level-1 {\\r\\n  background-color: $l1;\\r\\n}\\r\\n\\r\\n.btn-level-2 {\\r\\n  background-color: $l2;\\r\\n}\\r\\n\\r\\n.btn-level-3 {\\r\\n  background-color: $l3;\\r\\n}\\r\\n\\r\\n.btn-level-4 {\\r\\n  background-color: $l4;\\r\\n}\\r\\n\\r\\n.btn-level-5 {\\r\\n  background-color: $l5;\\r\\n}\\r\\n\\r\\n.btn-level-6 {\\r\\n  background-color: $l6;\\r\\n}\\r\\n\\r\\n.user-words-btn {\\r\\n  background-color: $accent-color;\\r\\n  color: $secondary-color;\\r\\n  position: relative;\\r\\n  &.btn-active {\\r\\n    background-color: $secondary-color;\\r\\n    color: $accent-color;\\r\\n  }\\r\\n  &::after {\\r\\n    content: \'\\\\ea19\';\\r\\n    position: absolute;\\r\\n    font-family: Material Icons Outlined;\\r\\n    font-size: 1.3rem;\\r\\n    font-weight: 300;\\r\\n    font-style: normal;\\r\\n    background: #ffddb0;\\r\\n    color: #332A7C;\\r\\n    padding: 0.5rem;\\r\\n    box-shadow: 0px 1px 4px 1px rgb(50 50 71 / 15%);\\r\\n    border-radius: 30px;\\r\\n    right: -15px;\\r\\n    top: -6px;\\r\\n  }\\r\\n  &:hover {\\r\\n    color: $accent-color;\\r\\n  }\\r\\n}\\r\\n\\r\\n.btn:disabled {\\r\\n  background-color: transparent;\\r\\n  border: 1px solid $mid-grey;\\r\\n  color: $mid-grey;\\r\\n}\\r\\n\\r\\n.btn-add,\\r\\n.btn-learn {\\r\\n  padding: 0.5rem;\\r\\n  width: 3rem;\\r\\n  height: 3rem;\\r\\n}\\r\\n\\r\\nh1,\\r\\nh2,\\r\\nh3,\\r\\nh4 {\\r\\n  font-family: $headers-font;\\r\\n}\\r\\n\\r\\nh1 {\\r\\n  font-size: 4.7rem;\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    font-size: 3.5rem;\\r\\n  }\\r\\n}\\r\\n\\r\\nh2 {\\r\\n  font-size: 2.4rem;\\r\\n}\\r\\n\\r\\n.user-icon {\\r\\n  background-color: transparent;\\r\\n  font-size: 45px;\\r\\n  border-radius: 50%;\\r\\n  transition: all 0.5s;\\r\\n  &:hover {\\r\\n    background-color: $secondary-color;\\r\\n  }\\r\\n}\\r\\n","$headers-font: \'Montserrat\', sans-serif;\\r\\n$text-font: \'Open Sans\', sans-serif;\\r\\n\\r\\n$dark-color: #191a15;\\r\\n$accent-color: #332A7C;\\r\\n$secondary-color: #ffddb0;\\r\\n$white-color: #ffffff;\\r\\n$mid-grey: #a1a1a1;\\r\\n$light-grey: #d8d8d8;\\r\\n$text-color: #333333;\\r\\n$overlay-color: rgba(41, 41, 41, 0.6);\\r\\n\\r\\n$section-padding: 4.5rem 0;\\r\\n\\r\\n// media\\r\\n$breakpoint-laptop: 1025px;\\r\\n$breakpoint-tablet: 768px;\\r\\n$breakpoint-mobile: 425px;\\r\\n$breakpoint-tablet-vertical: 600px;\\r\\n\\r\\n$learned-word-btn-color: $secondary-color;\\r\\n$hard-word-btn-color: $accent-color;\\r\\n\\r\\n$box-shadow: 0px 1px 4px 1px rgba(50, 50, 71, 0.15);\\r\\n// level colors\\r\\n\\r\\n$l1: #FCFCFF;\\r\\n$l2: #F4F4FF;\\r\\n$l3: #F0F0FF;\\r\\n$l4: #EAEAFF;\\r\\n$l5: #E4E4FF;\\r\\n$l6: #DEDEFF;\\r\\n\\r\\n/*\\r\\n$l1: #ECDCA3;\\r\\n$l2: #CCDFAF;\\r\\n$l3: #ABD8D3;\\r\\n$l4: #96D7E0;\\r\\n$l5: #76ADDA;\\r\\n$l6: #5A78CA;\\r\\n*/","@mixin display-flex-space-between {\\r\\n display: flex;\\r\\n justify-content: space-between;\\r\\n align-items: center;\\r\\n}\\r\\n\\r\\n@mixin display-flex-center {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n@mixin card-style {\\r\\n  padding: 1.2rem;\\r\\n  background: $white-color;\\r\\n  box-shadow: $box-shadow;\\r\\n  border-radius: 30px;\\r\\n}\\r\\n\\r\\n@mixin section-bg-colored {\\r\\n  // background: #FCFCFF;\\r\\n  background-color: $secondary-color;\\r\\n  box-shadow: inset -1px -1px 3px rgba(255, 255, 255, 0.75), inset 1px 1px 2px rgba(7, 7, 69, 0.15);\\r\\n  border-radius: 30px;\\r\\n}",".modal-overlay {\\r\\n  font-family: $headers-font;\\r\\n  position: fixed;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  background-color: $overlay-color;\\r\\n  cursor: pointer;\\r\\n  z-index: 5;\\r\\n  &:hover .modal-close-btn {\\r\\n    background-color: $dark-color;\\r\\n  }\\r\\n}\\r\\n\\r\\n.modal-wrapper {\\r\\n  position: absolute;\\r\\n  width: 50%;\\r\\n  height: auto;\\r\\n  z-index: 6;\\r\\n  cursor: default;\\r\\n  background-color: $white-color;\\r\\n  padding: 3rem;\\r\\n  border-radius: 1rem;\\r\\n}\\r\\n\\r\\n.modal-close-btn {\\r\\n  @include display-flex-center;\\r\\n  width: 52px;\\r\\n  height: 52px;\\r\\n  position: absolute;\\r\\n  right: -52px;\\r\\n  top: -52px;\\r\\n  border-radius: 50px;\\r\\n  cursor: pointer;\\r\\n  transition: 0.3s ease-in-out;\\r\\n  z-index: 6;\\r\\n  &:hover {\\r\\n    background-color: $white-color;\\r\\n  }\\r\\n}\\r\\n\\r\\n.modal_wrapper:hover .modal-close-btn {\\r\\n  background-color: transparent;\\r\\n}\\r\\n\\r\\n.modal-err-message {\\r\\n  text-align: center;\\r\\n  padding-bottom: 1.2rem;\\r\\n  color: red;\\r\\n}\\r\\n\\r\\n.modal-message {\\r\\n  color: $accent-color;\\r\\n  text-align: center;\\r\\n  font-size: 1.2rem;\\r\\n  font-weight: 600;\\r\\n}",".form-wrapper {\\r\\n  form {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    flex-wrap: nowrap;\\r\\n    align-content: center;\\r\\n    align-items: center;\\r\\n    justify-content: center;\\r\\n    row-gap: 1.5rem;\\r\\n  }\\r\\n  .input-wrapper {\\r\\n    width: 90%;\\r\\n    text-align: center;\\r\\n  }\\r\\n  input {\\r\\n  height: 3rem;\\r\\n  width: 100%;\\r\\n  border-bottom: 1px solid;\\r\\n  padding: 0 0.5rem;\\r\\n  font-size: 1.2rem;\\r\\n  font-family: $headers-font;\\r\\n  &:focus-visible {\\r\\n    outline: none;\\r\\n    }\\r\\n  }\\r\\n  .btn-submit {\\r\\n    margin-top: 1rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.error-message, .error-in-form {\\r\\n  color: red;\\r\\n}\\r\\n","*,\\r\\n*:before,\\r\\n*:after {\\r\\n  padding: 0;\\r\\n  margin: 0;\\r\\n  border: 0;\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.body {\\r\\n  font-family: $text-font;\\r\\n  font-size: 16px;\\r\\n  color: $text-color;\\r\\n  margin: 0 auto;\\r\\n  padding: 0 2.5rem;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-content: stretch;\\r\\n  flex-wrap: nowrap;\\r\\n  max-width: 1440px;\\r\\n  min-height: 100vh;\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    padding: 0 1rem;\\r\\n  }\\r\\n}\\r\\n",".header {\\r\\n  @include display-flex-space-between;\\r\\n  font-family: $headers-font;\\r\\n  font-weight: 400;\\r\\n  font-size: 1rem;\\r\\n  line-height: 1.2;\\r\\n  height: 75px;\\r\\n  margin: auto;\\r\\n  width: 100%;\\r\\n  // border-bottom: 1px solid $light-grey;\\r\\n  z-index: 1;\\r\\n  padding: 0 2rem;\\r\\n}\\r\\n\\r\\n.logo {\\r\\n  font-size: 1.5rem;\\r\\n  line-height: 1.4;\\r\\n  font-weight: 800;\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    line-height: 1.1;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    font-size: 1.2rem;\\r\\n    line-height: 1.1;\\r\\n  }\\r\\n}\\r\\n\\r\\n.header-menu {\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    position: fixed;\\r\\n    display: flex;\\r\\n    align-items: center;\\r\\n    justify-content: center;\\r\\n    width: 320px;\\r\\n    height: 100vh;\\r\\n    top: 0;\\r\\n    background-color: $white-color;\\r\\n    right: -320px;\\r\\n    z-index: 2;\\r\\n    font-size: 32px;\\r\\n    line-height: 51.2px;\\r\\n    overflow-x: hidden;\\r\\n    transition: all 0.8s ease-in-out;\\r\\n  }\\r\\n}\\r\\n\\r\\n.menu-items {\\r\\n  @include display-flex-center;\\r\\n  list-style: none;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    flex-direction: column;\\r\\n    justify-content: center;\\r\\n    align-items: center;\\r\\n    line-height: 48px;\\r\\n    gap: 43px;\\r\\n  }\\r\\n}\\r\\n\\r\\n.menu-item-link {\\r\\n  cursor: pointer;\\r\\n  font-weight: 600;\\r\\n  padding: 29px;\\r\\n  &:hover {\\r\\n    border-bottom: 2px solid $dark-color;\\r\\n    padding-bottom: 27px;\\r\\n  }\\r\\n}\\r\\n\\r\\n.auth {\\r\\n  @include display-flex-center;\\r\\n  gap: 1rem;\\r\\n}\\r\\n\\r\\n.burger-icon {\\r\\n  display: none;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    display: inline-block;\\r\\n    position: relative;\\r\\n    width: 30px;\\r\\n    height: 22px;\\r\\n    margin: 0 1rem;\\r\\n    z-index: 9;\\r\\n    cursor: pointer;\\r\\n    transition: 0.5s;\\r\\n  }\\r\\n}\\r\\n\\r\\n.burger-line {\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    display: inline-block;\\r\\n    position: absolute;\\r\\n    background-color: $dark-color;\\r\\n    height: 2px;\\r\\n    width: 100%;\\r\\n    top: 50%;\\r\\n    transform: translateY(-50%);\\r\\n    &::before {\\r\\n      display: inline-block;\\r\\n      position: absolute;\\r\\n      background-color: $dark-color;\\r\\n      height: 2px;\\r\\n      width: 100%;\\r\\n      top: 50%;\\r\\n      transform: translateY(-50%);\\r\\n      content: \\"\\";\\r\\n      margin-top: 10px;\\r\\n      background-color: $dark-color;\\r\\n    }\\r\\n    &::after {\\r\\n      display: inline-block;\\r\\n      position: absolute;\\r\\n      background-color: $dark-color;\\r\\n      height: 2px;\\r\\n      width: 100%;\\r\\n      top: 50%;\\r\\n      transform: translateY(-50%);\\r\\n      content: \\"\\";\\r\\n      margin-top: -10px;\\r\\n      background-color: $dark-color;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n.clicked {\\r\\n  transform: rotate(90deg);\\r\\n  z-index: 99;\\r\\n}\\r\\n\\r\\n.opened {\\r\\n  right: 0;\\r\\n}\\r\\n",".footer {\\r\\n  @include display-flex-space-between;\\r\\n  font-family: $headers-font;\\r\\n  font-weight: 400;\\r\\n  font-size: 0.9rem;\\r\\n  line-height: 1.1;\\r\\n  min-height: 90px;\\r\\n  margin: auto;\\r\\n  width: 100%;\\r\\n  background-color: $dark-color;\\r\\n  color: $white-color;\\r\\n  padding: 0 20px;\\r\\n  flex-wrap: wrap;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    flex-direction: column;\\r\\n    gap: 1rem;\\r\\n    padding: 0.5rem 0;\\r\\n  }\\r\\n}\\r\\n\\r\\n.team-github {\\r\\n  @include display-flex-center;\\r\\n  flex-wrap: wrap;\\r\\n  gap: 1rem;\\r\\n  a {\\r\\n    color: $white-color;\\r\\n  }\\r\\n}\\r\\n\\r\\n.rs-logo img {\\r\\n  width: 7rem;\\r\\n}\\r\\n",".main {\\r\\n  flex-grow: 1;\\r\\n}\\r\\n",".audio-call {\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100vh;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  /* height: calc(100vh - 75px); */\\r\\n  background: linear-gradient(180deg, #7d5db0, #b06d9a 72%, #c584a4);\\r\\n  color: hsla(0deg, 0%, 100%, 0.7);\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  // justify-content: center;\\r\\n  /* max-width: 1440px; */\\r\\n  margin: 0 auto;\\r\\n  flex-direction: column;\\r\\n  padding: 80px 10px 0 10px;\\r\\n  .container {\\r\\n    margin: 0 auto;\\r\\n    width: 100%;\\r\\n    max-width: 1250px;\\r\\n  }\\r\\n\\r\\n  .level-select {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n    justify-content: center;\\r\\n    row-gap: 2rem;\\r\\n  }\\r\\n  .select-block {\\r\\n    text-align: center;\\r\\n    @media screen and (max-width: 1030px) {\\r\\n      max-width: 500px;\\r\\n    }\\r\\n    .select-block__title {\\r\\n      padding: 1rem;\\r\\n    }\\r\\n  }\\r\\n  .selected {\\r\\n    color: hsla(0deg, 0%, 100%);\\r\\n    border: 1px solid hsla(0deg, 0%, 100%);\\r\\n  }\\r\\n\\r\\n  a,\\r\\n  button {\\r\\n    margin: 0.2rem;\\r\\n    border: 1px solid hsla(0deg, 0%, 100%, 0.2);\\r\\n    border-radius: 3px;\\r\\n    cursor: pointer;\\r\\n    display: inline-block;\\r\\n    line-height: 1;\\r\\n    color: inherit;\\r\\n    min-width: 162px;\\r\\n    padding: 19px 15px 21px;\\r\\n    transition: all 0.15s ease;\\r\\n    background-color: transparent;\\r\\n    &:hover {\\r\\n      color: hsla(0deg, 0%, 100%);\\r\\n      border: 1px solid hsla(0deg, 0%, 100%);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  .stage {\\r\\n    text-align: center;\\r\\n  }\\r\\n\\r\\n  .stage__img {\\r\\n    border-radius: 50%;\\r\\n    height: 13rem;\\r\\n    width: 13rem;\\r\\n    margin: 1rem auto;\\r\\n    display: block;\\r\\n  }\\r\\n\\r\\n  .answers {\\r\\n    margin: 3rem 0;\\r\\n    display: flex;\\r\\n    align-items: center;\\r\\n    flex-wrap: wrap;\\r\\n    justify-content: center;\\r\\n    gap: 2rem;\\r\\n  }\\r\\n\\r\\n  .answer {\\r\\n    font-size: 1.5rem;\\r\\n    display: flex;\\r\\n    gap: 0.5rem;\\r\\n    cursor: pointer;\\r\\n    & :hover {\\r\\n      color: hsla(0deg, 0%, 100%);\\r\\n    }\\r\\n    .checked {\\r\\n      color: green;\\r\\n      border: 1px solid;\\r\\n      border-radius: 50%;\\r\\n      height: 2rem;\\r\\n      width: 2rem;\\r\\n      line-height: 2rem;\\r\\n      font-size: 1.5rem;\\r\\n      background-color: #b7d693;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  .word {\\r\\n    display: flex;\\r\\n    align-items: center;\\r\\n    justify-content: center;\\r\\n    font-size: 2.5rem;\\r\\n  }\\r\\n\\r\\n  .speaker-button {\\r\\n    border: none;\\r\\n    border-radius: 50%;\\r\\n    &:hover {\\r\\n      border: none;\\r\\n    }\\r\\n    svg {\\r\\n      padding: 0.2rem;\\r\\n      &:hover {\\r\\n        path {\\r\\n          fill: #3c3e3d !important;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    padding: 0;\\r\\n    margin: 0;\\r\\n    min-width: 0px;\\r\\n    border-color: transparent;\\r\\n  }\\r\\n\\r\\n  .speaker-button_min {\\r\\n    padding: 0 1rem;\\r\\n    svg {\\r\\n      width: 3rem;\\r\\n      height: 3rem;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  .game__result {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n    background-color: #ffffff;\\r\\n    border: 1px solid #e6e9ee;\\r\\n    border-radius: 8px;\\r\\n    box-sizing: border-box;\\r\\n    max-width: 500px;\\r\\n    min-height: 646px;\\r\\n    padding: 42px 16px;\\r\\n    text-align: center;\\r\\n    width: 100%;\\r\\n  }\\r\\n\\r\\n  .result__score {\\r\\n    color: #37383c;\\r\\n    font-size: 34px;\\r\\n    font-weight: 300;\\r\\n    align-self: center;\\r\\n  }\\r\\n\\r\\n  .game__lists {\\r\\n    margin-top: 30px;\\r\\n  }\\r\\n\\r\\n  .result__true,\\r\\n  .result__false {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    align-items: flex-start;\\r\\n    font-size: 12px;\\r\\n    font-weight: 700;\\r\\n    line-height: 1.33;\\r\\n    text-transform: uppercase;\\r\\n    list-style: none;\\r\\n  }\\r\\n\\r\\n  .result__true {\\r\\n    color: #28c38a;\\r\\n    margin: 1rem 0;\\r\\n  }\\r\\n\\r\\n  .result__false {\\r\\n    color: #ed593b;\\r\\n  }\\r\\n\\r\\n  .result__word {\\r\\n    display: flex;\\r\\n    gap: 10px;\\r\\n    align-items: center;\\r\\n    color: #37383c;\\r\\n    font-size: 16px;\\r\\n    line-height: 1.25;\\r\\n    text-transform: lowercase;\\r\\n    font-weight: 500;\\r\\n    margin-top: 5px;\\r\\n  }\\r\\n\\r\\n  .result__word-en {\\r\\n    font-weight: 700;\\r\\n  }\\r\\n\\r\\n  .result__voice {\\r\\n    width: 33px;\\r\\n    height: 33px;\\r\\n    cursor: pointer;\\r\\n    svg {\\r\\n      width: 2rem;\\r\\n      height: 2rem;\\r\\n    }\\r\\n  }\\r\\n  .close-button {\\r\\n    border-radius: 50%;\\r\\n    width: 4rem;\\r\\n    height: 4rem;\\r\\n    text-align: center;\\r\\n    line-height: 22px;\\r\\n    font-size: 2rem;\\r\\n    min-width: min-content;\\r\\n  }\\r\\n\\r\\n  .mute-button {\\r\\n    margin: 4px;\\r\\n    font-size: 3rem;\\r\\n  }\\r\\n\\r\\n  .result__button {\\r\\n    margin-top: 1rem;\\r\\n    border: 2px solid #28c38a;\\r\\n    color: #3c3e3d;\\r\\n    font-size: 1.2rem;\\r\\n    &:hover {\\r\\n      background-color: #28c38a;\\r\\n      border: 2px solid #28c38a;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  .buttons-wrapper {\\r\\n    width: 100%;\\r\\n    display: flex;\\r\\n    align-items: center;\\r\\n    justify-content: space-between;\\r\\n  }\\r\\n}\\r\\n",".body {\\r\\n  &--sprint {\\r\\n    position: relative;\\r\\n    max-width: 100%;\\r\\n    min-height: 100vh;\\r\\n    padding: 0;\\r\\n    background-color: #0d3848;\\r\\n    background-image: url(\\"./assets/sprint/sprint-bg-bottom.svg\\"),\\r\\n      url(\\"./assets/sprint/sprint-bg-left.svg\\"),\\r\\n      url(\\"./assets/sprint/sprint-bg-right.svg\\");\\r\\n    background-repeat: no-repeat, no-repeat, no-repeat;\\r\\n    background-size: 100%, auto, auto;\\r\\n    background-position: bottom, 0 0, 100% 0;\\r\\n\\r\\n    h2 {\\r\\n      font-size: 24px;\\r\\n    }\\r\\n\\r\\n    .header {\\r\\n      position: absolute;\\r\\n      top: 0;\\r\\n      max-width: 1360px;\\r\\n      padding: 0 2rem;\\r\\n      background-color: transparent;\\r\\n      z-index: 10;\\r\\n      align-self: center;\\r\\n      color: #ffffff;\\r\\n      border: none;\\r\\n    }\\r\\n\\r\\n    .logo {\\r\\n      a {\\r\\n        color: #ffffff;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    .menu-item-link {\\r\\n      color: #ffffff;\\r\\n\\r\\n      &:hover {\\r\\n        border-bottom: 2px solid #ffffff;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    .btn-secondary {\\r\\n      color: #000000;\\r\\n    }\\r\\n\\r\\n    .enter-cabinet-link {\\r\\n      color: #ffffff;\\r\\n    }\\r\\n\\r\\n    .main {\\r\\n      padding: 75px 0;\\r\\n      display: flex;\\r\\n      min-height: 100vh;\\r\\n    }\\r\\n\\r\\n    .footer {\\r\\n      display: none;\\r\\n    }\\r\\n\\r\\n    .burger-line {\\r\\n      background-color: #ffffff;\\r\\n      &::after {\\r\\n        background-color: #ffffff;\\r\\n      }\\r\\n      &::before {\\r\\n        background-color: #ffffff;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    .opened {\\r\\n      background-color: #0d3848;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n.sprint {\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  padding: 20px 0;\\r\\n  color: #ffffff;\\r\\n  width: 100%;\\r\\n\\r\\n  .sprint__select-title {\\r\\n    font-size: 2.4rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.sprint__select {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  min-width: 50%;\\r\\n}\\r\\n\\r\\n.sprint__select-descr {\\r\\n  margin-top: 2rem;\\r\\n}\\r\\n\\r\\n.sprint__select-text {\\r\\n  margin-top: 2rem;\\r\\n}\\r\\n\\r\\n.sprint__levels {\\r\\n  margin-top: 20px;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n  width: 100%;\\r\\n  gap: 0.4rem;\\r\\n}\\r\\n\\r\\n.sprint__level {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  box-sizing: border-box;\\r\\n  width: 162px;\\r\\n  height: 55px;\\r\\n  border-radius: 3px;\\r\\n  border: 1px solid #ffffff;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.sprint__close {\\r\\n  position: absolute;\\r\\n  top: 10px;\\r\\n  right: 20px;\\r\\n  width: 40px;\\r\\n  height: 40px;\\r\\n  border-radius: 40px;\\r\\n  z-index: 1;\\r\\n  margin: 20px auto;\\r\\n  cursor: pointer;\\r\\n\\r\\n  &::before {\\r\\n    content: \\"+\\";\\r\\n    color: #ffffff;\\r\\n    position: absolute;\\r\\n    z-index: 2;\\r\\n    transform: rotate(45deg);\\r\\n    font-size: 50px;\\r\\n    line-height: 1;\\r\\n    top: -5px;\\r\\n    left: 6px;\\r\\n    transition: all 0.3s cubic-bezier(0.77, 0, 0.2, 0.85);\\r\\n  }\\r\\n\\r\\n  &::after {\\r\\n    content: \\"\\";\\r\\n    position: absolute;\\r\\n    top: 0;\\r\\n    left: 0;\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n    border-radius: 100%;\\r\\n    background: #ffffff;\\r\\n    z-index: 1;\\r\\n    transition: all 0.3s cubic-bezier(0.77, 0, 0.2, 0.85);\\r\\n    transform: scale(0.01);\\r\\n  }\\r\\n}\\r\\n\\r\\n.sprint__close:hover:after {\\r\\n  transform: scale(1);\\r\\n}\\r\\n\\r\\n.sprint__close:hover:before {\\r\\n  transform: scale(0.8) rotate(45deg);\\r\\n  color: #0d3848;\\r\\n}\\r\\n\\r\\n.timer {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.timer__time {\\r\\n  font-size: 30px;\\r\\n  font-weight: lighter;\\r\\n  width: 160px;\\r\\n  position: absolute;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.timer__svg {\\r\\n  transform: rotate(90deg) scaleX(-1);\\r\\n}\\r\\n\\r\\n.circle_animation {\\r\\n  stroke-dasharray: 440;\\r\\n  stroke-dashoffset: 0;\\r\\n  transition: all 1s linear;\\r\\n}\\r\\n\\r\\n.sprint__ready {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n}\\r\\n\\r\\n.timer--control {\\r\\n  position: absolute;\\r\\n  top: 20px;\\r\\n  left: 20px;\\r\\n}\\r\\n\\r\\n.sprint__control {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.control__sound {\\r\\n  position: absolute;\\r\\n  right: 0;\\r\\n  width: 23px;\\r\\n  height: 24px;\\r\\n  background-image: url(\\"./assets/sprint/sound-default.svg\\");\\r\\n  background-repeat: no-repeat;\\r\\n  cursor: pointer;\\r\\n\\r\\n  &--off {\\r\\n    background-image: url(\\"./assets/sprint/sound-mute.svg\\");\\r\\n  }\\r\\n}\\r\\n\\r\\n.control__container {\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  width: 500px;\\r\\n  padding: 30px;\\r\\n  margin-top: 10px;\\r\\n  border: 1px solid #ffffff;\\r\\n  border-radius: 10px;\\r\\n  background-color: hsla(0, 0%, 100%, 0.06);\\r\\n}\\r\\n\\r\\n.control__voice {\\r\\n  position: absolute;\\r\\n  right: 20px;\\r\\n  top: 20px;\\r\\n  width: 33px;\\r\\n  height: 33px;\\r\\n  background-image: url(\\"./assets/sprint/voice.svg\\");\\r\\n  background-repeat: no-repeat;\\r\\n  background-position: center;\\r\\n  cursor: pointer;\\r\\n\\r\\n  &:hover {\\r\\n    background-image: url(\\"./assets/sprint/voice-hover.svg\\");\\r\\n  }\\r\\n}\\r\\n\\r\\n.control__series-list {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  gap: 20px;\\r\\n}\\r\\n\\r\\n.control__series {\\r\\n  width: 26px;\\r\\n  height: 26px;\\r\\n  border-radius: 50%;\\r\\n  background-image: url(\\"./assets/sprint/circle-empty.svg\\");\\r\\n  background-position: 50%;\\r\\n  background-repeat: no-repeat;\\r\\n  background-size: contain;\\r\\n\\r\\n  &--active {\\r\\n    background-image: url(\\"./assets/sprint/true-series.svg\\");\\r\\n  }\\r\\n}\\r\\n\\r\\n.control__multiply {\\r\\n  margin-top: 10px;\\r\\n}\\r\\n\\r\\n.control__parrots {\\r\\n  display: flex;\\r\\n  width: 204px;\\r\\n  height: 57px;\\r\\n  margin-top: 30px;\\r\\n  background-image: url(\\"./assets/sprint/branch.svg\\");\\r\\n  background-repeat: no-repeat;\\r\\n  background-position: bottom;\\r\\n}\\r\\n\\r\\n.control__parrot {\\r\\n  position: relative;\\r\\n  top: 6px;\\r\\n}\\r\\n\\r\\n.control__word-en {\\r\\n  font-size: 36px;\\r\\n  margin-top: 20px;\\r\\n}\\r\\n\\r\\n.control__word-ru {\\r\\n  font-size: 24px;\\r\\n  color: hsla(0, 0%, 100%, 0.6);\\r\\n}\\r\\n\\r\\n.control__buttons {\\r\\n  display: flex;\\r\\n  gap: 20px;\\r\\n  margin-top: 40px;\\r\\n  padding-bottom: 40px;\\r\\n}\\r\\n\\r\\n.control__button {\\r\\n  position: relative;\\r\\n  border-radius: 4px;\\r\\n  color: #fff;\\r\\n  font-size: 20px;\\r\\n  font-weight: 400;\\r\\n  height: 50px;\\r\\n  text-align: center;\\r\\n  width: 183px;\\r\\n  cursor: pointer;\\r\\n\\r\\n  &::before {\\r\\n    bottom: -45px;\\r\\n    color: #7e919f;\\r\\n    display: block;\\r\\n    font-size: 28px;\\r\\n    position: absolute;\\r\\n  }\\r\\n\\r\\n  &--false {\\r\\n    background-color: #ed593b;\\r\\n\\r\\n    &::before {\\r\\n      content: \\"←\\";\\r\\n      left: 40%;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  &--true {\\r\\n    background-color: #28c38a;\\r\\n\\r\\n    &::before {\\r\\n      content: \\"→\\";\\r\\n      right: 40%;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n.sprint__result {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  background-color: #ffffff;\\r\\n  border: 1px solid #e6e9ee;\\r\\n  border-radius: 8px;\\r\\n  box-sizing: border-box;\\r\\n  max-width: 500px;\\r\\n  max-height: 500px;\\r\\n  padding: 42px 16px;\\r\\n  text-align: center;\\r\\n  width: 100%;\\r\\n  overflow-y: auto;\\r\\n}\\r\\n\\r\\n.result__score {\\r\\n  color: #37383c;\\r\\n  font-size: 34px;\\r\\n  font-weight: 300;\\r\\n  align-self: center;\\r\\n}\\r\\n\\r\\n.sprint__lists {\\r\\n  margin-top: 30px;\\r\\n}\\r\\n\\r\\n.result__true,\\r\\n.result__false {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: flex-start;\\r\\n  font-size: 12px;\\r\\n  font-weight: 700;\\r\\n  line-height: 1.33;\\r\\n  text-transform: uppercase;\\r\\n  list-style: none;\\r\\n}\\r\\n\\r\\n.result__true {\\r\\n  color: #28c38a;\\r\\n  margin-top: 20px;\\r\\n}\\r\\n\\r\\n.result__false {\\r\\n  color: #ed593b;\\r\\n}\\r\\n\\r\\n.result__word {\\r\\n  display: flex;\\r\\n  gap: 10px;\\r\\n  align-items: center;\\r\\n  color: #37383c;\\r\\n  font-size: 16px;\\r\\n  line-height: 1.25;\\r\\n  text-transform: lowercase;\\r\\n  font-weight: 500;\\r\\n  margin-top: 5px;\\r\\n}\\r\\n\\r\\n.result__word-en {\\r\\n  font-weight: 700;\\r\\n}\\r\\n\\r\\n.result__voice {\\r\\n  width: 33px;\\r\\n  height: 33px;\\r\\n  background-image: url(\\"./assets/sprint/voice-grey.svg\\");\\r\\n  background-repeat: no-repeat;\\r\\n  background-position: center;\\r\\n  cursor: pointer;\\r\\n\\r\\n  &:hover {\\r\\n    background-image: url(\\"./assets/sprint/voice-hover.svg\\");\\r\\n  }\\r\\n}\\r\\n\\r\\n.result__restart-btn {\\r\\n  background-color: rgba(37, 130, 231, 0.08);\\r\\n  border-radius: 4px;\\r\\n  color: #2582e7;\\r\\n  cursor: pointer;\\r\\n  font-size: 14px;\\r\\n  font-weight: 600;\\r\\n  line-height: 1.43;\\r\\n  margin-top: 24px;\\r\\n  padding: 10px 42px;\\r\\n  text-align: center;\\r\\n\\r\\n  &:hover {\\r\\n    background-color: rgba(37, 130, 231, 0.12);\\r\\n  }\\r\\n}\\r\\n\\r\\n.sprint__restart-message {\\r\\n  font-size: 14px;\\r\\n  width: 60%;\\r\\n  color: #ed593b;\\r\\n  margin-top: 10px;\\r\\n}\\r\\n",".textbook {\\r\\n  display: flex;\\r\\n  position: relative;\\r\\n  align-items: stretch;\\r\\n  width: 100%;\\r\\n  margin-top: -2px;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    flex-direction: column;\\r\\n  }\\r\\n}\\r\\n\\r\\n.aside {\\r\\n  padding: 2rem 1rem;\\r\\n  width: 15%;\\r\\n  flex-shrink: 0;\\r\\n  font-family: $headers-font;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    width: 100%;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    padding: 1rem 0.2rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.sidebar-content {\\r\\n  position: -webkit-sticky;\\r\\n  position: sticky;\\r\\n  top: 0;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  padding-right: 1.5rem;\\r\\n  // border-right: 1px solid $light-grey;\\r\\n  gap: 0.7rem;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    flex-direction: row;\\r\\n    flex-wrap: wrap;\\r\\n    justify-content: flex-start;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    gap: 0.3rem;\\r\\n    padding: 0;\\r\\n    justify-content: center;\\r\\n    row-gap: 1.8rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.sidebar-text {\\r\\n  font-size: 1.2rem;\\r\\n  font-weight: 600;\\r\\n  text-align: center;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    font-size: 1rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    display: none;\\r\\n  }\\r\\n}\\r\\n\\r\\n.btn-level {\\r\\n  @include display-flex-center;\\r\\n  height: 5.6rem;\\r\\n  width: 5.6rem;\\r\\n  border-radius: 50%;\\r\\n  padding: 2.5rem;\\r\\n  font-size: 2.5rem;\\r\\n  font-weight: 700;\\r\\n  cursor: pointer;\\r\\n  transition: 0.3s ease-in-out;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    height: 3.2rem;\\r\\n    width: 3.2rem;\\r\\n    padding: 0;\\r\\n    font-size: 1.5rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.userbook-mark {\\r\\n  display: flex;\\r\\n  position: absolute;\\r\\n  bottom: 3.8rem;\\r\\n  right: 2.4rem;\\r\\n  background: $secondary-color;\\r\\n  color: $accent-color;\\r\\n  border-radius: 30px;\\r\\n  padding: 0.5rem;\\r\\n  box-shadow: $box-shadow;\\r\\n  .material-icons-outlined {\\r\\n    font-size: 1.3rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    bottom: 2rem;\\r\\n    right: 1rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    right: 9.1rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.text-book-page {\\r\\n  @include section-bg-colored;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  padding: 0 2.5rem 1.5rem;\\r\\n  width: 85%;\\r\\n  border: 3px solid #ffffff;\\r\\n  margin-bottom: 1.5rem;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n   width: 100%;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    padding: 1rem;\\r\\n   }\\r\\n}\\r\\n\\r\\n.text-book-page-head {\\r\\n  display: flex;\\r\\n  padding: 2.5rem;\\r\\n  align-items: center;\\r\\n  gap: 1.5rem;\\r\\n  margin-right: auto;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    padding: 2.5rem 1.2rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    flex-direction: column;\\r\\n    gap: 0.5rem;\\r\\n    padding: 1.5rem;\\r\\n    margin: 0;\\r\\n  }\\r\\n}\\r\\n\\r\\n.cards-wrapper {\\r\\n  display: flex;\\r\\n  flex-direction: row;\\r\\n  justify-content: space-around;\\r\\n  flex-wrap: wrap;\\r\\n  row-gap: 1rem;\\r\\n}\\r\\n\\r\\n.card {\\r\\n  @include card-style;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  width: 32rem;\\r\\n  height: 25rem;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n    height: auto;\\r\\n  }\\r\\n}\\r\\n\\r\\n.card-main-info-wrapper {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  font-family: $headers-font;\\r\\n  padding-bottom: 1.5rem;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    flex-direction: column;\\r\\n    padding-bottom: 1rem;\\r\\n   }\\r\\n}\\r\\n\\r\\n.btn-play {\\r\\n  margin-left: -2rem;\\r\\n  &:hover {\\r\\n    background-color: $secondary-color;\\r\\n  }\\r\\n  svg {\\r\\n    width: 25px;\\r\\n    height: 25px;\\r\\n    path {\\r\\n      fill: $dark-color;\\r\\n      stroke: $dark-color;\\r\\n    }\\r\\n    &:hover {\\r\\n      fill: $accent-color;\\r\\n      path {\\r\\n        fill: $accent-color;\\r\\n        stroke: $accent-color;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    margin-left: 0;\\r\\n    margin-top: -2rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.card-img {\\r\\n  width: 10rem;\\r\\n  height: 8rem;\\r\\n  border-radius: 30px;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n    height: 10rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.card-word-info {\\r\\n  padding-left: 0.8rem;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    text-align: center;\\r\\n  }\\r\\n}\\r\\n\\r\\n.word {\\r\\n  font-size: 1.8rem;\\r\\n  font-weight: 700;\\r\\n}\\r\\n\\r\\n.word-transcription {\\r\\n  font-size: 1rem;\\r\\n  color: $mid-grey;\\r\\n  padding-bottom: 0.8rem;\\r\\n}\\r\\n\\r\\n.word-translate {\\r\\n  font-size: 1.3rem;\\r\\n}\\r\\n\\r\\n.user-btns {\\r\\n  margin-left: auto;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  gap: 0.5rem;\\r\\n  align-items: center;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    flex-direction: row;\\r\\n    margin: auto;\\r\\n    padding-top: 1rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.answers {\\r\\n  font-size: 0.8rem;\\r\\n}\\r\\n\\r\\n.hard-word-btn {\\r\\n  border-color: $accent-color;\\r\\n  background-color: $accent-color;\\r\\n  .btn-icon {\\r\\n    color: $secondary-color;\\r\\n  }\\r\\n}\\r\\n\\r\\n.learn-word-btn {\\r\\n  border-color: $secondary-color;\\r\\n  background-color: $secondary-color;\\r\\n  .btn-icon {\\r\\n    color: $accent-color;\\r\\n  }\\r\\n}\\r\\n\\r\\n.word-mean-translate, .word-ex-translate {\\r\\n  color: $mid-grey;\\r\\n  line-height: 1.6;\\r\\n  font-style: italic;\\r\\n}\\r\\n\\r\\n.word-mean-translate {\\r\\n  padding-bottom: 1rem;\\r\\n}\\r\\n\\r\\n.pagination {\\r\\n  @include display-flex-center;\\r\\n  padding: 2.5rem 1rem 0;\\r\\n}\\r\\n\\r\\n.page-input {\\r\\n  margin: 0 3rem;\\r\\n  width: 2rem;\\r\\n  font-size: 1.5rem;\\r\\n  font-weight: 600;\\r\\n  font-family: $headers-font;\\r\\n  border-bottom: 1px solid;\\r\\n  text-align: center;\\r\\n  &:focus-visible {\\r\\n    outline: none;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    margin: 0 0.5rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Chrome, Safari, Edge, Opera */\\r\\n.page-input::-webkit-outer-spin-button,\\r\\n.page-input::-webkit-inner-spin-button {\\r\\n  -webkit-appearance: none;\\r\\n  margin: 0;\\r\\n}\\r\\n\\r\\n/* Firefox */\\r\\n.page-input {\\r\\n  -moz-appearance: textfield;\\r\\n}",".user-page {\\r\\n  @include section-bg-colored;\\r\\n  background-color: $l2;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  padding: 2rem 1rem 1rem;\\r\\n  gap: 1.5rem;\\r\\n  \\r\\n}\\r\\n\\r\\n.user-sidebar {\\r\\n  display: flex;\\r\\n  gap: 1.5rem;\\r\\n  flex-direction: column;\\r\\n  width: 36%;\\r\\n  padding: 2.5rem 1.5rem 1.5rem;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n    padding: 0 1rem 1.5rem;\\r\\n    align-items: center;\\r\\n  }\\r\\n}\\r\\n\\r\\n.user-section {\\r\\n  display: flex;\\r\\n  padding-bottom: 1rem;\\r\\n  gap: 2.5rem;\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    gap: 0;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    flex-direction: column;\\r\\n  }\\r\\n}\\r\\n\\r\\n.enter-cabinet-link {\\r\\n  color: $dark-color;\\r\\n  font-weight: 600;\\r\\n}\\r\\n\\r\\n.exit-cabinet-btn {\\r\\n  width: 10rem;\\r\\n}",".hero-section {\\r\\n  @include display-flex-center;\\r\\n  flex-direction: column;\\r\\n  padding: 3rem;\\r\\n  background: center / cover no-repeat url(\\"./assets/main-bg1.jpg\\");\\r\\n  border-radius: 30px;\\r\\n  @media (max-width: $breakpoint-laptop) {\\r\\n    padding: 1.5rem;\\r\\n    padding-top: 2.5rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    padding: 3.5rem 2rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    padding: 2.5rem 1.5rem;\\r\\n  }\\r\\n  box-shadow: inset -1px -1px 3px rgba(255, 255, 255, 0.75),\\r\\n    inset 1px 1px 2px rgba(7, 7, 69, 0.15);\\r\\n}\\r\\n\\r\\n.hero-section-header {\\r\\n  width: 50%;\\r\\n  text-align: center;\\r\\n  line-height: 1;\\r\\n  padding-bottom: 2rem;\\r\\n  @media (max-width: $breakpoint-laptop) {\\r\\n    width: 60%;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    width: 100%;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.hero-section-text {\\r\\n  text-align: center;\\r\\n  width: 60%;\\r\\n  padding-bottom: 1.5rem;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.advantages-section {\\r\\n  display: flex;\\r\\n  padding: 0;\\r\\n  margin-top: 4.5rem;\\r\\n  gap: 1rem;\\r\\n  flex-wrap: wrap;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.advantage_wrapper {\\r\\n  @include card-style;\\r\\n  text-align: center;\\r\\n  padding: 1rem;\\r\\n  width: 23%;\\r\\n  @media (max-width: $breakpoint-laptop) {\\r\\n    width: 48%;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    width: 100%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.advantage-header {\\r\\n  position: relative;\\r\\n  font-size: 2rem;\\r\\n  padding-bottom: 1rem;\\r\\n  padding-top: 1rem;\\r\\n  &::after {\\r\\n    position: absolute;\\r\\n    content: \\"\\";\\r\\n    height: 2px;\\r\\n    background-color: $dark-color;\\r\\n    width: 30%;\\r\\n    bottom: 0;\\r\\n    left: 34.5%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.advantage-image {\\r\\n  width: 100%;\\r\\n  border-radius: 30px;\\r\\n}\\r\\n\\r\\n.advantage-text {\\r\\n  padding-top: 1rem;\\r\\n  padding-bottom: 1rem;\\r\\n}\\r\\n\\r\\n.info-section {\\r\\n  @include display-flex-space-between;\\r\\n  padding: $section-padding;\\r\\n}\\r\\n\\r\\n.info-text-wrapper {\\r\\n  width: 40%;\\r\\n  padding: 0 4.5rem;\\r\\n}\\r\\n\\r\\n.info-header {\\r\\n  font-size: 1.5rem;\\r\\n  padding-bottom: 2rem;\\r\\n}\\r\\n\\r\\n.info-text {\\r\\n  list-style: none;\\r\\n  padding-bottom: 0.7rem;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.info-text-icon {\\r\\n  padding-right: 0.5rem;\\r\\n}\\r\\n\\r\\n.info-image {\\r\\n  @include section-bg-colored;\\r\\n  background: center / cover no-repeat url(\\"./assets/info-section2.jpg\\");\\r\\n  width: 50%;\\r\\n  height: 25rem;\\r\\n}\\r\\n\\r\\n.team-section {\\r\\n  // @include section-bg-colored;\\r\\n  padding: $section-padding;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  flex-direction: column;\\r\\n  margin-bottom: 2.5rem;\\r\\n}\\r\\n\\r\\n.team-section-header {\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.team-members {\\r\\n  display: flex;\\r\\n  gap: 1.5rem;\\r\\n  padding-top: 2.5rem;\\r\\n  flex-wrap: wrap;\\r\\n  justify-content: center;\\r\\n  @media (max-width: $breakpoint-laptop) {\\r\\n    width: 100%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.team-member {\\r\\n  @include card-style;\\r\\n  padding: 1rem;\\r\\n  width: 30%;\\r\\n  display: flex;\\r\\n  justify-content: flex-start;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  @media (max-width: $breakpoint-tablet-vertical) {\\r\\n    width: 100%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.team-member-name {\\r\\n  font-size: 1.6rem;\\r\\n  padding: 1rem 0 0;\\r\\n}\\r\\n\\r\\n.team-member-img {\\r\\n  width: 100%;\\r\\n  border-radius: 30px;\\r\\n}\\r\\n\\r\\n.member-duty {\\r\\n  font-size: 0.9rem;\\r\\n  line-height: 2;\\r\\n  padding-bottom: 1rem;\\r\\n  color: $mid-grey;\\r\\n}\\r\\n\\r\\n.member-actions {\\r\\n  text-align: center;\\r\\n  padding-bottom: 1rem;\\r\\n  flex-grow: 1;\\r\\n  & ul {\\r\\n    text-align: left;\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n    justify-content: space-between;\\r\\n    height: 100%;\\r\\n  }\\r\\n  & li {\\r\\n    list-style: none;\\r\\n    padding-bottom: 0.3rem;\\r\\n    text-align: center;\\r\\n  }\\r\\n}\\r\\n\\r\\n.git-icon {\\r\\n  width: 50px;\\r\\n  height: 50px;\\r\\n  margin-top: auto;\\r\\n  background-image: url(\\"data:image/svg+xml,%3Csvg width=\'50px\' height=\'50px\' viewBox=\'0 0 1024 1024\' xmlns=\'http://www.w3.org/2000/svg\' class=\'icon-git\'%3E%3Cpath d=\'M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z\'%3E%3C/path%3E%3C/svg%3E\\");\\r\\n  filter: none;\\r\\n  transition: all 0.5s;\\r\\n  border-radius: 50%;\\r\\n  background-color: white;\\r\\n  &:hover {\\r\\n    filter: invert(1);\\r\\n  }\\r\\n}\\r\\n",".charts {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-around;\\r\\n  flex-wrap: wrap;\\r\\n  width: 100%;\\r\\n  padding: 20px;\\r\\n  @media (max-width: $breakpoint-laptop) {\\r\\n    gap: 1.5rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n  }\\r\\n}\\r\\n\\r\\n.chart {\\r\\n  width: 35%;\\r\\n  height: 300px;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n    height: max-content;\\r\\n  }\\r\\n}",".todaystat-wrapper {\\r\\n  @include card-style;\\r\\n  padding: 1.6rem;\\r\\n  font-family: $headers-font;\\r\\n  width: 62%;\\r\\n  display: flex;\\r\\n  justify-content: space-around;\\r\\n  .word-wrapper {\\r\\n    width: 100%;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n    padding: 0.5rem;\\r\\n  }\\r\\n}\\r\\n \\r\\n.wrapper_daily-stat {\\r\\n  @include display-flex-center;\\r\\n  flex-direction: column;\\r\\n  width: 100%;\\r\\n  font-size: 1.3rem;\\r\\n  color: $dark-color;\\r\\n  font-family: $headers-font;\\r\\n  gap: 1rem;\\r\\n}\\r\\n\\r\\n.daystat-wrapper {\\r\\n  @include card-style;\\r\\n  font-family: $headers-font;\\r\\n  display: flex;\\r\\n  justify-content: space-around;\\r\\n  align-items: center;\\r\\n  width: 100%;\\r\\n  padding-bottom: 1.5rem;\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    flex-wrap: wrap;\\r\\n    gap: 1rem;\\r\\n    .word-wrapper {\\r\\n      width: 48%;\\r\\n    }\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    flex-wrap: nowrap;\\r\\n    flex-direction: column;\\r\\n    gap: 1rem;\\r\\n    .word-wrapper {\\r\\n      width: 100%;\\r\\n    }\\r\\n  }\\r\\n} \\r\\n\\r\\n\\r\\n.data-wrapper-row1, .data-wrapper-row2 {\\r\\n  display: flex;\\r\\n  padding: 1rem;\\r\\n  gap: 1rem;\\r\\n  flex-direction: column;\\r\\n  width: 50%;\\r\\n  justify-content: space-between;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    padding: 5px;\\r\\n  }\\r\\n}\\r\\n\\r\\n.data-wrapper-row1 {\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.stat-data-item {\\r\\n  @include display-flex-space-between;\\r\\n  padding-bottom: 0.5rem;\\r\\n}\\r\\n\\r\\n.date-row {\\r\\n  padding-right: 6.5rem;\\r\\n  padding-top: 1.6rem;\\r\\n  padding-left: 2rem;\\r\\n  text-align: center;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    padding-right: 2.8rem;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    padding-top: 2.8rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.first-day-text {\\r\\n  line-height: 1.2;\\r\\n}\\r\\n\\r\\n.first-day-date {\\r\\n  font-size: 1.6rem;\\r\\n  font-weight: 700;\\r\\n  line-height: 1.6;\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    font-size: 1rem;\\r\\n  }\\r\\n}\\r\\n\\r\\n.word-text {\\r\\n  font-size: 1.2rem;\\r\\n  font-weight: 700;\\r\\n  padding-bottom: 0.5rem;\\r\\n}\\r\\n\\r\\n.stat-data-param {\\r\\n  padding-right: 1rem;\\r\\n  font-family: $text-font;\\r\\n  font-size: 0.9rem;\\r\\n}\\r\\n\\r\\n.stat-data-value {\\r\\n  font-weight: 600;\\r\\n  font-size: 0.9rem;\\r\\n}\\r\\n\\r\\n.date-text {\\r\\n  font-size: 1.2rem;\\r\\n  font-weight: 700;\\r\\n  @media (max-width: $breakpoint-tablet) {\\r\\n    width: 48%;\\r\\n  }\\r\\n  @media (max-width: $breakpoint-mobile) {\\r\\n    width: 100%;\\r\\n  }\\r\\n}"],"sourceRoot":""}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUE4Qix3QkFBd0IsS0FBSywwQkFBMEIsdUJBQXVCLHdCQUF3QixLQUFLLG9CQUFvQix3QkFBd0IsdUJBQXVCLDhDQUE4QyxtQkFBbUIsT0FBTyw4Q0FBOEMsb0JBQW9CLE9BQU8sS0FBSyxtQkFBbUI7QUFDOTEvRTtBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9nbG9iYWwuc2Nzcz9mOTc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyA9IG5ldyBVUkwoXCIuL2Fzc2V0cy9zcHJpbnQvc3ByaW50LWJnLWJvdHRvbS5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyA9IG5ldyBVUkwoXCIuL2Fzc2V0cy9zcHJpbnQvc3ByaW50LWJnLWxlZnQuc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzJfX18gPSBuZXcgVVJMKFwiLi9hc3NldHMvc3ByaW50L3NwcmludC1iZy1yaWdodC5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfM19fXyA9IG5ldyBVUkwoXCIuL2Fzc2V0cy9zcHJpbnQvc291bmQtZGVmYXVsdC5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNF9fXyA9IG5ldyBVUkwoXCIuL2Fzc2V0cy9zcHJpbnQvc291bmQtbXV0ZS5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNV9fXyA9IG5ldyBVUkwoXCIuL2Fzc2V0cy9zcHJpbnQvdm9pY2Uuc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzZfX18gPSBuZXcgVVJMKFwiLi9hc3NldHMvc3ByaW50L3ZvaWNlLWhvdmVyLnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF83X19fID0gbmV3IFVSTChcIi4vYXNzZXRzL3NwcmludC9jaXJjbGUtZW1wdHkuc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzhfX18gPSBuZXcgVVJMKFwiLi9hc3NldHMvc3ByaW50L3RydWUtc2VyaWVzLnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF85X19fID0gbmV3IFVSTChcIi4vYXNzZXRzL3NwcmludC9icmFuY2guc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzEwX19fID0gbmV3IFVSTChcIi4vYXNzZXRzL3NwcmludC92b2ljZS1ncmV5LnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xMV9fXyA9IG5ldyBVUkwoXCIuL2Fzc2V0cy9tYWluLWJnMS5qcGdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMTJfX18gPSBuZXcgVVJMKFwiLi9hc3NldHMvaW5mby1zZWN0aW9uMi5qcGdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMTNfX18gPSBuZXcgVVJMKFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB3aWR0aD0lMjc1MHB4JTI3IGhlaWdodD0lMjc1MHB4JTI3IHZpZXdCb3g9JTI3MCAwIDEwMjQgMTAyNCUyNyB4bWxucz0lMjdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyNyBjbGFzcz0lMjdpY29uLWdpdCUyNyUzRSUzQ3BhdGggZD0lMjdNNTExLjYgNzYuM0MyNjQuMyA3Ni4yIDY0IDI3Ni40IDY0IDUyMy41IDY0IDcxOC45IDE4OS4zIDg4NSAzNjMuOCA5NDZjMjMuNSA1LjkgMTkuOS0xMC44IDE5LjktMjIuMnYtNzcuNWMtMTM1LjcgMTUuOS0xNDEuMi03My45LTE1MC4zLTg4LjlDMjE1IDcyNiAxNzEuNSA3MTggMTg0LjUgNzAzYzMwLjktMTUuOSA2Mi40IDQgOTguOSA1Ny45IDI2LjQgMzkuMSA3Ny45IDMyLjUgMTA0IDI2IDUuNy0yMy41IDE3LjktNDQuNSAzNC43LTYwLjgtMTQwLjYtMjUuMi0xOTkuMi0xMTEtMTk5LjItMjEzIDAtNDkuNSAxNi4zLTk1IDQ4LjMtMTMxLjctMjAuNC02MC41IDEuOS0xMTIuMyA0LjktMTIwIDU4LjEtNS4yIDExOC41IDQxLjYgMTIzLjIgNDUuMyAzMy04LjkgNzAuNy0xMy42IDExMi45LTEzLjYgNDIuNCAwIDgwLjIgNC45IDExMy41IDEzLjkgMTEuMy04LjYgNjcuMy00OC44IDEyMS4zLTQzLjkgMi45IDcuNyAyNC43IDU4LjMgNS41IDExOCAzMi40IDM2LjggNDguOSA4Mi43IDQ4LjkgMTMyLjMgMCAxMDIuMi01OSAxODguMS0yMDAgMjEyLjlhMTI3LjUgMTI3LjUgMCAwIDEgMzguMSA5MXYxMTIuNWMuOCA5IDAgMTcuOSAxNSAxNy45IDE3Ny4xLTU5LjcgMzA0LjYtMjI3IDMwNC42LTQyNC4xIDAtMjQ3LjItMjAwLjQtNDQ3LjMtNDQ3LjUtNDQ3LjN6JTI3JTNFJTNDL3BhdGglM0UlM0Mvc3ZnJTNFXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Nb250c2VycmF0Oml0YWwsd2dodEAwLDQwMDswLDUwMDswLDYwMDswLDcwMDswLDgwMDsxLDQwMDsxLDUwMCZmYW1pbHk9T3BlbitTYW5zOml0YWwsd2dodEAwLDQwMDswLDcwMDsxLDQwMCZkaXNwbGF5PXN3YXApO1wiXSk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8yX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMl9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfM19fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzNfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzRfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF80X19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF81X19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfNV9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfNl9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzZfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzdfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF83X19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF84X19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfOF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfOV9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzlfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzEwX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMTBfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzExX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMTFfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzEyX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMTJfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzEzX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMTNfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiYXt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjojMzMzfS5idG4sLmJ0bi1zZWNvbmRhcnl7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMTkxYTE1O2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6MnJlbTtmb250LWZhbWlseTpcXFwiTW9udHNlcnJhdFxcXCIsc2Fucy1zZXJpZjtmb250LXNpemU6MXJlbTtwYWRkaW5nOi41cmVtIDEuMnJlbTtjdXJzb3I6cG9pbnRlcjt0cmFuc2l0aW9uOi41cyBhbGwgZWFzZS1pbi1vdXR9LmJ0bl9fZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLDApO2JvcmRlcjoxcHggc29saWQgI2ExYTFhMTtjb2xvcjojYTFhMWExO3BvaW50ZXItZXZlbnRzOm5vbmV9LmJ0bjpkaXNhYmxlZCwuYnRuLXNlY29uZGFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsMCk7Ym9yZGVyOjFweCBzb2xpZCAjYTFhMWExO2NvbG9yOiNhMWExYTE7cG9pbnRlci1ldmVudHM6bm9uZX0uYnRuLXNlY29uZGFyeXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjJweCBzb2xpZCAjMzMyYTdjO2NvbG9yOiMzMzJhN2N9LnZpZGVvLWJ0bntwYWRkaW5nOjAgMXJlbSAwIC4ycmVtO2JvcmRlci1jb2xvcjojZmZmO2JveC1zaGFkb3c6cmdiYSgwLDAsMCwuMikgMHB4IDEycHggMjhweCAwcHgscmdiYSgwLDAsMCwuMSkgMHB4IDJweCA0cHggMHB4LHJnYmEoMjU1LDI1NSwyNTUsLjA1KSAwcHggMHB4IDBweCAxcHggaW5zZXR9LnZpZGVvLWJ0bjpob3Zlcntib3gtc2hhZG93OjBweCAxcHggNHB4IDFweCByZ2JhKDUwLDUwLDcxLC4xNSl9LnZpZGVvLWJ0biAudmlkZW8taWNvbntmb250LXNpemU6M3JlbTtwYWRkaW5nLXJpZ2h0Oi41cmVtfS5idG4tcGxheXt3aWR0aDozLjVyZW07aGVpZ2h0OjMuNXJlbTtwYWRkaW5nOjA7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JveC1zaGFkb3c6MHB4IDFweCA0cHggMXB4IHJnYmEoNTAsNTAsNzEsLjE1KX0uYnRuLWxldmVse2JveC1zaGFkb3c6MHB4IDFweCA0cHggMXB4IHJnYmEoNTAsNTAsNzEsLjE1KTtib3JkZXI6MnB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmJ0bi1sZXZlbDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmRkYjB9LmJ0bi1sZXZlbC5idG4tYWN0aXZle2JvcmRlci1jb2xvcjojMzMyYTdjO2NvbG9yOiMxOTFhMTV9LmJ0bi1sZXZlbHtib3gtc2hhZG93OjBweCAxcHggNHB4IDFweCByZ2JhKDUwLDUwLDcxLC4xNSl9LmJ0bi1sZXZlbC0xe2JhY2tncm91bmQtY29sb3I6I2ZjZmNmZn0uYnRuLWxldmVsLTJ7YmFja2dyb3VuZC1jb2xvcjojZjRmNGZmfS5idG4tbGV2ZWwtM3tiYWNrZ3JvdW5kLWNvbG9yOiNmMGYwZmZ9LmJ0bi1sZXZlbC00e2JhY2tncm91bmQtY29sb3I6I2VhZWFmZn0uYnRuLWxldmVsLTV7YmFja2dyb3VuZC1jb2xvcjojZTRlNGZmfS5idG4tbGV2ZWwtNntiYWNrZ3JvdW5kLWNvbG9yOiNkZWRlZmZ9LnVzZXItd29yZHMtYnRue2JhY2tncm91bmQtY29sb3I6IzMzMmE3Yztjb2xvcjojZmZkZGIwO3Bvc2l0aW9uOnJlbGF0aXZlfS51c2VyLXdvcmRzLWJ0bi5idG4tYWN0aXZle2JhY2tncm91bmQtY29sb3I6I2ZmZGRiMDtjb2xvcjojMzMyYTdjfS51c2VyLXdvcmRzLWJ0bjo6YWZ0ZXJ7Y29udGVudDpcXFwi7qiZXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtmb250LWZhbWlseTpNYXRlcmlhbCBJY29ucyBPdXRsaW5lZDtmb250LXNpemU6MS4zcmVtO2ZvbnQtd2VpZ2h0OjMwMDtmb250LXN0eWxlOm5vcm1hbDtiYWNrZ3JvdW5kOiNmZmRkYjA7Y29sb3I6IzMzMmE3YztwYWRkaW5nOi41cmVtO2JveC1zaGFkb3c6MHB4IDFweCA0cHggMXB4IHJnYmEoNTAsNTAsNzEsLjE1KTtib3JkZXItcmFkaXVzOjMwcHg7cmlnaHQ6LTE1cHg7dG9wOi02cHh9LnVzZXItd29yZHMtYnRuOmhvdmVye2NvbG9yOiMzMzJhN2N9LmJ0bjpkaXNhYmxlZCwuYnRuLXNlY29uZGFyeTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsMCk7Ym9yZGVyOjFweCBzb2xpZCAjYTFhMWExO2NvbG9yOiNhMWExYTF9LmJ0bi1hZGQsLmJ0bi1sZWFybntwYWRkaW5nOi41cmVtO3dpZHRoOjNyZW07aGVpZ2h0OjNyZW19aDEsaDIsaDMsaDR7Zm9udC1mYW1pbHk6XFxcIk1vbnRzZXJyYXRcXFwiLHNhbnMtc2VyaWZ9aDF7Zm9udC1zaXplOjQuN3JlbX1AbWVkaWEobWF4LXdpZHRoOiA3NjhweCl7aDF7Zm9udC1zaXplOjMuNXJlbX19aDJ7Zm9udC1zaXplOjIuNHJlbX0udXNlci1pY29ue2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwwKTtmb250LXNpemU6NDVweDtib3JkZXItcmFkaXVzOjUwJTt0cmFuc2l0aW9uOmFsbCAuNXN9LnVzZXItaWNvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmRkYjB9Lm1vZGFsLW92ZXJsYXl7Zm9udC1mYW1pbHk6XFxcIk1vbnRzZXJyYXRcXFwiLHNhbnMtc2VyaWY7cG9zaXRpb246Zml4ZWQ7bGVmdDowO3RvcDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQtY29sb3I6cmdiYSg0MSw0MSw0MSwuNik7Y3Vyc29yOnBvaW50ZXI7ei1pbmRleDo1fS5tb2RhbC1vdmVybGF5OmhvdmVyIC5tb2RhbC1jbG9zZS1idG57YmFja2dyb3VuZC1jb2xvcjojMTkxYTE1fS5tb2RhbC13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjUwJTtoZWlnaHQ6YXV0bzt6LWluZGV4OjY7Y3Vyc29yOmRlZmF1bHQ7YmFja2dyb3VuZC1jb2xvcjojZmZmO3BhZGRpbmc6M3JlbTtib3JkZXItcmFkaXVzOjFyZW19Lm1vZGFsLWNsb3NlLWJ0bntkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7d2lkdGg6NTJweDtoZWlnaHQ6NTJweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotNTJweDt0b3A6LTUycHg7Ym9yZGVyLXJhZGl1czo1MHB4O2N1cnNvcjpwb2ludGVyO3RyYW5zaXRpb246LjNzIGVhc2UtaW4tb3V0O3otaW5kZXg6Nn0ubW9kYWwtY2xvc2UtYnRuOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2ZmZn0ubW9kYWxfd3JhcHBlcjpob3ZlciAubW9kYWwtY2xvc2UtYnRue2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwwKX0ubW9kYWwtZXJyLW1lc3NhZ2V7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZy1ib3R0b206MS4ycmVtO2NvbG9yOnJlZH0ubW9kYWwtbWVzc2FnZXtjb2xvcjojMzMyYTdjO3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZToxLjJyZW07Zm9udC13ZWlnaHQ6NjAwfS5mb3JtLXdyYXBwZXIgZm9ybXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtd3JhcDpub3dyYXA7YWxpZ24tY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cm93LWdhcDoxLjVyZW19LmZvcm0td3JhcHBlciAuaW5wdXQtd3JhcHBlcnt3aWR0aDo5MCU7dGV4dC1hbGlnbjpjZW50ZXJ9LmZvcm0td3JhcHBlciBpbnB1dHtoZWlnaHQ6M3JlbTt3aWR0aDoxMDAlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkO3BhZGRpbmc6MCAuNXJlbTtmb250LXNpemU6MS4ycmVtO2ZvbnQtZmFtaWx5OlxcXCJNb250c2VycmF0XFxcIixzYW5zLXNlcmlmfS5mb3JtLXdyYXBwZXIgaW5wdXQ6Zm9jdXMtdmlzaWJsZXtvdXRsaW5lOm5vbmV9LmZvcm0td3JhcHBlciAuYnRuLXN1Ym1pdHttYXJnaW4tdG9wOjFyZW19LmVycm9yLW1lc3NhZ2UsLmVycm9yLWluLWZvcm17Y29sb3I6cmVkfSosKjpiZWZvcmUsKjphZnRlcntwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7Ym94LXNpemluZzpib3JkZXItYm94fS5ib2R5e2ZvbnQtZmFtaWx5OlxcXCJPcGVuIFNhbnNcXFwiLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7Y29sb3I6IzMzMzttYXJnaW46MCBhdXRvO3BhZGRpbmc6MCAyLjVyZW07ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1jb250ZW50OnN0cmV0Y2g7ZmxleC13cmFwOm5vd3JhcDttYXgtd2lkdGg6MTQ0MHB4O21pbi1oZWlnaHQ6MTAwdmh9QG1lZGlhKG1heC13aWR0aDogNzY4cHgpey5ib2R5e3BhZGRpbmc6MCAxcmVtfX0uaGVhZGVye2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1mYW1pbHk6XFxcIk1vbnRzZXJyYXRcXFwiLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZToxcmVtO2xpbmUtaGVpZ2h0OjEuMjtoZWlnaHQ6NzVweDttYXJnaW46YXV0bzt3aWR0aDoxMDAlO3otaW5kZXg6MTtwYWRkaW5nOjAgMnJlbX0ubG9nb3tmb250LXNpemU6MS41cmVtO2xpbmUtaGVpZ2h0OjEuNDtmb250LXdlaWdodDo4MDB9QG1lZGlhKG1heC13aWR0aDogNzY4cHgpey5sb2dve2xpbmUtaGVpZ2h0OjEuMX19QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5sb2dve2ZvbnQtc2l6ZToxLjJyZW07bGluZS1oZWlnaHQ6MS4xfX1AbWVkaWEobWF4LXdpZHRoOiA2MDBweCl7LmhlYWRlci1tZW51e3Bvc2l0aW9uOmZpeGVkO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDozMjBweDtoZWlnaHQ6MTAwdmg7dG9wOjA7YmFja2dyb3VuZC1jb2xvcjojZmZmO3JpZ2h0Oi0zMjBweDt6LWluZGV4OjI7Zm9udC1zaXplOjMycHg7bGluZS1oZWlnaHQ6NTEuMnB4O292ZXJmbG93LXg6aGlkZGVuO3RyYW5zaXRpb246YWxsIC44cyBlYXNlLWluLW91dH19Lm1lbnUtaXRlbXN7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2xpc3Qtc3R5bGU6bm9uZX1AbWVkaWEobWF4LXdpZHRoOiA2MDBweCl7Lm1lbnUtaXRlbXN7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2xpbmUtaGVpZ2h0OjQ4cHg7Z2FwOjQzcHh9fS5tZW51LWl0ZW0tbGlua3tjdXJzb3I6cG9pbnRlcjtmb250LXdlaWdodDo2MDA7cGFkZGluZzoyOXB4fS5tZW51LWl0ZW0tbGluazpob3Zlcntib3JkZXItYm90dG9tOjJweCBzb2xpZCAjMTkxYTE1O3BhZGRpbmctYm90dG9tOjI3cHh9LmF1dGh7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2dhcDoxcmVtfS5idXJnZXItaWNvbntkaXNwbGF5Om5vbmV9QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey5idXJnZXItaWNvbntkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMHB4O2hlaWdodDoyMnB4O21hcmdpbjowIDFyZW07ei1pbmRleDo5O2N1cnNvcjpwb2ludGVyO3RyYW5zaXRpb246LjVzfX1AbWVkaWEobWF4LXdpZHRoOiA2MDBweCl7LmJ1cmdlci1saW5le2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6IzE5MWExNTtoZWlnaHQ6MnB4O3dpZHRoOjEwMCU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX0uYnVyZ2VyLWxpbmU6OmJlZm9yZXtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiMxOTFhMTU7aGVpZ2h0OjJweDt3aWR0aDoxMDAlO3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7Y29udGVudDpcXFwiXFxcIjttYXJnaW4tdG9wOjEwcHg7YmFja2dyb3VuZC1jb2xvcjojMTkxYTE1fS5idXJnZXItbGluZTo6YWZ0ZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojMTkxYTE1O2hlaWdodDoycHg7d2lkdGg6MTAwJTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO2NvbnRlbnQ6XFxcIlxcXCI7bWFyZ2luLXRvcDotMTBweDtiYWNrZ3JvdW5kLWNvbG9yOiMxOTFhMTV9fS5jbGlja2Vke3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpO3otaW5kZXg6OTl9Lm9wZW5lZHtyaWdodDowfS5mb290ZXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LWZhbWlseTpcXFwiTW9udHNlcnJhdFxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOi45cmVtO2xpbmUtaGVpZ2h0OjEuMTttaW4taGVpZ2h0OjkwcHg7bWFyZ2luOmF1dG87d2lkdGg6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOiMxOTFhMTU7Y29sb3I6I2ZmZjtwYWRkaW5nOjAgMjBweDtmbGV4LXdyYXA6d3JhcH1AbWVkaWEobWF4LXdpZHRoOiA2MDBweCl7LmZvb3RlcntmbGV4LWRpcmVjdGlvbjpjb2x1bW47Z2FwOjFyZW07cGFkZGluZzouNXJlbSAwfX0udGVhbS1naXRodWJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2ZsZXgtd3JhcDp3cmFwO2dhcDoxcmVtfS50ZWFtLWdpdGh1YiBhe2NvbG9yOiNmZmZ9LnJzLWxvZ28gaW1ne3dpZHRoOjdyZW19Lm1haW57ZmxleC1ncm93OjF9LmF1ZGlvLWNhbGx7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwdmg7dG9wOjA7bGVmdDowO3JpZ2h0OjA7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCAjN2Q1ZGIwLCAjYjA2ZDlhIDcyJSwgI2M1ODRhNCk7Y29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuNyk7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjttYXJnaW46MCBhdXRvO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtwYWRkaW5nOjgwcHggMTBweCAwIDEwcHh9LmF1ZGlvLWNhbGwgLmNvbnRhaW5lcnttYXJnaW46MCBhdXRvO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEyNTBweH0uYXVkaW8tY2FsbCAubGV2ZWwtc2VsZWN0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cm93LWdhcDoycmVtfS5hdWRpby1jYWxsIC5zZWxlY3QtYmxvY2t7dGV4dC1hbGlnbjpjZW50ZXJ9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTAzMHB4KXsuYXVkaW8tY2FsbCAuc2VsZWN0LWJsb2Nre21heC13aWR0aDo1MDBweH19LmF1ZGlvLWNhbGwgLnNlbGVjdC1ibG9jayAuc2VsZWN0LWJsb2NrX190aXRsZXtwYWRkaW5nOjFyZW19LmF1ZGlvLWNhbGwgLnNlbGVjdGVke2NvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjZmZmfS5hdWRpby1jYWxsIGEsLmF1ZGlvLWNhbGwgYnV0dG9ue21hcmdpbjouMnJlbTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsLjIpO2JvcmRlci1yYWRpdXM6M3B4O2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xpbmUtaGVpZ2h0OjE7Y29sb3I6aW5oZXJpdDttaW4td2lkdGg6MTYycHg7cGFkZGluZzoxOXB4IDE1cHggMjFweDt0cmFuc2l0aW9uOmFsbCAuMTVzIGVhc2U7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLDApfS5hdWRpby1jYWxsIGE6aG92ZXIsLmF1ZGlvLWNhbGwgYnV0dG9uOmhvdmVye2NvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjZmZmfS5hdWRpby1jYWxsIC5zdGFnZXt0ZXh0LWFsaWduOmNlbnRlcn0uYXVkaW8tY2FsbCAuc3RhZ2VfX2ltZ3tib3JkZXItcmFkaXVzOjUwJTtoZWlnaHQ6MTNyZW07d2lkdGg6MTNyZW07bWFyZ2luOjFyZW0gYXV0bztkaXNwbGF5OmJsb2NrfS5hdWRpby1jYWxsIC5hbnN3ZXJze21hcmdpbjozcmVtIDA7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtmbGV4LXdyYXA6d3JhcDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2dhcDoycmVtfS5hdWRpby1jYWxsIC5hbnN3ZXJ7Zm9udC1zaXplOjEuNXJlbTtkaXNwbGF5OmZsZXg7Z2FwOi41cmVtO2N1cnNvcjpwb2ludGVyfS5hdWRpby1jYWxsIC5hbnN3ZXIgOmhvdmVye2NvbG9yOiNmZmZ9LmF1ZGlvLWNhbGwgLmFuc3dlciAuY2hlY2tlZHtjb2xvcjpncmVlbjtib3JkZXI6MXB4IHNvbGlkO2JvcmRlci1yYWRpdXM6NTAlO2hlaWdodDoycmVtO3dpZHRoOjJyZW07bGluZS1oZWlnaHQ6MnJlbTtmb250LXNpemU6MS41cmVtO2JhY2tncm91bmQtY29sb3I6I2I3ZDY5M30uYXVkaW8tY2FsbCAud29yZHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Zm9udC1zaXplOjIuNXJlbX0uYXVkaW8tY2FsbCAuc3BlYWtlci1idXR0b257Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czo1MCU7cGFkZGluZzowO21hcmdpbjowO21pbi13aWR0aDowcHg7Ym9yZGVyLWNvbG9yOnJnYmEoMCwwLDAsMCl9LmF1ZGlvLWNhbGwgLnNwZWFrZXItYnV0dG9uOmhvdmVye2JvcmRlcjpub25lfS5hdWRpby1jYWxsIC5zcGVha2VyLWJ1dHRvbiBzdmd7cGFkZGluZzouMnJlbX0uYXVkaW8tY2FsbCAuc3BlYWtlci1idXR0b24gc3ZnOmhvdmVyIHBhdGh7ZmlsbDojM2MzZTNkICFpbXBvcnRhbnR9LmF1ZGlvLWNhbGwgLnNwZWFrZXItYnV0dG9uX21pbntwYWRkaW5nOjAgMXJlbX0uYXVkaW8tY2FsbCAuc3BlYWtlci1idXR0b25fbWluIHN2Z3t3aWR0aDozcmVtO2hlaWdodDozcmVtfS5hdWRpby1jYWxsIC5nYW1lX19yZXN1bHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2U2ZTllZTtib3JkZXItcmFkaXVzOjhweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7bWF4LXdpZHRoOjUwMHB4O21pbi1oZWlnaHQ6NjQ2cHg7cGFkZGluZzo0MnB4IDE2cHg7dGV4dC1hbGlnbjpjZW50ZXI7d2lkdGg6MTAwJX0uYXVkaW8tY2FsbCAucmVzdWx0X19zY29yZXtjb2xvcjojMzczODNjO2ZvbnQtc2l6ZTozNHB4O2ZvbnQtd2VpZ2h0OjMwMDthbGlnbi1zZWxmOmNlbnRlcn0uYXVkaW8tY2FsbCAuZ2FtZV9fbGlzdHN7bWFyZ2luLXRvcDozMHB4fS5hdWRpby1jYWxsIC5yZXN1bHRfX3RydWUsLmF1ZGlvLWNhbGwgLnJlc3VsdF9fZmFsc2V7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjcwMDtsaW5lLWhlaWdodDoxLjMzO3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZTtsaXN0LXN0eWxlOm5vbmV9LmF1ZGlvLWNhbGwgLnJlc3VsdF9fdHJ1ZXtjb2xvcjojMjhjMzhhO21hcmdpbjoxcmVtIDB9LmF1ZGlvLWNhbGwgLnJlc3VsdF9fZmFsc2V7Y29sb3I6I2VkNTkzYn0uYXVkaW8tY2FsbCAucmVzdWx0X193b3Jke2Rpc3BsYXk6ZmxleDtnYXA6MTBweDthbGlnbi1pdGVtczpjZW50ZXI7Y29sb3I6IzM3MzgzYztmb250LXNpemU6MTZweDtsaW5lLWhlaWdodDoxLjI1O3RleHQtdHJhbnNmb3JtOmxvd2VyY2FzZTtmb250LXdlaWdodDo1MDA7bWFyZ2luLXRvcDo1cHh9LmF1ZGlvLWNhbGwgLnJlc3VsdF9fd29yZC1lbntmb250LXdlaWdodDo3MDB9LmF1ZGlvLWNhbGwgLnJlc3VsdF9fdm9pY2V7d2lkdGg6MzNweDtoZWlnaHQ6MzNweDtjdXJzb3I6cG9pbnRlcn0uYXVkaW8tY2FsbCAucmVzdWx0X192b2ljZSBzdmd7d2lkdGg6MnJlbTtoZWlnaHQ6MnJlbX0uYXVkaW8tY2FsbCAuY2xvc2UtYnV0dG9ue2JvcmRlci1yYWRpdXM6NTAlO3dpZHRoOjRyZW07aGVpZ2h0OjRyZW07dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6MjJweDtmb250LXNpemU6MnJlbTttaW4td2lkdGg6bWluLWNvbnRlbnR9LmF1ZGlvLWNhbGwgLm11dGUtYnV0dG9ue21hcmdpbjo0cHg7Zm9udC1zaXplOjNyZW19LmF1ZGlvLWNhbGwgLnJlc3VsdF9fYnV0dG9ue21hcmdpbi10b3A6MXJlbTtib3JkZXI6MnB4IHNvbGlkICMyOGMzOGE7Y29sb3I6IzNjM2UzZDtmb250LXNpemU6MS4ycmVtfS5hdWRpby1jYWxsIC5yZXN1bHRfX2J1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMyOGMzOGE7Ym9yZGVyOjJweCBzb2xpZCAjMjhjMzhhfS5hdWRpby1jYWxsIC5idXR0b25zLXdyYXBwZXJ7d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5ib2R5LS1zcHJpbnR7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOjEwMCU7bWluLWhlaWdodDoxMDB2aDtwYWRkaW5nOjA7YmFja2dyb3VuZC1jb2xvcjojMGQzODQ4O2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyArIFwiKSx1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fICsgXCIpLHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzJfX18gKyBcIik7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0LG5vLXJlcGVhdCxuby1yZXBlYXQ7YmFja2dyb3VuZC1zaXplOjEwMCUsYXV0byxhdXRvO2JhY2tncm91bmQtcG9zaXRpb246Ym90dG9tLDAgMCwxMDAlIDB9LmJvZHktLXNwcmludCBoMntmb250LXNpemU6MjRweH0uYm9keS0tc3ByaW50IC5oZWFkZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bWF4LXdpZHRoOjEzNjBweDtwYWRkaW5nOjAgMnJlbTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsMCk7ei1pbmRleDoxMDthbGlnbi1zZWxmOmNlbnRlcjtjb2xvcjojZmZmO2JvcmRlcjpub25lfS5ib2R5LS1zcHJpbnQgLmxvZ28gYXtjb2xvcjojZmZmfS5ib2R5LS1zcHJpbnQgLm1lbnUtaXRlbS1saW5re2NvbG9yOiNmZmZ9LmJvZHktLXNwcmludCAubWVudS1pdGVtLWxpbms6aG92ZXJ7Ym9yZGVyLWJvdHRvbToycHggc29saWQgI2ZmZn0uYm9keS0tc3ByaW50IC5idG4tc2Vjb25kYXJ5e2NvbG9yOiMwMDB9LmJvZHktLXNwcmludCAuZW50ZXItY2FiaW5ldC1saW5re2NvbG9yOiNmZmZ9LmJvZHktLXNwcmludCAubWFpbntwYWRkaW5nOjc1cHggMDtkaXNwbGF5OmZsZXg7bWluLWhlaWdodDoxMDB2aH0uYm9keS0tc3ByaW50IC5mb290ZXJ7ZGlzcGxheTpub25lfS5ib2R5LS1zcHJpbnQgLmJ1cmdlci1saW5le2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYm9keS0tc3ByaW50IC5idXJnZXItbGluZTo6YWZ0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5ib2R5LS1zcHJpbnQgLmJ1cmdlci1saW5lOjpiZWZvcmV7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5ib2R5LS1zcHJpbnQgLm9wZW5lZHtiYWNrZ3JvdW5kLWNvbG9yOiMwZDM4NDh9LnNwcmludHtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cGFkZGluZzoyMHB4IDA7Y29sb3I6I2ZmZjt3aWR0aDoxMDAlfS5zcHJpbnQgLnNwcmludF9fc2VsZWN0LXRpdGxle2ZvbnQtc2l6ZToyLjRyZW19LnNwcmludF9fc2VsZWN0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyO21pbi13aWR0aDo1MCV9LnNwcmludF9fc2VsZWN0LWRlc2Nye21hcmdpbi10b3A6MnJlbX0uc3ByaW50X19zZWxlY3QtdGV4dHttYXJnaW4tdG9wOjJyZW19LnNwcmludF9fbGV2ZWxze21hcmdpbi10b3A6MjBweDtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47d2lkdGg6MTAwJTtnYXA6LjRyZW19LnNwcmludF9fbGV2ZWx7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDoxNjJweDtoZWlnaHQ6NTVweDtib3JkZXItcmFkaXVzOjNweDtib3JkZXI6MXB4IHNvbGlkICNmZmY7Y3Vyc29yOnBvaW50ZXJ9LnNwcmludF9fY2xvc2V7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwcHg7cmlnaHQ6MjBweDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O2JvcmRlci1yYWRpdXM6NDBweDt6LWluZGV4OjE7bWFyZ2luOjIwcHggYXV0bztjdXJzb3I6cG9pbnRlcn0uc3ByaW50X19jbG9zZTo6YmVmb3Jle2NvbnRlbnQ6XFxcIitcXFwiO2NvbG9yOiNmZmY7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoyO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO2ZvbnQtc2l6ZTo1MHB4O2xpbmUtaGVpZ2h0OjE7dG9wOi01cHg7bGVmdDo2cHg7dHJhbnNpdGlvbjphbGwgLjNzIGN1YmljLWJlemllcigwLjc3LCAwLCAwLjIsIDAuODUpfS5zcHJpbnRfX2Nsb3NlOjphZnRlcntjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JvcmRlci1yYWRpdXM6MTAwJTtiYWNrZ3JvdW5kOiNmZmY7ei1pbmRleDoxO3RyYW5zaXRpb246YWxsIC4zcyBjdWJpYy1iZXppZXIoMC43NywgMCwgMC4yLCAwLjg1KTt0cmFuc2Zvcm06c2NhbGUoMC4wMSl9LnNwcmludF9fY2xvc2U6aG92ZXI6YWZ0ZXJ7dHJhbnNmb3JtOnNjYWxlKDEpfS5zcHJpbnRfX2Nsb3NlOmhvdmVyOmJlZm9yZXt0cmFuc2Zvcm06c2NhbGUoMC44KSByb3RhdGUoNDVkZWcpO2NvbG9yOiMwZDM4NDh9LnRpbWVye2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZX0udGltZXJfX3RpbWV7Zm9udC1zaXplOjMwcHg7Zm9udC13ZWlnaHQ6bGlnaHRlcjt3aWR0aDoxNjBweDtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXJ9LnRpbWVyX19zdmd7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZykgc2NhbGVYKC0xKX0uY2lyY2xlX2FuaW1hdGlvbntzdHJva2UtZGFzaGFycmF5OjQ0MDtzdHJva2UtZGFzaG9mZnNldDowO3RyYW5zaXRpb246YWxsIDFzIGxpbmVhcn0uc3ByaW50X19yZWFkeXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS50aW1lci0tY29udHJvbHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MjBweDtsZWZ0OjIwcHh9LnNwcmludF9fY29udHJvbHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2FsaWduLWl0ZW1zOmNlbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZX0uY29udHJvbF9fc291bmR7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt3aWR0aDoyM3B4O2hlaWdodDoyNHB4O2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfM19fXyArIFwiKTtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXJ9LmNvbnRyb2xfX3NvdW5kLS1vZmZ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF80X19fICsgXCIpfS5jb250cm9sX19jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7d2lkdGg6NTAwcHg7cGFkZGluZzozMHB4O21hcmdpbi10b3A6MTBweDtib3JkZXI6MXB4IHNvbGlkICNmZmY7Ym9yZGVyLXJhZGl1czoxMHB4O2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuMDYpfS5jb250cm9sX192b2ljZXtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoyMHB4O3RvcDoyMHB4O3dpZHRoOjMzcHg7aGVpZ2h0OjMzcHg7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF81X19fICsgXCIpO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlcjtjdXJzb3I6cG9pbnRlcn0uY29udHJvbF9fdm9pY2U6aG92ZXJ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF82X19fICsgXCIpfS5jb250cm9sX19zZXJpZXMtbGlzdHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjtnYXA6MjBweH0uY29udHJvbF9fc2VyaWVze3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF83X19fICsgXCIpO2JhY2tncm91bmQtcG9zaXRpb246NTAlO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXNpemU6Y29udGFpbn0uY29udHJvbF9fc2VyaWVzLS1hY3RpdmV7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF84X19fICsgXCIpfS5jb250cm9sX19tdWx0aXBseXttYXJnaW4tdG9wOjEwcHh9LmNvbnRyb2xfX3BhcnJvdHN7ZGlzcGxheTpmbGV4O3dpZHRoOjIwNHB4O2hlaWdodDo1N3B4O21hcmdpbi10b3A6MzBweDtiYWNrZ3JvdW5kLWltYWdlOnVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzlfX18gKyBcIik7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtcG9zaXRpb246Ym90dG9tfS5jb250cm9sX19wYXJyb3R7cG9zaXRpb246cmVsYXRpdmU7dG9wOjZweH0uY29udHJvbF9fd29yZC1lbntmb250LXNpemU6MzZweDttYXJnaW4tdG9wOjIwcHh9LmNvbnRyb2xfX3dvcmQtcnV7Zm9udC1zaXplOjI0cHg7Y29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuNil9LmNvbnRyb2xfX2J1dHRvbnN7ZGlzcGxheTpmbGV4O2dhcDoyMHB4O21hcmdpbi10b3A6NDBweDtwYWRkaW5nLWJvdHRvbTo0MHB4fS5jb250cm9sX19idXR0b257cG9zaXRpb246cmVsYXRpdmU7Ym9yZGVyLXJhZGl1czo0cHg7Y29sb3I6I2ZmZjtmb250LXNpemU6MjBweDtmb250LXdlaWdodDo0MDA7aGVpZ2h0OjUwcHg7dGV4dC1hbGlnbjpjZW50ZXI7d2lkdGg6MTgzcHg7Y3Vyc29yOnBvaW50ZXJ9LmNvbnRyb2xfX2J1dHRvbjo6YmVmb3Jle2JvdHRvbTotNDVweDtjb2xvcjojN2U5MTlmO2Rpc3BsYXk6YmxvY2s7Zm9udC1zaXplOjI4cHg7cG9zaXRpb246YWJzb2x1dGV9LmNvbnRyb2xfX2J1dHRvbi0tZmFsc2V7YmFja2dyb3VuZC1jb2xvcjojZWQ1OTNifS5jb250cm9sX19idXR0b24tLWZhbHNlOjpiZWZvcmV7Y29udGVudDpcXFwi4oaQXFxcIjtsZWZ0OjQwJX0uY29udHJvbF9fYnV0dG9uLS10cnVle2JhY2tncm91bmQtY29sb3I6IzI4YzM4YX0uY29udHJvbF9fYnV0dG9uLS10cnVlOjpiZWZvcmV7Y29udGVudDpcXFwi4oaSXFxcIjtyaWdodDo0MCV9LnNwcmludF9fcmVzdWx0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNlNmU5ZWU7Ym9yZGVyLXJhZGl1czo4cHg7Ym94LXNpemluZzpib3JkZXItYm94O21heC13aWR0aDo1MDBweDttYXgtaGVpZ2h0OjUwMHB4O3BhZGRpbmc6NDJweCAxNnB4O3RleHQtYWxpZ246Y2VudGVyO3dpZHRoOjEwMCU7b3ZlcmZsb3cteTphdXRvfS5yZXN1bHRfX3Njb3Jle2NvbG9yOiMzNzM4M2M7Zm9udC1zaXplOjM0cHg7Zm9udC13ZWlnaHQ6MzAwO2FsaWduLXNlbGY6Y2VudGVyfS5zcHJpbnRfX2xpc3Rze21hcmdpbi10b3A6MzBweH0ucmVzdWx0X190cnVlLC5yZXN1bHRfX2ZhbHNle2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6ZmxleC1zdGFydDtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo3MDA7bGluZS1oZWlnaHQ6MS4zMzt0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2U7bGlzdC1zdHlsZTpub25lfS5yZXN1bHRfX3RydWV7Y29sb3I6IzI4YzM4YTttYXJnaW4tdG9wOjIwcHh9LnJlc3VsdF9fZmFsc2V7Y29sb3I6I2VkNTkzYn0ucmVzdWx0X193b3Jke2Rpc3BsYXk6ZmxleDtnYXA6MTBweDthbGlnbi1pdGVtczpjZW50ZXI7Y29sb3I6IzM3MzgzYztmb250LXNpemU6MTZweDtsaW5lLWhlaWdodDoxLjI1O3RleHQtdHJhbnNmb3JtOmxvd2VyY2FzZTtmb250LXdlaWdodDo1MDA7bWFyZ2luLXRvcDo1cHh9LnJlc3VsdF9fd29yZC1lbntmb250LXdlaWdodDo3MDB9LnJlc3VsdF9fdm9pY2V7d2lkdGg6MzNweDtoZWlnaHQ6MzNweDtiYWNrZ3JvdW5kLWltYWdlOnVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzEwX19fICsgXCIpO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlcjtjdXJzb3I6cG9pbnRlcn0ucmVzdWx0X192b2ljZTpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOnVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzZfX18gKyBcIil9LnJlc3VsdF9fcmVzdGFydC1idG57YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDM3LDEzMCwyMzEsLjA4KTtib3JkZXItcmFkaXVzOjRweDtjb2xvcjojMjU4MmU3O2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjYwMDtsaW5lLWhlaWdodDoxLjQzO21hcmdpbi10b3A6MjRweDtwYWRkaW5nOjEwcHggNDJweDt0ZXh0LWFsaWduOmNlbnRlcn0ucmVzdWx0X19yZXN0YXJ0LWJ0bjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMzcsMTMwLDIzMSwuMTIpfS5zcHJpbnRfX3Jlc3RhcnQtbWVzc2FnZXtmb250LXNpemU6MTRweDt3aWR0aDo2MCU7Y29sb3I6I2VkNTkzYjttYXJnaW4tdG9wOjEwcHh9LnRleHRib29re2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTthbGlnbi1pdGVtczpzdHJldGNoO3dpZHRoOjEwMCU7bWFyZ2luLXRvcDotMnB4fUBtZWRpYShtYXgtd2lkdGg6IDYwMHB4KXsudGV4dGJvb2t7ZmxleC1kaXJlY3Rpb246Y29sdW1ufX0uYXNpZGV7cGFkZGluZzoycmVtIDFyZW07d2lkdGg6MTUlO2ZsZXgtc2hyaW5rOjA7Zm9udC1mYW1pbHk6XFxcIk1vbnRzZXJyYXRcXFwiLHNhbnMtc2VyaWZ9QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey5hc2lkZXt3aWR0aDoxMDAlfX1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LmFzaWRle3BhZGRpbmc6MXJlbSAuMnJlbX19LnNpZGViYXItY29udGVudHtwb3NpdGlvbjotd2Via2l0LXN0aWNreTtwb3NpdGlvbjpzdGlja3k7dG9wOjA7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nLXJpZ2h0OjEuNXJlbTtnYXA6LjdyZW19QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey5zaWRlYmFyLWNvbnRlbnR7ZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtd3JhcDp3cmFwO2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0fX1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LnNpZGViYXItY29udGVudHtnYXA6LjNyZW07cGFkZGluZzowO2p1c3RpZnktY29udGVudDpjZW50ZXI7cm93LWdhcDoxLjhyZW19fS5zaWRlYmFyLXRleHR7Zm9udC1zaXplOjEuMnJlbTtmb250LXdlaWdodDo2MDA7dGV4dC1hbGlnbjpjZW50ZXJ9QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey5zaWRlYmFyLXRleHR7Zm9udC1zaXplOjFyZW19fUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsuc2lkZWJhci10ZXh0e2Rpc3BsYXk6bm9uZX19LmJ0bi1sZXZlbHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjUuNnJlbTt3aWR0aDo1LjZyZW07Ym9yZGVyLXJhZGl1czo1MCU7cGFkZGluZzoyLjVyZW07Zm9udC1zaXplOjIuNXJlbTtmb250LXdlaWdodDo3MDA7Y3Vyc29yOnBvaW50ZXI7dHJhbnNpdGlvbjouM3MgZWFzZS1pbi1vdXR9QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey5idG4tbGV2ZWx7aGVpZ2h0OjMuMnJlbTt3aWR0aDozLjJyZW07cGFkZGluZzowO2ZvbnQtc2l6ZToxLjVyZW19fS51c2VyYm9vay1tYXJre2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206My44cmVtO3JpZ2h0OjIuNHJlbTtiYWNrZ3JvdW5kOiNmZmRkYjA7Y29sb3I6IzMzMmE3Yztib3JkZXItcmFkaXVzOjMwcHg7cGFkZGluZzouNXJlbTtib3gtc2hhZG93OjBweCAxcHggNHB4IDFweCByZ2JhKDUwLDUwLDcxLC4xNSl9LnVzZXJib29rLW1hcmsgLm1hdGVyaWFsLWljb25zLW91dGxpbmVke2ZvbnQtc2l6ZToxLjNyZW19QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey51c2VyYm9vay1tYXJre2JvdHRvbToycmVtO3JpZ2h0OjFyZW19fUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsudXNlcmJvb2stbWFya3tyaWdodDo5LjFyZW19fS50ZXh0LWJvb2stcGFnZXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmRkYjA7Ym94LXNoYWRvdzppbnNldCAtMXB4IC0xcHggM3B4IHJnYmEoMjU1LDI1NSwyNTUsLjc1KSxpbnNldCAxcHggMXB4IDJweCByZ2JhKDcsNyw2OSwuMTUpO2JvcmRlci1yYWRpdXM6MzBweDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3BhZGRpbmc6MCAyLjVyZW0gMS41cmVtO3dpZHRoOjg1JTtib3JkZXI6M3B4IHNvbGlkICNmZmY7bWFyZ2luLWJvdHRvbToxLjVyZW19QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey50ZXh0LWJvb2stcGFnZXt3aWR0aDoxMDAlfX1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LnRleHQtYm9vay1wYWdle3BhZGRpbmc6MXJlbX19LnRleHQtYm9vay1wYWdlLWhlYWR7ZGlzcGxheTpmbGV4O3BhZGRpbmc6Mi41cmVtO2FsaWduLWl0ZW1zOmNlbnRlcjtnYXA6MS41cmVtO21hcmdpbi1yaWdodDphdXRvfUBtZWRpYShtYXgtd2lkdGg6IDYwMHB4KXsudGV4dC1ib29rLXBhZ2UtaGVhZHtwYWRkaW5nOjIuNXJlbSAxLjJyZW19fUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsudGV4dC1ib29rLXBhZ2UtaGVhZHtmbGV4LWRpcmVjdGlvbjpjb2x1bW47Z2FwOi41cmVtO3BhZGRpbmc6MS41cmVtO21hcmdpbjowfX0uY2FyZHMtd3JhcHBlcntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2p1c3RpZnktY29udGVudDpzcGFjZS1hcm91bmQ7ZmxleC13cmFwOndyYXA7cm93LWdhcDoxcmVtfS5jYXJke3BhZGRpbmc6MS4ycmVtO2JhY2tncm91bmQ6I2ZmZjtib3gtc2hhZG93OjBweCAxcHggNHB4IDFweCByZ2JhKDUwLDUwLDcxLC4xNSk7Ym9yZGVyLXJhZGl1czozMHB4O2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MzJyZW07aGVpZ2h0OjI1cmVtfUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsuY2FyZHt3aWR0aDoxMDAlO2hlaWdodDphdXRvfX0uY2FyZC1tYWluLWluZm8td3JhcHBlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2ZvbnQtZmFtaWx5OlxcXCJNb250c2VycmF0XFxcIixzYW5zLXNlcmlmO3BhZGRpbmctYm90dG9tOjEuNXJlbX1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LmNhcmQtbWFpbi1pbmZvLXdyYXBwZXJ7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3BhZGRpbmctYm90dG9tOjFyZW19fS5idG4tcGxheXttYXJnaW4tbGVmdDotMnJlbX0uYnRuLXBsYXk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZkZGIwfS5idG4tcGxheSBzdmd7d2lkdGg6MjVweDtoZWlnaHQ6MjVweH0uYnRuLXBsYXkgc3ZnIHBhdGh7ZmlsbDojMTkxYTE1O3N0cm9rZTojMTkxYTE1fS5idG4tcGxheSBzdmc6aG92ZXJ7ZmlsbDojMzMyYTdjfS5idG4tcGxheSBzdmc6aG92ZXIgcGF0aHtmaWxsOiMzMzJhN2M7c3Ryb2tlOiMzMzJhN2N9QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5idG4tcGxheXttYXJnaW4tbGVmdDowO21hcmdpbi10b3A6LTJyZW19fS5jYXJkLWltZ3t3aWR0aDoxMHJlbTtoZWlnaHQ6OHJlbTtib3JkZXItcmFkaXVzOjMwcHh9QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5jYXJkLWltZ3t3aWR0aDoxMDAlO2hlaWdodDoxMHJlbX19LmNhcmQtd29yZC1pbmZve3BhZGRpbmctbGVmdDouOHJlbX1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LmNhcmQtd29yZC1pbmZve3RleHQtYWxpZ246Y2VudGVyfX0ud29yZHtmb250LXNpemU6MS44cmVtO2ZvbnQtd2VpZ2h0OjcwMH0ud29yZC10cmFuc2NyaXB0aW9ue2ZvbnQtc2l6ZToxcmVtO2NvbG9yOiNhMWExYTE7cGFkZGluZy1ib3R0b206LjhyZW19LndvcmQtdHJhbnNsYXRle2ZvbnQtc2l6ZToxLjNyZW19LnVzZXItYnRuc3ttYXJnaW4tbGVmdDphdXRvO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47Z2FwOi41cmVtO2FsaWduLWl0ZW1zOmNlbnRlcn1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LnVzZXItYnRuc3tmbGV4LWRpcmVjdGlvbjpyb3c7bWFyZ2luOmF1dG87cGFkZGluZy10b3A6MXJlbX19LmFuc3dlcnN7Zm9udC1zaXplOi44cmVtfS5oYXJkLXdvcmQtYnRue2JvcmRlci1jb2xvcjojMzMyYTdjO2JhY2tncm91bmQtY29sb3I6IzMzMmE3Y30uaGFyZC13b3JkLWJ0biAuYnRuLWljb257Y29sb3I6I2ZmZGRiMH0ubGVhcm4td29yZC1idG57Ym9yZGVyLWNvbG9yOiNmZmRkYjA7YmFja2dyb3VuZC1jb2xvcjojZmZkZGIwfS5sZWFybi13b3JkLWJ0biAuYnRuLWljb257Y29sb3I6IzMzMmE3Y30ud29yZC1tZWFuLXRyYW5zbGF0ZSwud29yZC1leC10cmFuc2xhdGV7Y29sb3I6I2ExYTFhMTtsaW5lLWhlaWdodDoxLjY7Zm9udC1zdHlsZTppdGFsaWN9LndvcmQtbWVhbi10cmFuc2xhdGV7cGFkZGluZy1ib3R0b206MXJlbX0ucGFnaW5hdGlvbntkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7cGFkZGluZzoyLjVyZW0gMXJlbSAwfS5wYWdlLWlucHV0e21hcmdpbjowIDNyZW07d2lkdGg6MnJlbTtmb250LXNpemU6MS41cmVtO2ZvbnQtd2VpZ2h0OjYwMDtmb250LWZhbWlseTpcXFwiTW9udHNlcnJhdFxcXCIsc2Fucy1zZXJpZjtib3JkZXItYm90dG9tOjFweCBzb2xpZDt0ZXh0LWFsaWduOmNlbnRlcn0ucGFnZS1pbnB1dDpmb2N1cy12aXNpYmxle291dGxpbmU6bm9uZX1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LnBhZ2UtaW5wdXR7bWFyZ2luOjAgLjVyZW19fS5wYWdlLWlucHV0Ojotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLC5wYWdlLWlucHV0Ojotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lO21hcmdpbjowfS5wYWdlLWlucHV0ey1tb3otYXBwZWFyYW5jZTp0ZXh0ZmllbGR9LnVzZXItcGFnZXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmRkYjA7Ym94LXNoYWRvdzppbnNldCAtMXB4IC0xcHggM3B4IHJnYmEoMjU1LDI1NSwyNTUsLjc1KSxpbnNldCAxcHggMXB4IDJweCByZ2JhKDcsNyw2OSwuMTUpO2JvcmRlci1yYWRpdXM6MzBweDtiYWNrZ3JvdW5kLWNvbG9yOiNmNGY0ZmY7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtwYWRkaW5nOjJyZW0gMXJlbSAxcmVtO2dhcDoxLjVyZW19LnVzZXItc2lkZWJhcntkaXNwbGF5OmZsZXg7Z2FwOjEuNXJlbTtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MzYlO3BhZGRpbmc6Mi41cmVtIDEuNXJlbSAxLjVyZW19QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey51c2VyLXNpZGViYXJ7d2lkdGg6MTAwJTtwYWRkaW5nOjAgMXJlbSAxLjVyZW07YWxpZ24taXRlbXM6Y2VudGVyfX0udXNlci1zZWN0aW9ue2Rpc3BsYXk6ZmxleDtwYWRkaW5nLWJvdHRvbToxcmVtO2dhcDoyLjVyZW19QG1lZGlhKG1heC13aWR0aDogNzY4cHgpey51c2VyLXNlY3Rpb257Z2FwOjB9fUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsudXNlci1zZWN0aW9ue2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn19LmVudGVyLWNhYmluZXQtbGlua3tjb2xvcjojMTkxYTE1O2ZvbnQtd2VpZ2h0OjYwMH0uZXhpdC1jYWJpbmV0LWJ0bnt3aWR0aDoxMHJlbX0uaGVyby1zZWN0aW9ue2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47cGFkZGluZzozcmVtO2JhY2tncm91bmQ6Y2VudGVyL2NvdmVyIG5vLXJlcGVhdCB1cmwoXCIgKyBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xMV9fXyArIFwiKTtib3JkZXItcmFkaXVzOjMwcHg7Ym94LXNoYWRvdzppbnNldCAtMXB4IC0xcHggM3B4IHJnYmEoMjU1LDI1NSwyNTUsLjc1KSxpbnNldCAxcHggMXB4IDJweCByZ2JhKDcsNyw2OSwuMTUpfUBtZWRpYShtYXgtd2lkdGg6IDEwMjVweCl7Lmhlcm8tc2VjdGlvbntwYWRkaW5nOjEuNXJlbTtwYWRkaW5nLXRvcDoyLjVyZW19fUBtZWRpYShtYXgtd2lkdGg6IDc2OHB4KXsuaGVyby1zZWN0aW9ue3BhZGRpbmc6My41cmVtIDJyZW19fUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsuaGVyby1zZWN0aW9ue3BhZGRpbmc6Mi41cmVtIDEuNXJlbX19Lmhlcm8tc2VjdGlvbi1oZWFkZXJ7d2lkdGg6NTAlO3RleHQtYWxpZ246Y2VudGVyO2xpbmUtaGVpZ2h0OjE7cGFkZGluZy1ib3R0b206MnJlbX1AbWVkaWEobWF4LXdpZHRoOiAxMDI1cHgpey5oZXJvLXNlY3Rpb24taGVhZGVye3dpZHRoOjYwJX19QG1lZGlhKG1heC13aWR0aDogNzY4cHgpey5oZXJvLXNlY3Rpb24taGVhZGVye3dpZHRoOjEwMCV9fUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsuaGVyby1zZWN0aW9uLWhlYWRlcnt3aWR0aDoxMDAlfX0uaGVyby1zZWN0aW9uLXRleHR7dGV4dC1hbGlnbjpjZW50ZXI7d2lkdGg6NjAlO3BhZGRpbmctYm90dG9tOjEuNXJlbX1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7Lmhlcm8tc2VjdGlvbi10ZXh0e3dpZHRoOjEwMCV9fS5hZHZhbnRhZ2VzLXNlY3Rpb257ZGlzcGxheTpmbGV4O3BhZGRpbmc6MDttYXJnaW4tdG9wOjQuNXJlbTtnYXA6MXJlbTtmbGV4LXdyYXA6d3JhcDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5hZHZhbnRhZ2Vfd3JhcHBlcntwYWRkaW5nOjEuMnJlbTtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowcHggMXB4IDRweCAxcHggcmdiYSg1MCw1MCw3MSwuMTUpO2JvcmRlci1yYWRpdXM6MzBweDt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjFyZW07d2lkdGg6MjMlfUBtZWRpYShtYXgtd2lkdGg6IDEwMjVweCl7LmFkdmFudGFnZV93cmFwcGVye3dpZHRoOjQ4JX19QG1lZGlhKG1heC13aWR0aDogNjAwcHgpey5hZHZhbnRhZ2Vfd3JhcHBlcnt3aWR0aDoxMDAlfX0uYWR2YW50YWdlLWhlYWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtmb250LXNpemU6MnJlbTtwYWRkaW5nLWJvdHRvbToxcmVtO3BhZGRpbmctdG9wOjFyZW19LmFkdmFudGFnZS1oZWFkZXI6OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6XFxcIlxcXCI7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kLWNvbG9yOiMxOTFhMTU7d2lkdGg6MzAlO2JvdHRvbTowO2xlZnQ6MzQuNSV9LmFkdmFudGFnZS1pbWFnZXt3aWR0aDoxMDAlO2JvcmRlci1yYWRpdXM6MzBweH0uYWR2YW50YWdlLXRleHR7cGFkZGluZy10b3A6MXJlbTtwYWRkaW5nLWJvdHRvbToxcmVtfS5pbmZvLXNlY3Rpb257ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOjQuNXJlbSAwfS5pbmZvLXRleHQtd3JhcHBlcnt3aWR0aDo0MCU7cGFkZGluZzowIDQuNXJlbX0uaW5mby1oZWFkZXJ7Zm9udC1zaXplOjEuNXJlbTtwYWRkaW5nLWJvdHRvbToycmVtfS5pbmZvLXRleHR7bGlzdC1zdHlsZTpub25lO3BhZGRpbmctYm90dG9tOi43cmVtO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LmluZm8tdGV4dC1pY29ue3BhZGRpbmctcmlnaHQ6LjVyZW19LmluZm8taW1hZ2V7YmFja2dyb3VuZC1jb2xvcjojZmZkZGIwO2JveC1zaGFkb3c6aW5zZXQgLTFweCAtMXB4IDNweCByZ2JhKDI1NSwyNTUsMjU1LC43NSksaW5zZXQgMXB4IDFweCAycHggcmdiYSg3LDcsNjksLjE1KTtib3JkZXItcmFkaXVzOjMwcHg7YmFja2dyb3VuZDpjZW50ZXIvY292ZXIgbm8tcmVwZWF0IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzEyX19fICsgXCIpO3dpZHRoOjUwJTtoZWlnaHQ6MjVyZW19LnRlYW0tc2VjdGlvbntwYWRkaW5nOjQuNXJlbSAwO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7ZmxleC1kaXJlY3Rpb246Y29sdW1uO21hcmdpbi1ib3R0b206Mi41cmVtfS50ZWFtLXNlY3Rpb24taGVhZGVye3RleHQtYWxpZ246Y2VudGVyfS50ZWFtLW1lbWJlcnN7ZGlzcGxheTpmbGV4O2dhcDoxLjVyZW07cGFkZGluZy10b3A6Mi41cmVtO2ZsZXgtd3JhcDp3cmFwO2p1c3RpZnktY29udGVudDpjZW50ZXJ9QG1lZGlhKG1heC13aWR0aDogMTAyNXB4KXsudGVhbS1tZW1iZXJze3dpZHRoOjEwMCV9fS50ZWFtLW1lbWJlcntwYWRkaW5nOjEuMnJlbTtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowcHggMXB4IDRweCAxcHggcmdiYSg1MCw1MCw3MSwuMTUpO2JvcmRlci1yYWRpdXM6MzBweDtwYWRkaW5nOjFyZW07d2lkdGg6MzAlO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyfUBtZWRpYShtYXgtd2lkdGg6IDYwMHB4KXsudGVhbS1tZW1iZXJ7d2lkdGg6MTAwJX19LnRlYW0tbWVtYmVyLW5hbWV7Zm9udC1zaXplOjEuNnJlbTtwYWRkaW5nOjFyZW0gMCAwfS50ZWFtLW1lbWJlci1pbWd7d2lkdGg6MTAwJTtib3JkZXItcmFkaXVzOjMwcHh9Lm1lbWJlci1kdXR5e2ZvbnQtc2l6ZTouOXJlbTtsaW5lLWhlaWdodDoyO3BhZGRpbmctYm90dG9tOjFyZW07Y29sb3I6I2ExYTFhMX0ubWVtYmVyLWFjdGlvbnN7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZy1ib3R0b206MXJlbTtmbGV4LWdyb3c6MX0ubWVtYmVyLWFjdGlvbnMgdWx7dGV4dC1hbGlnbjpsZWZ0O2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2hlaWdodDoxMDAlfS5tZW1iZXItYWN0aW9ucyBsaXtsaXN0LXN0eWxlOm5vbmU7cGFkZGluZy1ib3R0b206LjNyZW07dGV4dC1hbGlnbjpjZW50ZXJ9LmdpdC1pY29ue3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7bWFyZ2luLXRvcDphdXRvO2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMTNfX18gKyBcIik7ZmlsdGVyOm5vbmU7dHJhbnNpdGlvbjphbGwgLjVzO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uZ2l0LWljb246aG92ZXJ7ZmlsdGVyOmludmVydCgxKX0uY2hhcnRze2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZDtmbGV4LXdyYXA6d3JhcDt3aWR0aDoxMDAlO3BhZGRpbmc6MjBweH1AbWVkaWEobWF4LXdpZHRoOiAxMDI1cHgpey5jaGFydHN7Z2FwOjEuNXJlbX19QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5jaGFydHN7d2lkdGg6MTAwJX19LmNoYXJ0e3dpZHRoOjM1JTtoZWlnaHQ6MzAwcHh9QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5jaGFydHt3aWR0aDoxMDAlO2hlaWdodDptYXgtY29udGVudH19LnRvZGF5c3RhdC13cmFwcGVye3BhZGRpbmc6MS4ycmVtO2JhY2tncm91bmQ6I2ZmZjtib3gtc2hhZG93OjBweCAxcHggNHB4IDFweCByZ2JhKDUwLDUwLDcxLC4xNSk7Ym9yZGVyLXJhZGl1czozMHB4O3BhZGRpbmc6MS42cmVtO2ZvbnQtZmFtaWx5OlxcXCJNb250c2VycmF0XFxcIixzYW5zLXNlcmlmO3dpZHRoOjYyJTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZH0udG9kYXlzdGF0LXdyYXBwZXIgLndvcmQtd3JhcHBlcnt3aWR0aDoxMDAlfUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsudG9kYXlzdGF0LXdyYXBwZXJ7d2lkdGg6MTAwJTtwYWRkaW5nOi41cmVtfX0ud3JhcHBlcl9kYWlseS1zdGF0e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MTAwJTtmb250LXNpemU6MS4zcmVtO2NvbG9yOiMxOTFhMTU7Zm9udC1mYW1pbHk6XFxcIk1vbnRzZXJyYXRcXFwiLHNhbnMtc2VyaWY7Z2FwOjFyZW19LmRheXN0YXQtd3JhcHBlcntwYWRkaW5nOjEuMnJlbTtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowcHggMXB4IDRweCAxcHggcmdiYSg1MCw1MCw3MSwuMTUpO2JvcmRlci1yYWRpdXM6MzBweDtmb250LWZhbWlseTpcXFwiTW9udHNlcnJhdFxcXCIsc2Fucy1zZXJpZjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZDthbGlnbi1pdGVtczpjZW50ZXI7d2lkdGg6MTAwJTtwYWRkaW5nLWJvdHRvbToxLjVyZW19QG1lZGlhKG1heC13aWR0aDogNzY4cHgpey5kYXlzdGF0LXdyYXBwZXJ7ZmxleC13cmFwOndyYXA7Z2FwOjFyZW19LmRheXN0YXQtd3JhcHBlciAud29yZC13cmFwcGVye3dpZHRoOjQ4JX19QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5kYXlzdGF0LXdyYXBwZXJ7ZmxleC13cmFwOm5vd3JhcDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47Z2FwOjFyZW19LmRheXN0YXQtd3JhcHBlciAud29yZC13cmFwcGVye3dpZHRoOjEwMCV9fS5kYXRhLXdyYXBwZXItcm93MSwuZGF0YS13cmFwcGVyLXJvdzJ7ZGlzcGxheTpmbGV4O3BhZGRpbmc6MXJlbTtnYXA6MXJlbTtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6NTAlO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufUBtZWRpYShtYXgtd2lkdGg6IDQyNXB4KXsuZGF0YS13cmFwcGVyLXJvdzEsLmRhdGEtd3JhcHBlci1yb3cye3BhZGRpbmc6NXB4fX0uZGF0YS13cmFwcGVyLXJvdzF7YWxpZ24taXRlbXM6Y2VudGVyfS5zdGF0LWRhdGEtaXRlbXtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmctYm90dG9tOi41cmVtfS5kYXRlLXJvd3twYWRkaW5nLXJpZ2h0OjYuNXJlbTtwYWRkaW5nLXRvcDoxLjZyZW07cGFkZGluZy1sZWZ0OjJyZW07dGV4dC1hbGlnbjpjZW50ZXJ9QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5kYXRlLXJvd3twYWRkaW5nLXJpZ2h0OjIuOHJlbX19QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5kYXRlLXJvd3twYWRkaW5nLXRvcDoyLjhyZW19fS5maXJzdC1kYXktdGV4dHtsaW5lLWhlaWdodDoxLjJ9LmZpcnN0LWRheS1kYXRle2ZvbnQtc2l6ZToxLjZyZW07Zm9udC13ZWlnaHQ6NzAwO2xpbmUtaGVpZ2h0OjEuNn1AbWVkaWEobWF4LXdpZHRoOiA0MjVweCl7LmZpcnN0LWRheS1kYXRle2ZvbnQtc2l6ZToxcmVtfX0ud29yZC10ZXh0e2ZvbnQtc2l6ZToxLjJyZW07Zm9udC13ZWlnaHQ6NzAwO3BhZGRpbmctYm90dG9tOi41cmVtfS5zdGF0LWRhdGEtcGFyYW17cGFkZGluZy1yaWdodDoxcmVtO2ZvbnQtZmFtaWx5OlxcXCJPcGVuIFNhbnNcXFwiLHNhbnMtc2VyaWY7Zm9udC1zaXplOi45cmVtfS5zdGF0LWRhdGEtdmFsdWV7Zm9udC13ZWlnaHQ6NjAwO2ZvbnQtc2l6ZTouOXJlbX0uZGF0ZS10ZXh0e2ZvbnQtc2l6ZToxLjJyZW07Zm9udC13ZWlnaHQ6NzAwfUBtZWRpYShtYXgtd2lkdGg6IDc2OHB4KXsuZGF0ZS10ZXh0e3dpZHRoOjQ4JX19QG1lZGlhKG1heC13aWR0aDogNDI1cHgpey5kYXRlLXRleHR7d2lkdGg6MTAwJX19XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlcy9mb250cy5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzL2NvbXBvbmVudHMuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy92YXJpYWJsZXMuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy9taXhpbnMuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy9tb2RhbC5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzL2Zvcm0uc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy9ib2R5LnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvaGVhZGVyLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvZm9vdGVyLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzL2F1ZGlvLWNhbGwuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy9zcHJpbnQuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy90ZXh0Qm9vay5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzL3VzZXJQYWdlLnNjc3NcIixcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvbWFpblBhZ2Uuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy9jaGFydHMuc2Nzc1wiLFwid2VicGFjazovLy4vc3JjL3N0eWxlcy9z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QUFBLGVBQ0EsQ0FBQSxlQUNBLENBQUEseUJBQ0EsZ0JBSkYsY0FLSSxDQUFBLENBQUEsV0FJSixnQkFDRSxDQUFBLGVBQ0EsQ0FBQSxvQkFDQSxDQUFBLGlCQUdGLGtCQUNFLENBQUEsa0NkekdVLENBQUEsZWMyR1YsQ0FBQSxpQkFHRixlQUNFLENBQUEsZUFDQSxDQUFBLFdBR0YsZ0JBQ0UsQ0FBQSxlQUNBLENBQUEseUJBQ0EsV0FIRixTQUlJLENBQUEsQ0FBQSx5QkFFRixXQU5GLFVBT0ksQ0FBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Nb250c2VycmF0Oml0YWwsd2dodEAwLDQwMDswLDUwMDswLDYwMDswLDcwMDswLDgwMDsxLDQwMDsxLDUwMCZmYW1pbHk9T3BlbitTYW5zOml0YWwsd2dodEAwLDQwMDswLDcwMDsxLDQwMCZkaXNwbGF5PXN3YXAnKTtcXHJcXG5cIixcImEge1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgY29sb3I6ICR0ZXh0LWNvbG9yO1xcclxcbn1cXHJcXG5cXHJcXG4uYnRuIHtcXHJcXG4gIEBpbmNsdWRlIGRpc3BsYXktZmxleC1jZW50ZXI7XFxyXFxuICBjb2xvcjogJHdoaXRlLWNvbG9yO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogJGRhcmstY29sb3I7XFxyXFxuICBib3JkZXI6IG5vbmU7XFxyXFxuICBib3JkZXItcmFkaXVzOiAycmVtO1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxuICBmb250LXNpemU6IDFyZW07XFxyXFxuICBwYWRkaW5nOiAwLjVyZW0gMS4ycmVtO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgdHJhbnNpdGlvbjogMC41cyBhbGwgZWFzZS1pbi1vdXQ7XFxyXFxuICAmX19kaXNhYmxlZCB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAkbWlkLWdyZXk7XFxyXFxuICAgIGNvbG9yOiAkbWlkLWdyZXk7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgfVxcclxcbiAgJjpkaXNhYmxlZCB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAkbWlkLWdyZXk7XFxyXFxuICAgIGNvbG9yOiAkbWlkLWdyZXk7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uYnRuLXNlY29uZGFyeSB7XFxyXFxuICBAZXh0ZW5kIC5idG47XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAkd2hpdGUtY29sb3I7XFxyXFxuICBib3JkZXI6IDJweCBzb2xpZCAkYWNjZW50LWNvbG9yO1xcclxcbiAgY29sb3I6ICRhY2NlbnQtY29sb3I7XFxyXFxufVxcclxcblxcclxcbi52aWRlby1idG4ge1xcclxcbiAgcGFkZGluZzogMCAxcmVtIDAgMC4ycmVtO1xcclxcbiAgYm9yZGVyLWNvbG9yOiAkd2hpdGUtY29sb3I7XFxyXFxuICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMikgMHB4IDEycHggMjhweCAwcHgsXFxyXFxuICAgIHJnYmEoMCwgMCwgMCwgMC4xKSAwcHggMnB4IDRweCAwcHgsXFxyXFxuICAgIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSkgMHB4IDBweCAwcHggMXB4IGluc2V0O1xcclxcbiAgJjpob3ZlciB7XFxyXFxuICAgIGJveC1zaGFkb3c6ICRib3gtc2hhZG93O1xcclxcbiAgfVxcclxcbiAgLnZpZGVvLWljb24ge1xcclxcbiAgICBmb250LXNpemU6IDNyZW07XFxyXFxuICAgIHBhZGRpbmctcmlnaHQ6IDAuNXJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1wbGF5IHtcXHJcXG4gIHdpZHRoOiAzLjVyZW07XFxyXFxuICBoZWlnaHQ6IDMuNXJlbTtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAkd2hpdGUtY29sb3I7XFxyXFxuICBib3gtc2hhZG93OiAkYm94LXNoYWRvdztcXHJcXG59XFxyXFxuXFxyXFxuLy9sZXZlbCBidXR0b25zXFxyXFxuLmJ0bi1sZXZlbCB7XFxyXFxuICBib3gtc2hhZG93OiAkYm94LXNoYWRvdztcXHJcXG4gIGJvcmRlcjogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcbiAgJjpob3ZlciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICRzZWNvbmRhcnktY29sb3I7XFxyXFxuICB9XFxyXFxuICAmLmJ0bi1hY3RpdmUge1xcclxcbiAgICBib3JkZXItY29sb3I6ICRhY2NlbnQtY29sb3I7XFxyXFxuICAgIGNvbG9yOiAkZGFyay1jb2xvcjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLy9sZXZlbCBidXR0b25zXFxyXFxuLmJ0bi1sZXZlbCB7XFxyXFxuICBib3gtc2hhZG93OiAkYm94LXNoYWRvdztcXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1sZXZlbC0xIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRsMTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1sZXZlbC0yIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRsMjtcXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1sZXZlbC0zIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRsMztcXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1sZXZlbC00IHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRsNDtcXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1sZXZlbC01IHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRsNTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1sZXZlbC02IHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRsNjtcXHJcXG59XFxyXFxuXFxyXFxuLnVzZXItd29yZHMtYnRuIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRhY2NlbnQtY29sb3I7XFxyXFxuICBjb2xvcjogJHNlY29uZGFyeS1jb2xvcjtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICYuYnRuLWFjdGl2ZSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICRzZWNvbmRhcnktY29sb3I7XFxyXFxuICAgIGNvbG9yOiAkYWNjZW50LWNvbG9yO1xcclxcbiAgfVxcclxcbiAgJjo6YWZ0ZXIge1xcclxcbiAgICBjb250ZW50OiAnXFxcXGVhMTknO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBNYXRlcmlhbCBJY29ucyBPdXRsaW5lZDtcXHJcXG4gICAgZm9udC1zaXplOiAxLjNyZW07XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XFxyXFxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXHJcXG4gICAgYmFja2dyb3VuZDogI2ZmZGRiMDtcXHJcXG4gICAgY29sb3I6ICMzMzJBN0M7XFxyXFxuICAgIHBhZGRpbmc6IDAuNXJlbTtcXHJcXG4gICAgYm94LXNoYWRvdzogMHB4IDFweCA0cHggMXB4IHJnYig1MCA1MCA3MSAvIDE1JSk7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDMwcHg7XFxyXFxuICAgIHJpZ2h0OiAtMTVweDtcXHJcXG4gICAgdG9wOiAtNnB4O1xcclxcbiAgfVxcclxcbiAgJjpob3ZlciB7XFxyXFxuICAgIGNvbG9yOiAkYWNjZW50LWNvbG9yO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uYnRuOmRpc2FibGVkIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgJG1pZC1ncmV5O1xcclxcbiAgY29sb3I6ICRtaWQtZ3JleTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ0bi1hZGQsXFxyXFxuLmJ0bi1sZWFybiB7XFxyXFxuICBwYWRkaW5nOiAwLjVyZW07XFxyXFxuICB3aWR0aDogM3JlbTtcXHJcXG4gIGhlaWdodDogM3JlbTtcXHJcXG59XFxyXFxuXFxyXFxuaDEsXFxyXFxuaDIsXFxyXFxuaDMsXFxyXFxuaDQge1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxufVxcclxcblxcclxcbmgxIHtcXHJcXG4gIGZvbnQtc2l6ZTogNC43cmVtO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldCkge1xcclxcbiAgICBmb250LXNpemU6IDMuNXJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuaDIge1xcclxcbiAgZm9udC1zaXplOiAyLjRyZW07XFxyXFxufVxcclxcblxcclxcbi51c2VyLWljb24ge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxuICBmb250LXNpemU6IDQ1cHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxuICB0cmFuc2l0aW9uOiBhbGwgMC41cztcXHJcXG4gICY6aG92ZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkc2Vjb25kYXJ5LWNvbG9yO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIixcIiRoZWFkZXJzLWZvbnQ6ICdNb250c2VycmF0Jywgc2Fucy1zZXJpZjtcXHJcXG4kdGV4dC1mb250OiAnT3BlbiBTYW5zJywgc2Fucy1zZXJpZjtcXHJcXG5cXHJcXG4kZGFyay1jb2xvcjogIzE5MWExNTtcXHJcXG4kYWNjZW50LWNvbG9yOiAjMzMyQTdDO1xcclxcbiRzZWNvbmRhcnktY29sb3I6ICNmZmRkYjA7XFxyXFxuJHdoaXRlLWNvbG9yOiAjZmZmZmZmO1xcclxcbiRtaWQtZ3JleTogI2ExYTFhMTtcXHJcXG4kbGlnaHQtZ3JleTogI2Q4ZDhkODtcXHJcXG4kdGV4dC1jb2xvcjogIzMzMzMzMztcXHJcXG4kb3ZlcmxheS1jb2xvcjogcmdiYSg0MSwgNDEsIDQxLCAwLjYpO1xcclxcblxcclxcbiRzZWN0aW9uLXBhZGRpbmc6IDQuNXJlbSAwO1xcclxcblxcclxcbi8vIG1lZGlhXFxyXFxuJGJyZWFrcG9pbnQtbGFwdG9wOiAxMDI1cHg7XFxyXFxuJGJyZWFrcG9pbnQtdGFibGV0OiA3NjhweDtcXHJcXG4kYnJlYWtwb2ludC1tb2JpbGU6IDQyNXB4O1xcclxcbiRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbDogNjAwcHg7XFxyXFxuXFxyXFxuJGxlYXJuZWQtd29yZC1idG4tY29sb3I6ICRzZWNvbmRhcnktY29sb3I7XFxyXFxuJGhhcmQtd29yZC1idG4tY29sb3I6ICRhY2NlbnQtY29sb3I7XFxyXFxuXFxyXFxuJGJveC1zaGFkb3c6IDBweCAxcHggNHB4IDFweCByZ2JhKDUwLCA1MCwgNzEsIDAuMTUpO1xcclxcbi8vIGxldmVsIGNvbG9yc1xcclxcblxcclxcbiRsMTogI0ZDRkNGRjtcXHJcXG4kbDI6ICNGNEY0RkY7XFxyXFxuJGwzOiAjRjBGMEZGO1xcclxcbiRsNDogI0VBRUFGRjtcXHJcXG4kbDU6ICNFNEU0RkY7XFxyXFxuJGw2OiAjREVERUZGO1xcclxcblxcclxcbi8qXFxyXFxuJGwxOiAjRUNEQ0EzO1xcclxcbiRsMjogI0NDREZBRjtcXHJcXG4kbDM6ICNBQkQ4RDM7XFxyXFxuJGw0OiAjOTZEN0UwO1xcclxcbiRsNTogIzc2QUREQTtcXHJcXG4kbDY6ICM1QTc4Q0E7XFxyXFxuKi9cIixcIkBtaXhpbiBkaXNwbGF5LWZsZXgtc3BhY2UtYmV0d2VlbiB7XFxyXFxuIGRpc3BsYXk6IGZsZXg7XFxyXFxuIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIGRpc3BsYXktZmxleC1jZW50ZXIge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuQG1peGluIGNhcmQtc3R5bGUge1xcclxcbiAgcGFkZGluZzogMS4ycmVtO1xcclxcbiAgYmFja2dyb3VuZDogJHdoaXRlLWNvbG9yO1xcclxcbiAgYm94LXNoYWRvdzogJGJveC1zaGFkb3c7XFxyXFxuICBib3JkZXItcmFkaXVzOiAzMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5AbWl4aW4gc2VjdGlvbi1iZy1jb2xvcmVkIHtcXHJcXG4gIC8vIGJhY2tncm91bmQ6ICNGQ0ZDRkY7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAkc2Vjb25kYXJ5LWNvbG9yO1xcclxcbiAgYm94LXNoYWRvdzogaW5zZXQgLTFweCAtMXB4IDNweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpLCBpbnNldCAxcHggMXB4IDJweCByZ2JhKDcsIDcsIDY5LCAwLjE1KTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDMwcHg7XFxyXFxufVwiLFwiLm1vZGFsLW92ZXJsYXkge1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxuICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogJG92ZXJsYXktY29sb3I7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB6LWluZGV4OiA1O1xcclxcbiAgJjpob3ZlciAubW9kYWwtY2xvc2UtYnRuIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGRhcmstY29sb3I7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC13cmFwcGVyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHdpZHRoOiA1MCU7XFxyXFxuICBoZWlnaHQ6IGF1dG87XFxyXFxuICB6LWluZGV4OiA2O1xcclxcbiAgY3Vyc29yOiBkZWZhdWx0O1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogJHdoaXRlLWNvbG9yO1xcclxcbiAgcGFkZGluZzogM3JlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jbG9zZS1idG4ge1xcclxcbiAgQGluY2x1ZGUgZGlzcGxheS1mbGV4LWNlbnRlcjtcXHJcXG4gIHdpZHRoOiA1MnB4O1xcclxcbiAgaGVpZ2h0OiA1MnB4O1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgcmlnaHQ6IC01MnB4O1xcclxcbiAgdG9wOiAtNTJweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwcHg7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB0cmFuc2l0aW9uOiAwLjNzIGVhc2UtaW4tb3V0O1xcclxcbiAgei1pbmRleDogNjtcXHJcXG4gICY6aG92ZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkd2hpdGUtY29sb3I7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5tb2RhbF93cmFwcGVyOmhvdmVyIC5tb2RhbC1jbG9zZS1idG4ge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1lcnItbWVzc2FnZSB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMS4ycmVtO1xcclxcbiAgY29sb3I6IHJlZDtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLW1lc3NhZ2Uge1xcclxcbiAgY29sb3I6ICRhY2NlbnQtY29sb3I7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBmb250LXNpemU6IDEuMnJlbTtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxufVwiLFwiLmZvcm0td3JhcHBlciB7XFxyXFxuICBmb3JtIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxyXFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgIHJvdy1nYXA6IDEuNXJlbTtcXHJcXG4gIH1cXHJcXG4gIC5pbnB1dC13cmFwcGVyIHtcXHJcXG4gICAgd2lkdGg6IDkwJTtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgfVxcclxcbiAgaW5wdXQge1xcclxcbiAgaGVpZ2h0OiAzcmVtO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQ7XFxyXFxuICBwYWRkaW5nOiAwIDAuNXJlbTtcXHJcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxuICAmOmZvY3VzLXZpc2libGUge1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICAuYnRuLXN1Ym1pdCB7XFxyXFxuICAgIG1hcmdpbi10b3A6IDFyZW07XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5lcnJvci1tZXNzYWdlLCAuZXJyb3ItaW4tZm9ybSB7XFxyXFxuICBjb2xvcjogcmVkO1xcclxcbn1cXHJcXG5cIixcIiosXFxyXFxuKjpiZWZvcmUsXFxyXFxuKjphZnRlciB7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG59XFxyXFxuXFxyXFxuLmJvZHkge1xcclxcbiAgZm9udC1mYW1pbHk6ICR0ZXh0LWZvbnQ7XFxyXFxuICBmb250LXNpemU6IDE2cHg7XFxyXFxuICBjb2xvcjogJHRleHQtY29sb3I7XFxyXFxuICBtYXJnaW46IDAgYXV0bztcXHJcXG4gIHBhZGRpbmc6IDAgMi41cmVtO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBhbGlnbi1jb250ZW50OiBzdHJldGNoO1xcclxcbiAgZmxleC13cmFwOiBub3dyYXA7XFxyXFxuICBtYXgtd2lkdGg6IDE0NDBweDtcXHJcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldCkge1xcclxcbiAgICBwYWRkaW5nOiAwIDFyZW07XFxyXFxuICB9XFxyXFxufVxcclxcblwiLFwiLmhlYWRlciB7XFxyXFxuICBAaW5jbHVkZSBkaXNwbGF5LWZsZXgtc3BhY2UtYmV0d2VlbjtcXHJcXG4gIGZvbnQtZmFtaWx5OiAkaGVhZGVycy1mb250O1xcclxcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXHJcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjI7XFxyXFxuICBoZWlnaHQ6IDc1cHg7XFxyXFxuICBtYXJnaW46IGF1dG87XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIC8vIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAkbGlnaHQtZ3JleTtcXHJcXG4gIHotaW5kZXg6IDE7XFxyXFxuICBwYWRkaW5nOiAwIDJyZW07XFxyXFxufVxcclxcblxcclxcbi5sb2dvIHtcXHJcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtdGFibGV0KSB7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxLjE7XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4ycmVtO1xcclxcbiAgICBsaW5lLWhlaWdodDogMS4xO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uaGVhZGVyLW1lbnUge1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgICB3aWR0aDogMzIwcHg7XFxyXFxuICAgIGhlaWdodDogMTAwdmg7XFxyXFxuICAgIHRvcDogMDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHdoaXRlLWNvbG9yO1xcclxcbiAgICByaWdodDogLTMyMHB4O1xcclxcbiAgICB6LWluZGV4OiAyO1xcclxcbiAgICBmb250LXNpemU6IDMycHg7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiA1MS4ycHg7XFxyXFxuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuOHMgZWFzZS1pbi1vdXQ7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5tZW51LWl0ZW1zIHtcXHJcXG4gIEBpbmNsdWRlIGRpc3BsYXktZmxleC1jZW50ZXI7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDQ4cHg7XFxyXFxuICAgIGdhcDogNDNweDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLm1lbnUtaXRlbS1saW5rIHtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBwYWRkaW5nOiAyOXB4O1xcclxcbiAgJjpob3ZlciB7XFxyXFxuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAkZGFyay1jb2xvcjtcXHJcXG4gICAgcGFkZGluZy1ib3R0b206IDI3cHg7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5hdXRoIHtcXHJcXG4gIEBpbmNsdWRlIGRpc3BsYXktZmxleC1jZW50ZXI7XFxyXFxuICBnYXA6IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5idXJnZXItaWNvbiB7XFxyXFxuICBkaXNwbGF5OiBub25lO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgd2lkdGg6IDMwcHg7XFxyXFxuICAgIGhlaWdodDogMjJweDtcXHJcXG4gICAgbWFyZ2luOiAwIDFyZW07XFxyXFxuICAgIHotaW5kZXg6IDk7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgdHJhbnNpdGlvbjogMC41cztcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmJ1cmdlci1saW5lIHtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC10YWJsZXQtdmVydGljYWwpIHtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICRkYXJrLWNvbG9yO1xcclxcbiAgICBoZWlnaHQ6IDJweDtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHRvcDogNTAlO1xcclxcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxyXFxuICAgICY6OmJlZm9yZSB7XFxyXFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZGFyay1jb2xvcjtcXHJcXG4gICAgICBoZWlnaHQ6IDJweDtcXHJcXG4gICAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgICB0b3A6IDUwJTtcXHJcXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxyXFxuICAgICAgY29udGVudDogXFxcIlxcXCI7XFxyXFxuICAgICAgbWFyZ2luLXRvcDogMTBweDtcXHJcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZGFyay1jb2xvcjtcXHJcXG4gICAgfVxcclxcbiAgICAmOjphZnRlciB7XFxyXFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZGFyay1jb2xvcjtcXHJcXG4gICAgICBoZWlnaHQ6IDJweDtcXHJcXG4gICAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgICB0b3A6IDUwJTtcXHJcXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxyXFxuICAgICAgY29udGVudDogXFxcIlxcXCI7XFxyXFxuICAgICAgbWFyZ2luLXRvcDogLTEwcHg7XFxyXFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGRhcmstY29sb3I7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmNsaWNrZWQge1xcclxcbiAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcclxcbiAgei1pbmRleDogOTk7XFxyXFxufVxcclxcblxcclxcbi5vcGVuZWQge1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxufVxcclxcblwiLFwiLmZvb3RlciB7XFxyXFxuICBAaW5jbHVkZSBkaXNwbGF5LWZsZXgtc3BhY2UtYmV0d2VlbjtcXHJcXG4gIGZvbnQtZmFtaWx5OiAkaGVhZGVycy1mb250O1xcclxcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXHJcXG4gIGZvbnQtc2l6ZTogMC45cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMTtcXHJcXG4gIG1pbi1oZWlnaHQ6IDkwcHg7XFxyXFxuICBtYXJnaW46IGF1dG87XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRkYXJrLWNvbG9yO1xcclxcbiAgY29sb3I6ICR3aGl0ZS1jb2xvcjtcXHJcXG4gIHBhZGRpbmc6IDAgMjBweDtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC10YWJsZXQtdmVydGljYWwpIHtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgZ2FwOiAxcmVtO1xcclxcbiAgICBwYWRkaW5nOiAwLjVyZW0gMDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLnRlYW0tZ2l0aHViIHtcXHJcXG4gIEBpbmNsdWRlIGRpc3BsYXktZmxleC1jZW50ZXI7XFxyXFxuICBmbGV4LXdyYXA6IHdyYXA7XFxyXFxuICBnYXA6IDFyZW07XFxyXFxuICBhIHtcXHJcXG4gICAgY29sb3I6ICR3aGl0ZS1jb2xvcjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLnJzLWxvZ28gaW1nIHtcXHJcXG4gIHdpZHRoOiA3cmVtO1xcclxcbn1cXHJcXG5cIixcIi5tYWluIHtcXHJcXG4gIGZsZXgtZ3JvdzogMTtcXHJcXG59XFxyXFxuXCIsXCIuYXVkaW8tY2FsbCB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogMTAwdmg7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICAvKiBoZWlnaHQ6IGNhbGMoMTAwdmggLSA3NXB4KTsgKi9cXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxODBkZWcsICM3ZDVkYjAsICNiMDZkOWEgNzIlLCAjYzU4NGE0KTtcXHJcXG4gIGNvbG9yOiBoc2xhKDBkZWcsIDAlLCAxMDAlLCAwLjcpO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAvLyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIC8qIG1heC13aWR0aDogMTQ0MHB4OyAqL1xcclxcbiAgbWFyZ2luOiAwIGF1dG87XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgcGFkZGluZzogODBweCAxMHB4IDAgMTBweDtcXHJcXG4gIC5jb250YWluZXIge1xcclxcbiAgICBtYXJnaW46IDAgYXV0bztcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIG1heC13aWR0aDogMTI1MHB4O1xcclxcbiAgfVxcclxcblxcclxcbiAgLmxldmVsLXNlbGVjdCB7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgICByb3ctZ2FwOiAycmVtO1xcclxcbiAgfVxcclxcbiAgLnNlbGVjdC1ibG9jayB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTAzMHB4KSB7XFxyXFxuICAgICAgbWF4LXdpZHRoOiA1MDBweDtcXHJcXG4gICAgfVxcclxcbiAgICAuc2VsZWN0LWJsb2NrX190aXRsZSB7XFxyXFxuICAgICAgcGFkZGluZzogMXJlbTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgLnNlbGVjdGVkIHtcXHJcXG4gICAgY29sb3I6IGhzbGEoMGRlZywgMCUsIDEwMCUpO1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCBoc2xhKDBkZWcsIDAlLCAxMDAlKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGEsXFxyXFxuICBidXR0b24ge1xcclxcbiAgICBtYXJnaW46IDAuMnJlbTtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgaHNsYSgwZGVnLCAwJSwgMTAwJSwgMC4yKTtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxyXFxuICAgIGNvbG9yOiBpbmhlcml0O1xcclxcbiAgICBtaW4td2lkdGg6IDE2MnB4O1xcclxcbiAgICBwYWRkaW5nOiAxOXB4IDE1cHggMjFweDtcXHJcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMTVzIGVhc2U7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICAmOmhvdmVyIHtcXHJcXG4gICAgICBjb2xvcjogaHNsYSgwZGVnLCAwJSwgMTAwJSk7XFxyXFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgaHNsYSgwZGVnLCAwJSwgMTAwJSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zdGFnZSB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zdGFnZV9faW1nIHtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcclxcbiAgICBoZWlnaHQ6IDEzcmVtO1xcclxcbiAgICB3aWR0aDogMTNyZW07XFxyXFxuICAgIG1hcmdpbjogMXJlbSBhdXRvO1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5hbnN3ZXJzIHtcXHJcXG4gICAgbWFyZ2luOiAzcmVtIDA7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGZsZXgtd3JhcDogd3JhcDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICAgIGdhcDogMnJlbTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5hbnN3ZXIge1xcclxcbiAgICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZ2FwOiAwLjVyZW07XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gICAgJiA6aG92ZXIge1xcclxcbiAgICAgIGNvbG9yOiBoc2xhKDBkZWcsIDAlLCAxMDAlKTtcXHJcXG4gICAgfVxcclxcbiAgICAuY2hlY2tlZCB7XFxyXFxuICAgICAgY29sb3I6IGdyZWVuO1xcclxcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkO1xcclxcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gICAgICBoZWlnaHQ6IDJyZW07XFxyXFxuICAgICAgd2lkdGg6IDJyZW07XFxyXFxuICAgICAgbGluZS1oZWlnaHQ6IDJyZW07XFxyXFxuICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxyXFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2I3ZDY5MztcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcblxcclxcbiAgLndvcmQge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgZm9udC1zaXplOiAyLjVyZW07XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuc3BlYWtlci1idXR0b24ge1xcclxcbiAgICBib3JkZXI6IG5vbmU7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gICAgJjpob3ZlciB7XFxyXFxuICAgICAgYm9yZGVyOiBub25lO1xcclxcbiAgICB9XFxyXFxuICAgIHN2ZyB7XFxyXFxuICAgICAgcGFkZGluZzogMC4ycmVtO1xcclxcbiAgICAgICY6aG92ZXIge1xcclxcbiAgICAgICAgcGF0aCB7XFxyXFxuICAgICAgICAgIGZpbGw6ICMzYzNlM2QgIWltcG9ydGFudDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICBtaW4td2lkdGg6IDBweDtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5zcGVha2VyLWJ1dHRvbl9taW4ge1xcclxcbiAgICBwYWRkaW5nOiAwIDFyZW07XFxyXFxuICAgIHN2ZyB7XFxyXFxuICAgICAgd2lkdGg6IDNyZW07XFxyXFxuICAgICAgaGVpZ2h0OiAzcmVtO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuZ2FtZV9fcmVzdWx0IHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2U2ZTllZTtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBtYXgtd2lkdGg6IDUwMHB4O1xcclxcbiAgICBtaW4taGVpZ2h0OiA2NDZweDtcXHJcXG4gICAgcGFkZGluZzogNDJweCAxNnB4O1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgfVxcclxcblxcclxcbiAgLnJlc3VsdF9fc2NvcmUge1xcclxcbiAgICBjb2xvcjogIzM3MzgzYztcXHJcXG4gICAgZm9udC1zaXplOiAzNHB4O1xcclxcbiAgICBmb250LXdlaWdodDogMzAwO1xcclxcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuZ2FtZV9fbGlzdHMge1xcclxcbiAgICBtYXJnaW4tdG9wOiAzMHB4O1xcclxcbiAgfVxcclxcblxcclxcbiAgLnJlc3VsdF9fdHJ1ZSxcXHJcXG4gIC5yZXN1bHRfX2ZhbHNlIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDEuMzM7XFxyXFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxyXFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAucmVzdWx0X190cnVlIHtcXHJcXG4gICAgY29sb3I6ICMyOGMzOGE7XFxyXFxuICAgIG1hcmdpbjogMXJlbSAwO1xcclxcbiAgfVxcclxcblxcclxcbiAgLnJlc3VsdF9fZmFsc2Uge1xcclxcbiAgICBjb2xvcjogI2VkNTkzYjtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5yZXN1bHRfX3dvcmQge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBnYXA6IDEwcHg7XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGNvbG9yOiAjMzczODNjO1xcclxcbiAgICBmb250LXNpemU6IDE2cHg7XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiAxLjI1O1xcclxcbiAgICB0ZXh0LXRyYW5zZm9ybTogbG93ZXJjYXNlO1xcclxcbiAgICBmb250LXdlaWdodDogNTAwO1xcclxcbiAgICBtYXJnaW4tdG9wOiA1cHg7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAucmVzdWx0X193b3JkLWVuIHtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5yZXN1bHRfX3ZvaWNlIHtcXHJcXG4gICAgd2lkdGg6IDMzcHg7XFxyXFxuICAgIGhlaWdodDogMzNweDtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgICBzdmcge1xcclxcbiAgICAgIHdpZHRoOiAycmVtO1xcclxcbiAgICAgIGhlaWdodDogMnJlbTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbiAgLmNsb3NlLWJ1dHRvbiB7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gICAgd2lkdGg6IDRyZW07XFxyXFxuICAgIGhlaWdodDogNHJlbTtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICBsaW5lLWhlaWdodDogMjJweDtcXHJcXG4gICAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgICBtaW4td2lkdGg6IG1pbi1jb250ZW50O1xcclxcbiAgfVxcclxcblxcclxcbiAgLm11dGUtYnV0dG9uIHtcXHJcXG4gICAgbWFyZ2luOiA0cHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogM3JlbTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC5yZXN1bHRfX2J1dHRvbiB7XFxyXFxuICAgIG1hcmdpbi10b3A6IDFyZW07XFxyXFxuICAgIGJvcmRlcjogMnB4IHNvbGlkICMyOGMzOGE7XFxyXFxuICAgIGNvbG9yOiAjM2MzZTNkO1xcclxcbiAgICBmb250LXNpemU6IDEuMnJlbTtcXHJcXG4gICAgJjpob3ZlciB7XFxyXFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzI4YzM4YTtcXHJcXG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAjMjhjMzhhO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuXFxyXFxuICAuYnV0dG9ucy13cmFwcGVyIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCIsXCIuYm9keSB7XFxyXFxuICAmLS1zcHJpbnQge1xcclxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICAgIG1heC13aWR0aDogMTAwJTtcXHJcXG4gICAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwZDM4NDg7XFxyXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi9hc3NldHMvc3ByaW50L3NwcmludC1iZy1ib3R0b20uc3ZnXFxcIiksXFxyXFxuICAgICAgdXJsKFxcXCIuL2Fzc2V0cy9zcHJpbnQvc3ByaW50LWJnLWxlZnQuc3ZnXFxcIiksXFxyXFxuICAgICAgdXJsKFxcXCIuL2Fzc2V0cy9zcHJpbnQvc3ByaW50LWJnLXJpZ2h0LnN2Z1xcXCIpO1xcclxcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0LCBuby1yZXBlYXQsIG5vLXJlcGVhdDtcXHJcXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMDAlLCBhdXRvLCBhdXRvO1xcclxcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b20sIDAgMCwgMTAwJSAwO1xcclxcblxcclxcbiAgICBoMiB7XFxyXFxuICAgICAgZm9udC1zaXplOiAyNHB4O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC5oZWFkZXIge1xcclxcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgICB0b3A6IDA7XFxyXFxuICAgICAgbWF4LXdpZHRoOiAxMzYwcHg7XFxyXFxuICAgICAgcGFkZGluZzogMCAycmVtO1xcclxcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICAgIHotaW5kZXg6IDEwO1xcclxcbiAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcXHJcXG4gICAgICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gICAgICBib3JkZXI6IG5vbmU7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLmxvZ28ge1xcclxcbiAgICAgIGEge1xcclxcbiAgICAgICAgY29sb3I6ICNmZmZmZmY7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC5tZW51LWl0ZW0tbGluayB7XFxyXFxuICAgICAgY29sb3I6ICNmZmZmZmY7XFxyXFxuXFxyXFxuICAgICAgJjpob3ZlciB7XFxyXFxuICAgICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgI2ZmZmZmZjtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLmJ0bi1zZWNvbmRhcnkge1xcclxcbiAgICAgIGNvbG9yOiAjMDAwMDAwO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC5lbnRlci1jYWJpbmV0LWxpbmsge1xcclxcbiAgICAgIGNvbG9yOiAjZmZmZmZmO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC5tYWluIHtcXHJcXG4gICAgICBwYWRkaW5nOiA3NXB4IDA7XFxyXFxuICAgICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgICBtaW4taGVpZ2h0OiAxMDB2aDtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAuZm9vdGVyIHtcXHJcXG4gICAgICBkaXNwbGF5OiBub25lO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC5idXJnZXItbGluZSB7XFxyXFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXHJcXG4gICAgICAmOjphZnRlciB7XFxyXFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICAmOjpiZWZvcmUge1xcclxcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLm9wZW5lZCB7XFxyXFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzBkMzg0ODtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uc3ByaW50IHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBwYWRkaW5nOiAyMHB4IDA7XFxyXFxuICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcblxcclxcbiAgLnNwcmludF9fc2VsZWN0LXRpdGxlIHtcXHJcXG4gICAgZm9udC1zaXplOiAyLjRyZW07XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5zcHJpbnRfX3NlbGVjdCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBtaW4td2lkdGg6IDUwJTtcXHJcXG59XFxyXFxuXFxyXFxuLnNwcmludF9fc2VsZWN0LWRlc2NyIHtcXHJcXG4gIG1hcmdpbi10b3A6IDJyZW07XFxyXFxufVxcclxcblxcclxcbi5zcHJpbnRfX3NlbGVjdC10ZXh0IHtcXHJcXG4gIG1hcmdpbi10b3A6IDJyZW07XFxyXFxufVxcclxcblxcclxcbi5zcHJpbnRfX2xldmVscyB7XFxyXFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgZ2FwOiAwLjRyZW07XFxyXFxufVxcclxcblxcclxcbi5zcHJpbnRfX2xldmVsIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgd2lkdGg6IDE2MnB4O1xcclxcbiAgaGVpZ2h0OiA1NXB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnNwcmludF9fY2xvc2Uge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAxMHB4O1xcclxcbiAgcmlnaHQ6IDIwcHg7XFxyXFxuICB3aWR0aDogNDBweDtcXHJcXG4gIGhlaWdodDogNDBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDQwcHg7XFxyXFxuICB6LWluZGV4OiAxO1xcclxcbiAgbWFyZ2luOiAyMHB4IGF1dG87XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFxyXFxuICAmOjpiZWZvcmUge1xcclxcbiAgICBjb250ZW50OiBcXFwiK1xcXCI7XFxyXFxuICAgIGNvbG9yOiAjZmZmZmZmO1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICAgIHotaW5kZXg6IDI7XFxyXFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXHJcXG4gICAgZm9udC1zaXplOiA1MHB4O1xcclxcbiAgICBsaW5lLWhlaWdodDogMTtcXHJcXG4gICAgdG9wOiAtNXB4O1xcclxcbiAgICBsZWZ0OiA2cHg7XFxyXFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGN1YmljLWJlemllcigwLjc3LCAwLCAwLjIsIDAuODUpO1xcclxcbiAgfVxcclxcblxcclxcbiAgJjo6YWZ0ZXIge1xcclxcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGxlZnQ6IDA7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxyXFxuICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxyXFxuICAgIHotaW5kZXg6IDE7XFxyXFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGN1YmljLWJlemllcigwLjc3LCAwLCAwLjIsIDAuODUpO1xcclxcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMDEpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uc3ByaW50X19jbG9zZTpob3ZlcjphZnRlciB7XFxyXFxuICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcclxcbn1cXHJcXG5cXHJcXG4uc3ByaW50X19jbG9zZTpob3ZlcjpiZWZvcmUge1xcclxcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjgpIHJvdGF0ZSg0NWRlZyk7XFxyXFxuICBjb2xvcjogIzBkMzg0ODtcXHJcXG59XFxyXFxuXFxyXFxuLnRpbWVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi50aW1lcl9fdGltZSB7XFxyXFxuICBmb250LXNpemU6IDMwcHg7XFxyXFxuICBmb250LXdlaWdodDogbGlnaHRlcjtcXHJcXG4gIHdpZHRoOiAxNjBweDtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi50aW1lcl9fc3ZnIHtcXHJcXG4gIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKSBzY2FsZVgoLTEpO1xcclxcbn1cXHJcXG5cXHJcXG4uY2lyY2xlX2FuaW1hdGlvbiB7XFxyXFxuICBzdHJva2UtZGFzaGFycmF5OiA0NDA7XFxyXFxuICBzdHJva2UtZGFzaG9mZnNldDogMDtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAxcyBsaW5lYXI7XFxyXFxufVxcclxcblxcclxcbi5zcHJpbnRfX3JlYWR5IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbn1cXHJcXG5cXHJcXG4udGltZXItLWNvbnRyb2wge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAyMHB4O1xcclxcbiAgbGVmdDogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnNwcmludF9fY29udHJvbCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5jb250cm9sX19zb3VuZCB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICByaWdodDogMDtcXHJcXG4gIHdpZHRoOiAyM3B4O1xcclxcbiAgaGVpZ2h0OiAyNHB4O1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCIuL2Fzc2V0cy9zcHJpbnQvc291bmQtZGVmYXVsdC5zdmdcXFwiKTtcXHJcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFxyXFxuICAmLS1vZmYge1xcclxcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4vYXNzZXRzL3NwcmludC9zb3VuZC1tdXRlLnN2Z1xcXCIpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uY29udHJvbF9fY29udGFpbmVyIHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiA1MDBweDtcXHJcXG4gIHBhZGRpbmc6IDMwcHg7XFxyXFxuICBtYXJnaW4tdG9wOiAxMHB4O1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2xhKDAsIDAlLCAxMDAlLCAwLjA2KTtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbnRyb2xfX3ZvaWNlIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHJpZ2h0OiAyMHB4O1xcclxcbiAgdG9wOiAyMHB4O1xcclxcbiAgd2lkdGg6IDMzcHg7XFxyXFxuICBoZWlnaHQ6IDMzcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4vYXNzZXRzL3NwcmludC92b2ljZS5zdmdcXFwiKTtcXHJcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFxyXFxuICAmOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCIuL2Fzc2V0cy9zcHJpbnQvdm9pY2UtaG92ZXIuc3ZnXFxcIik7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5jb250cm9sX19zZXJpZXMtbGlzdCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBnYXA6IDIwcHg7XFxyXFxufVxcclxcblxcclxcbi5jb250cm9sX19zZXJpZXMge1xcclxcbiAgd2lkdGg6IDI2cHg7XFxyXFxuICBoZWlnaHQ6IDI2cHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4vYXNzZXRzL3NwcmludC9jaXJjbGUtZW1wdHkuc3ZnXFxcIik7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCU7XFxyXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcclxcblxcclxcbiAgJi0tYWN0aXZlIHtcXHJcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXCIuL2Fzc2V0cy9zcHJpbnQvdHJ1ZS1zZXJpZXMuc3ZnXFxcIik7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5jb250cm9sX19tdWx0aXBseSB7XFxyXFxuICBtYXJnaW4tdG9wOiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY29udHJvbF9fcGFycm90cyB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgd2lkdGg6IDIwNHB4O1xcclxcbiAgaGVpZ2h0OiA1N3B4O1xcclxcbiAgbWFyZ2luLXRvcDogMzBweDtcXHJcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi9hc3NldHMvc3ByaW50L2JyYW5jaC5zdmdcXFwiKTtcXHJcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxyXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b207XFxyXFxufVxcclxcblxcclxcbi5jb250cm9sX19wYXJyb3Qge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgdG9wOiA2cHg7XFxyXFxufVxcclxcblxcclxcbi5jb250cm9sX193b3JkLWVuIHtcXHJcXG4gIGZvbnQtc2l6ZTogMzZweDtcXHJcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxyXFxufVxcclxcblxcclxcbi5jb250cm9sX193b3JkLXJ1IHtcXHJcXG4gIGZvbnQtc2l6ZTogMjRweDtcXHJcXG4gIGNvbG9yOiBoc2xhKDAsIDAlLCAxMDAlLCAwLjYpO1xcclxcbn1cXHJcXG5cXHJcXG4uY29udHJvbF9fYnV0dG9ucyB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZ2FwOiAyMHB4O1xcclxcbiAgbWFyZ2luLXRvcDogNDBweDtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiA0MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY29udHJvbF9fYnV0dG9uIHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbiAgZm9udC1zaXplOiAyMHB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXHJcXG4gIGhlaWdodDogNTBweDtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiAxODNweDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG5cXHJcXG4gICY6OmJlZm9yZSB7XFxyXFxuICAgIGJvdHRvbTogLTQ1cHg7XFxyXFxuICAgIGNvbG9yOiAjN2U5MTlmO1xcclxcbiAgICBkaXNwbGF5OiBibG9jaztcXHJcXG4gICAgZm9udC1zaXplOiAyOHB4O1xcclxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAmLS1mYWxzZSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZDU5M2I7XFxyXFxuXFxyXFxuICAgICY6OmJlZm9yZSB7XFxyXFxuICAgICAgY29udGVudDogXFxcIuKGkFxcXCI7XFxyXFxuICAgICAgbGVmdDogNDAlO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuXFxyXFxuICAmLS10cnVlIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4YzM4YTtcXHJcXG5cXHJcXG4gICAgJjo6YmVmb3JlIHtcXHJcXG4gICAgICBjb250ZW50OiBcXFwi4oaSXFxcIjtcXHJcXG4gICAgICByaWdodDogNDAlO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5zcHJpbnRfX3Jlc3VsdCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgI2U2ZTllZTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICBtYXgtd2lkdGg6IDUwMHB4O1xcclxcbiAgbWF4LWhlaWdodDogNTAwcHg7XFxyXFxuICBwYWRkaW5nOiA0MnB4IDE2cHg7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi5yZXN1bHRfX3Njb3JlIHtcXHJcXG4gIGNvbG9yOiAjMzczODNjO1xcclxcbiAgZm9udC1zaXplOiAzNHB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXHJcXG4gIGFsaWduLXNlbGY6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnNwcmludF9fbGlzdHMge1xcclxcbiAgbWFyZ2luLXRvcDogMzBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnJlc3VsdF9fdHJ1ZSxcXHJcXG4ucmVzdWx0X19mYWxzZSB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbiAgZm9udC1zaXplOiAxMnB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjMzO1xcclxcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXHJcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5yZXN1bHRfX3RydWUge1xcclxcbiAgY29sb3I6ICMyOGMzOGE7XFxyXFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4ucmVzdWx0X19mYWxzZSB7XFxyXFxuICBjb2xvcjogI2VkNTkzYjtcXHJcXG59XFxyXFxuXFxyXFxuLnJlc3VsdF9fd29yZCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZ2FwOiAxMHB4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGNvbG9yOiAjMzczODNjO1xcclxcbiAgZm9udC1zaXplOiAxNnB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMjU7XFxyXFxuICB0ZXh0LXRyYW5zZm9ybTogbG93ZXJjYXNlO1xcclxcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXHJcXG4gIG1hcmdpbi10b3A6IDVweDtcXHJcXG59XFxyXFxuXFxyXFxuLnJlc3VsdF9fd29yZC1lbiB7XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbn1cXHJcXG5cXHJcXG4ucmVzdWx0X192b2ljZSB7XFxyXFxuICB3aWR0aDogMzNweDtcXHJcXG4gIGhlaWdodDogMzNweDtcXHJcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi9hc3NldHMvc3ByaW50L3ZvaWNlLWdyZXkuc3ZnXFxcIik7XFxyXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcblxcclxcbiAgJjpob3ZlciB7XFxyXFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiLi9hc3NldHMvc3ByaW50L3ZvaWNlLWhvdmVyLnN2Z1xcXCIpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4ucmVzdWx0X19yZXN0YXJ0LWJ0biB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDM3LCAxMzAsIDIzMSwgMC4wOCk7XFxyXFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxyXFxuICBjb2xvcjogIzI1ODJlNztcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBsaW5lLWhlaWdodDogMS40MztcXHJcXG4gIG1hcmdpbi10b3A6IDI0cHg7XFxyXFxuICBwYWRkaW5nOiAxMHB4IDQycHg7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuXFxyXFxuICAmOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgzNywgMTMwLCAyMzEsIDAuMTIpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uc3ByaW50X19yZXN0YXJ0LW1lc3NhZ2Uge1xcclxcbiAgZm9udC1zaXplOiAxNHB4O1xcclxcbiAgd2lkdGg6IDYwJTtcXHJcXG4gIGNvbG9yOiAjZWQ1OTNiO1xcclxcbiAgbWFyZ2luLXRvcDogMTBweDtcXHJcXG59XFxyXFxuXCIsXCIudGV4dGJvb2sge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBtYXJnaW4tdG9wOiAtMnB4O1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uYXNpZGUge1xcclxcbiAgcGFkZGluZzogMnJlbSAxcmVtO1xcclxcbiAgd2lkdGg6IDE1JTtcXHJcXG4gIGZsZXgtc2hyaW5rOiAwO1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtdGFibGV0LXZlcnRpY2FsKSB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICBwYWRkaW5nOiAxcmVtIDAuMnJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLnNpZGViYXItY29udGVudCB7XFxyXFxuICBwb3NpdGlvbjogLXdlYmtpdC1zdGlja3k7XFxyXFxuICBwb3NpdGlvbjogc3RpY2t5O1xcclxcbiAgdG9wOiAwO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiAxLjVyZW07XFxyXFxuICAvLyBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAkbGlnaHQtZ3JleTtcXHJcXG4gIGdhcDogMC43cmVtO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcclxcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXHJcXG4gIH1cXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1tb2JpbGUpIHtcXHJcXG4gICAgZ2FwOiAwLjNyZW07XFxyXFxuICAgIHBhZGRpbmc6IDA7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgICByb3ctZ2FwOiAxLjhyZW07XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5zaWRlYmFyLXRleHQge1xcclxcbiAgZm9udC1zaXplOiAxLjJyZW07XFxyXFxuICBmb250LXdlaWdodDogNjAwO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICBmb250LXNpemU6IDFyZW07XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5idG4tbGV2ZWwge1xcclxcbiAgQGluY2x1ZGUgZGlzcGxheS1mbGV4LWNlbnRlcjtcXHJcXG4gIGhlaWdodDogNS42cmVtO1xcclxcbiAgd2lkdGg6IDUuNnJlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gIHBhZGRpbmc6IDIuNXJlbTtcXHJcXG4gIGZvbnQtc2l6ZTogMi41cmVtO1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIHRyYW5zaXRpb246IDAuM3MgZWFzZS1pbi1vdXQ7XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtdGFibGV0LXZlcnRpY2FsKSB7XFxyXFxuICAgIGhlaWdodDogMy4ycmVtO1xcclxcbiAgICB3aWR0aDogMy4ycmVtO1xcclxcbiAgICBwYWRkaW5nOiAwO1xcclxcbiAgICBmb250LXNpemU6IDEuNXJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLnVzZXJib29rLW1hcmsge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGJvdHRvbTogMy44cmVtO1xcclxcbiAgcmlnaHQ6IDIuNHJlbTtcXHJcXG4gIGJhY2tncm91bmQ6ICRzZWNvbmRhcnktY29sb3I7XFxyXFxuICBjb2xvcjogJGFjY2VudC1jb2xvcjtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDMwcHg7XFxyXFxuICBwYWRkaW5nOiAwLjVyZW07XFxyXFxuICBib3gtc2hhZG93OiAkYm94LXNoYWRvdztcXHJcXG4gIC5tYXRlcmlhbC1pY29ucy1vdXRsaW5lZCB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4zcmVtO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICBib3R0b206IDJyZW07XFxyXFxuICAgIHJpZ2h0OiAxcmVtO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICByaWdodDogOS4xcmVtO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4udGV4dC1ib29rLXBhZ2Uge1xcclxcbiAgQGluY2x1ZGUgc2VjdGlvbi1iZy1jb2xvcmVkO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBwYWRkaW5nOiAwIDIuNXJlbSAxLjVyZW07XFxyXFxuICB3aWR0aDogODUlO1xcclxcbiAgYm9yZGVyOiAzcHggc29saWQgI2ZmZmZmZjtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDEuNXJlbTtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC10YWJsZXQtdmVydGljYWwpIHtcXHJcXG4gICB3aWR0aDogMTAwJTtcXHJcXG4gIH1cXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1tb2JpbGUpIHtcXHJcXG4gICAgcGFkZGluZzogMXJlbTtcXHJcXG4gICB9XFxyXFxufVxcclxcblxcclxcbi50ZXh0LWJvb2stcGFnZS1oZWFkIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBwYWRkaW5nOiAyLjVyZW07XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgZ2FwOiAxLjVyZW07XFxyXFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtdGFibGV0LXZlcnRpY2FsKSB7XFxyXFxuICAgIHBhZGRpbmc6IDIuNXJlbSAxLjJyZW07XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIGdhcDogMC41cmVtO1xcclxcbiAgICBwYWRkaW5nOiAxLjVyZW07XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmNhcmRzLXdyYXBwZXIge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG4gIHJvdy1nYXA6IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5jYXJkIHtcXHJcXG4gIEBpbmNsdWRlIGNhcmQtc3R5bGU7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIHdpZHRoOiAzMnJlbTtcXHJcXG4gIGhlaWdodDogMjVyZW07XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IGF1dG87XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5jYXJkLW1haW4taW5mby13cmFwcGVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMS41cmVtO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXHJcXG4gICB9XFxyXFxufVxcclxcblxcclxcbi5idG4tcGxheSB7XFxyXFxuICBtYXJnaW4tbGVmdDogLTJyZW07XFxyXFxuICAmOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHNlY29uZGFyeS1jb2xvcjtcXHJcXG4gIH1cXHJcXG4gIHN2ZyB7XFxyXFxuICAgIHdpZHRoOiAyNXB4O1xcclxcbiAgICBoZWlnaHQ6IDI1cHg7XFxyXFxuICAgIHBhdGgge1xcclxcbiAgICAgIGZpbGw6ICRkYXJrLWNvbG9yO1xcclxcbiAgICAgIHN0cm9rZTogJGRhcmstY29sb3I7XFxyXFxuICAgIH1cXHJcXG4gICAgJjpob3ZlciB7XFxyXFxuICAgICAgZmlsbDogJGFjY2VudC1jb2xvcjtcXHJcXG4gICAgICBwYXRoIHtcXHJcXG4gICAgICAgIGZpbGw6ICRhY2NlbnQtY29sb3I7XFxyXFxuICAgICAgICBzdHJva2U6ICRhY2NlbnQtY29sb3I7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcclxcbiAgICBtYXJnaW4tdG9wOiAtMnJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQtaW1nIHtcXHJcXG4gIHdpZHRoOiAxMHJlbTtcXHJcXG4gIGhlaWdodDogOHJlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDMwcHg7XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwcmVtO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC13b3JkLWluZm8ge1xcclxcbiAgcGFkZGluZy1sZWZ0OiAwLjhyZW07XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLndvcmQge1xcclxcbiAgZm9udC1zaXplOiAxLjhyZW07XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbn1cXHJcXG5cXHJcXG4ud29yZC10cmFuc2NyaXB0aW9uIHtcXHJcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXHJcXG4gIGNvbG9yOiAkbWlkLWdyZXk7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMC44cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ud29yZC10cmFuc2xhdGUge1xcclxcbiAgZm9udC1zaXplOiAxLjNyZW07XFxyXFxufVxcclxcblxcclxcbi51c2VyLWJ0bnMge1xcclxcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGdhcDogMC41cmVtO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1tb2JpbGUpIHtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXHJcXG4gICAgbWFyZ2luOiBhdXRvO1xcclxcbiAgICBwYWRkaW5nLXRvcDogMXJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmFuc3dlcnMge1xcclxcbiAgZm9udC1zaXplOiAwLjhyZW07XFxyXFxufVxcclxcblxcclxcbi5oYXJkLXdvcmQtYnRuIHtcXHJcXG4gIGJvcmRlci1jb2xvcjogJGFjY2VudC1jb2xvcjtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRhY2NlbnQtY29sb3I7XFxyXFxuICAuYnRuLWljb24ge1xcclxcbiAgICBjb2xvcjogJHNlY29uZGFyeS1jb2xvcjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmxlYXJuLXdvcmQtYnRuIHtcXHJcXG4gIGJvcmRlci1jb2xvcjogJHNlY29uZGFyeS1jb2xvcjtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRzZWNvbmRhcnktY29sb3I7XFxyXFxuICAuYnRuLWljb24ge1xcclxcbiAgICBjb2xvcjogJGFjY2VudC1jb2xvcjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLndvcmQtbWVhbi10cmFuc2xhdGUsIC53b3JkLWV4LXRyYW5zbGF0ZSB7XFxyXFxuICBjb2xvcjogJG1pZC1ncmV5O1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNjtcXHJcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXHJcXG59XFxyXFxuXFxyXFxuLndvcmQtbWVhbi10cmFuc2xhdGUge1xcclxcbiAgcGFkZGluZy1ib3R0b206IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5wYWdpbmF0aW9uIHtcXHJcXG4gIEBpbmNsdWRlIGRpc3BsYXktZmxleC1jZW50ZXI7XFxyXFxuICBwYWRkaW5nOiAyLjVyZW0gMXJlbSAwO1xcclxcbn1cXHJcXG5cXHJcXG4ucGFnZS1pbnB1dCB7XFxyXFxuICBtYXJnaW46IDAgM3JlbTtcXHJcXG4gIHdpZHRoOiAycmVtO1xcclxcbiAgZm9udC1zaXplOiAxLjVyZW07XFxyXFxuICBmb250LXdlaWdodDogNjAwO1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQ7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAmOmZvY3VzLXZpc2libGUge1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICBtYXJnaW46IDAgMC41cmVtO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBDaHJvbWUsIFNhZmFyaSwgRWRnZSwgT3BlcmEgKi9cXHJcXG4ucGFnZS1pbnB1dDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcXHJcXG4ucGFnZS1pbnB1dDo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XFxyXFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxufVxcclxcblxcclxcbi8qIEZpcmVmb3ggKi9cXHJcXG4ucGFnZS1pbnB1dCB7XFxyXFxuICAtbW96LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcXHJcXG59XCIsXCIudXNlci1wYWdlIHtcXHJcXG4gIEBpbmNsdWRlIHNlY3Rpb24tYmctY29sb3JlZDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICRsMjtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgcGFkZGluZzogMnJlbSAxcmVtIDFyZW07XFxyXFxuICBnYXA6IDEuNXJlbTtcXHJcXG4gIFxcclxcbn1cXHJcXG5cXHJcXG4udXNlci1zaWRlYmFyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBnYXA6IDEuNXJlbTtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICB3aWR0aDogMzYlO1xcclxcbiAgcGFkZGluZzogMi41cmVtIDEuNXJlbSAxLjVyZW07XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBwYWRkaW5nOiAwIDFyZW0gMS41cmVtO1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4udXNlci1zZWN0aW9uIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXHJcXG4gIGdhcDogMi41cmVtO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldCkge1xcclxcbiAgICBnYXA6IDA7XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5lbnRlci1jYWJpbmV0LWxpbmsge1xcclxcbiAgY29sb3I6ICRkYXJrLWNvbG9yO1xcclxcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXHJcXG59XFxyXFxuXFxyXFxuLmV4aXQtY2FiaW5ldC1idG4ge1xcclxcbiAgd2lkdGg6IDEwcmVtO1xcclxcbn1cIixcIi5oZXJvLXNlY3Rpb24ge1xcclxcbiAgQGluY2x1ZGUgZGlzcGxheS1mbGV4LWNlbnRlcjtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICBwYWRkaW5nOiAzcmVtO1xcclxcbiAgYmFja2dyb3VuZDogY2VudGVyIC8gY292ZXIgbm8tcmVwZWF0IHVybChcXFwiLi9hc3NldHMvbWFpbi1iZzEuanBnXFxcIik7XFxyXFxuICBib3JkZXItcmFkaXVzOiAzMHB4O1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LWxhcHRvcCkge1xcclxcbiAgICBwYWRkaW5nOiAxLjVyZW07XFxyXFxuICAgIHBhZGRpbmctdG9wOiAyLjVyZW07XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtdGFibGV0KSB7XFxyXFxuICAgIHBhZGRpbmc6IDMuNXJlbSAycmVtO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICBwYWRkaW5nOiAyLjVyZW0gMS41cmVtO1xcclxcbiAgfVxcclxcbiAgYm94LXNoYWRvdzogaW5zZXQgLTFweCAtMXB4IDNweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpLFxcclxcbiAgICBpbnNldCAxcHggMXB4IDJweCByZ2JhKDcsIDcsIDY5LCAwLjE1KTtcXHJcXG59XFxyXFxuXFxyXFxuLmhlcm8tc2VjdGlvbi1oZWFkZXIge1xcclxcbiAgd2lkdGg6IDUwJTtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDJyZW07XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbGFwdG9wKSB7XFxyXFxuICAgIHdpZHRoOiA2MCU7XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtdGFibGV0KSB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmhlcm8tc2VjdGlvbi10ZXh0IHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiA2MCU7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMS41cmVtO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmFkdmFudGFnZXMtc2VjdGlvbiB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIG1hcmdpbi10b3A6IDQuNXJlbTtcXHJcXG4gIGdhcDogMXJlbTtcXHJcXG4gIGZsZXgtd3JhcDogd3JhcDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uYWR2YW50YWdlX3dyYXBwZXIge1xcclxcbiAgQGluY2x1ZGUgY2FyZC1zdHlsZTtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIHBhZGRpbmc6IDFyZW07XFxyXFxuICB3aWR0aDogMjMlO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LWxhcHRvcCkge1xcclxcbiAgICB3aWR0aDogNDglO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LXRhYmxldC12ZXJ0aWNhbCkge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmFkdmFudGFnZS1oZWFkZXIge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDFyZW07XFxyXFxuICBwYWRkaW5nLXRvcDogMXJlbTtcXHJcXG4gICY6OmFmdGVyIHtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXHJcXG4gICAgaGVpZ2h0OiAycHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICRkYXJrLWNvbG9yO1xcclxcbiAgICB3aWR0aDogMzAlO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIGxlZnQ6IDM0LjUlO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4uYWR2YW50YWdlLWltYWdlIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMzBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmFkdmFudGFnZS10ZXh0IHtcXHJcXG4gIHBhZGRpbmctdG9wOiAxcmVtO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5pbmZvLXNlY3Rpb24ge1xcclxcbiAgQGluY2x1ZGUgZGlzcGxheS1mbGV4LXNwYWNlLWJldHdlZW47XFxyXFxuICBwYWRkaW5nOiAkc2VjdGlvbi1wYWRkaW5nO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5mby10ZXh0LXdyYXBwZXIge1xcclxcbiAgd2lkdGg6IDQwJTtcXHJcXG4gIHBhZGRpbmc6IDAgNC41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5mby1oZWFkZXIge1xcclxcbiAgZm9udC1zaXplOiAxLjVyZW07XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMnJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmluZm8tdGV4dCB7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDAuN3JlbTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5mby10ZXh0LWljb24ge1xcclxcbiAgcGFkZGluZy1yaWdodDogMC41cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5mby1pbWFnZSB7XFxyXFxuICBAaW5jbHVkZSBzZWN0aW9uLWJnLWNvbG9yZWQ7XFxyXFxuICBiYWNrZ3JvdW5kOiBjZW50ZXIgLyBjb3ZlciBuby1yZXBlYXQgdXJsKFxcXCIuL2Fzc2V0cy9pbmZvLXNlY3Rpb24yLmpwZ1xcXCIpO1xcclxcbiAgd2lkdGg6IDUwJTtcXHJcXG4gIGhlaWdodDogMjVyZW07XFxyXFxufVxcclxcblxcclxcbi50ZWFtLXNlY3Rpb24ge1xcclxcbiAgLy8gQGluY2x1ZGUgc2VjdGlvbi1iZy1jb2xvcmVkO1xcclxcbiAgcGFkZGluZzogJHNlY3Rpb24tcGFkZGluZztcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDIuNXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLnRlYW0tc2VjdGlvbi1oZWFkZXIge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4udGVhbS1tZW1iZXJzIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBnYXA6IDEuNXJlbTtcXHJcXG4gIHBhZGRpbmctdG9wOiAyLjVyZW07XFxyXFxuICBmbGV4LXdyYXA6IHdyYXA7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1sYXB0b3ApIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi50ZWFtLW1lbWJlciB7XFxyXFxuICBAaW5jbHVkZSBjYXJkLXN0eWxlO1xcclxcbiAgcGFkZGluZzogMXJlbTtcXHJcXG4gIHdpZHRoOiAzMCU7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtdGFibGV0LXZlcnRpY2FsKSB7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4udGVhbS1tZW1iZXItbmFtZSB7XFxyXFxuICBmb250LXNpemU6IDEuNnJlbTtcXHJcXG4gIHBhZGRpbmc6IDFyZW0gMCAwO1xcclxcbn1cXHJcXG5cXHJcXG4udGVhbS1tZW1iZXItaW1nIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMzBweDtcXHJcXG59XFxyXFxuXFxyXFxuLm1lbWJlci1kdXR5IHtcXHJcXG4gIGZvbnQtc2l6ZTogMC45cmVtO1xcclxcbiAgbGluZS1oZWlnaHQ6IDI7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXHJcXG4gIGNvbG9yOiAkbWlkLWdyZXk7XFxyXFxufVxcclxcblxcclxcbi5tZW1iZXItYWN0aW9ucyB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXHJcXG4gIGZsZXgtZ3JvdzogMTtcXHJcXG4gICYgdWwge1xcclxcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gIH1cXHJcXG4gICYgbGkge1xcclxcbiAgICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgICBwYWRkaW5nLWJvdHRvbTogMC4zcmVtO1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5naXQtaWNvbiB7XFxyXFxuICB3aWR0aDogNTBweDtcXHJcXG4gIGhlaWdodDogNTBweDtcXHJcXG4gIG1hcmdpbi10b3A6IGF1dG87XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0Nzdmcgd2lkdGg9JzUwcHgnIGhlaWdodD0nNTBweCcgdmlld0JveD0nMCAwIDEwMjQgMTAyNCcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBjbGFzcz0naWNvbi1naXQnJTNFJTNDcGF0aCBkPSdNNTExLjYgNzYuM0MyNjQuMyA3Ni4yIDY0IDI3Ni40IDY0IDUyMy41IDY0IDcxOC45IDE4OS4zIDg4NSAzNjMuOCA5NDZjMjMuNSA1LjkgMTkuOS0xMC44IDE5LjktMjIuMnYtNzcuNWMtMTM1LjcgMTUuOS0xNDEuMi03My45LTE1MC4zLTg4LjlDMjE1IDcyNiAxNzEuNSA3MTggMTg0LjUgNzAzYzMwLjktMTUuOSA2Mi40IDQgOTguOSA1Ny45IDI2LjQgMzkuMSA3Ny45IDMyLjUgMTA0IDI2IDUuNy0yMy41IDE3LjktNDQuNSAzNC43LTYwLjgtMTQwLjYtMjUuMi0xOTkuMi0xMTEtMTk5LjItMjEzIDAtNDkuNSAxNi4zLTk1IDQ4LjMtMTMxLjctMjAuNC02MC41IDEuOS0xMTIuMyA0LjktMTIwIDU4LjEtNS4yIDExOC41IDQxLjYgMTIzLjIgNDUuMyAzMy04LjkgNzAuNy0xMy42IDExMi45LTEzLjYgNDIuNCAwIDgwLjIgNC45IDExMy41IDEzLjkgMTEuMy04LjYgNjcuMy00OC44IDEyMS4zLTQzLjkgMi45IDcuNyAyNC43IDU4LjMgNS41IDExOCAzMi40IDM2LjggNDguOSA4Mi43IDQ4LjkgMTMyLjMgMCAxMDIuMi01OSAxODguMS0yMDAgMjEyLjlhMTI3LjUgMTI3LjUgMCAwIDEgMzguMSA5MXYxMTIuNWMuOCA5IDAgMTcuOSAxNSAxNy45IDE3Ny4xLTU5LjcgMzA0LjYtMjI3IDMwNC42LTQyNC4xIDAtMjQ3LjItMjAwLjQtNDQ3LjMtNDQ3LjUtNDQ3LjN6JyUzRSUzQy9wYXRoJTNFJTNDL3N2ZyUzRVxcXCIpO1xcclxcbiAgZmlsdGVyOiBub25lO1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXM7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gICY6aG92ZXIge1xcclxcbiAgICBmaWx0ZXI6IGludmVydCgxKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCIsXCIuY2hhcnRzIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxyXFxuICBmbGV4LXdyYXA6IHdyYXA7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHBhZGRpbmc6IDIwcHg7XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbGFwdG9wKSB7XFxyXFxuICAgIGdhcDogMS41cmVtO1xcclxcbiAgfVxcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmNoYXJ0IHtcXHJcXG4gIHdpZHRoOiAzNSU7XFxyXFxuICBoZWlnaHQ6IDMwMHB4O1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiBtYXgtY29udGVudDtcXHJcXG4gIH1cXHJcXG59XCIsXCIudG9kYXlzdGF0LXdyYXBwZXIge1xcclxcbiAgQGluY2x1ZGUgY2FyZC1zdHlsZTtcXHJcXG4gIHBhZGRpbmc6IDEuNnJlbTtcXHJcXG4gIGZvbnQtZmFtaWx5OiAkaGVhZGVycy1mb250O1xcclxcbiAgd2lkdGg6IDYyJTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXHJcXG4gIC53b3JkLXdyYXBwZXIge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gIH1cXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1tb2JpbGUpIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIHBhZGRpbmc6IDAuNXJlbTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuIFxcclxcbi53cmFwcGVyX2RhaWx5LXN0YXQge1xcclxcbiAgQGluY2x1ZGUgZGlzcGxheS1mbGV4LWNlbnRlcjtcXHJcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGZvbnQtc2l6ZTogMS4zcmVtO1xcclxcbiAgY29sb3I6ICRkYXJrLWNvbG9yO1xcclxcbiAgZm9udC1mYW1pbHk6ICRoZWFkZXJzLWZvbnQ7XFxyXFxuICBnYXA6IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5kYXlzdGF0LXdyYXBwZXIge1xcclxcbiAgQGluY2x1ZGUgY2FyZC1zdHlsZTtcXHJcXG4gIGZvbnQtZmFtaWx5OiAkaGVhZGVycy1mb250O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDEuNXJlbTtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC10YWJsZXQpIHtcXHJcXG4gICAgZmxleC13cmFwOiB3cmFwO1xcclxcbiAgICBnYXA6IDFyZW07XFxyXFxuICAgIC53b3JkLXdyYXBwZXIge1xcclxcbiAgICAgIHdpZHRoOiA0OCU7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1tb2JpbGUpIHtcXHJcXG4gICAgZmxleC13cmFwOiBub3dyYXA7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIGdhcDogMXJlbTtcXHJcXG4gICAgLndvcmQtd3JhcHBlciB7XFxyXFxuICAgICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59IFxcclxcblxcclxcblxcclxcbi5kYXRhLXdyYXBwZXItcm93MSwgLmRhdGEtd3JhcHBlci1yb3cyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBwYWRkaW5nOiAxcmVtO1xcclxcbiAgZ2FwOiAxcmVtO1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIHdpZHRoOiA1MCU7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIHBhZGRpbmc6IDVweDtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLmRhdGEtd3JhcHBlci1yb3cxIHtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5zdGF0LWRhdGEtaXRlbSB7XFxyXFxuICBAaW5jbHVkZSBkaXNwbGF5LWZsZXgtc3BhY2UtYmV0d2VlbjtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxyXFxufVxcclxcblxcclxcbi5kYXRlLXJvdyB7XFxyXFxuICBwYWRkaW5nLXJpZ2h0OiA2LjVyZW07XFxyXFxuICBwYWRkaW5nLXRvcDogMS42cmVtO1xcclxcbiAgcGFkZGluZy1sZWZ0OiAycmVtO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgQG1lZGlhIChtYXgtd2lkdGg6ICRicmVha3BvaW50LW1vYmlsZSkge1xcclxcbiAgICBwYWRkaW5nLXJpZ2h0OiAyLjhyZW07XFxyXFxuICB9XFxyXFxuICBAbWVkaWEgKG1heC13aWR0aDogJGJyZWFrcG9pbnQtbW9iaWxlKSB7XFxyXFxuICAgIHBhZGRpbmctdG9wOiAyLjhyZW07XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi5maXJzdC1kYXktdGV4dCB7XFxyXFxuICBsaW5lLWhlaWdodDogMS4yO1xcclxcbn1cXHJcXG5cXHJcXG4uZmlyc3QtZGF5LWRhdGUge1xcclxcbiAgZm9udC1zaXplOiAxLjZyZW07XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuNjtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1tb2JpbGUpIHtcXHJcXG4gICAgZm9udC1zaXplOiAxcmVtO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4ud29yZC10ZXh0IHtcXHJcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxyXFxufVxcclxcblxcclxcbi5zdGF0LWRhdGEtcGFyYW0ge1xcclxcbiAgcGFkZGluZy1yaWdodDogMXJlbTtcXHJcXG4gIGZvbnQtZmFtaWx5OiAkdGV4dC1mb250O1xcclxcbiAgZm9udC1zaXplOiAwLjlyZW07XFxyXFxufVxcclxcblxcclxcbi5zdGF0LWRhdGEtdmFsdWUge1xcclxcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXHJcXG4gIGZvbnQtc2l6ZTogMC45cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uZGF0ZS10ZXh0IHtcXHJcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC10YWJsZXQpIHtcXHJcXG4gICAgd2lkdGg6IDQ4JTtcXHJcXG4gIH1cXHJcXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAkYnJlYWtwb2ludC1tb2JpbGUpIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICB9XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6525\n')},3645:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += "}";\n      }\n\n      if (item[2]) {\n        content += "}";\n      }\n\n      if (item[4]) {\n        content += "}";\n      }\n\n      return content;\n    }).join("");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0ZBQXNGLHFCQUFxQjtBQUMzRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3645\n')},1667:module=>{"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (!url) {\n    return url;\n  }\n\n  url = String(url.__esModule ? url.default : url); // If url is already wrapped in quotes, remove them\n\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/["\'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, "\\\\n"), "\\"");\n  }\n\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY2Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcz8xZGU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdXJsID0gU3RyaW5nKHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmwpOyAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgIHVybCArPSBvcHRpb25zLmhhc2g7XG4gIH0gLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXG5cbiAgaWYgKC9bXCInKCkgXFx0XFxuXXwoJTIwKS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSwgXCJcXFwiXCIpO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1667\n')},7537:module=>{"use strict";eval('\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === "function") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n    var sourceMapping = "/*# ".concat(data, " */");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join("\\n");\n  }\n\n  return [content].join("\\n");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUzNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7537\n')},8123:function(module){eval('!function(t,n){ true?module.exports=n():0}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";var t={407:function(t,n,e){e.d(n,{default:function(){return N}});var o=/([:*])(\\w+)/g,r=/\\*/g,i=/\\/\\?/g;function a(t){return void 0===t&&(t="/"),v()?location.pathname+location.search+location.hash:t}function s(t){return t.replace(/\\/+$/,"").replace(/^\\/+/,"")}function c(t){return"string"==typeof t}function u(t){return t&&t.indexOf("#")>=0&&t.split("#").pop()||""}function h(t){var n=s(t).split(/\\?(.*)?$/);return[s(n[0]),n.slice(1).join("")]}function f(t){for(var n={},e=t.split("&"),o=0;o<e.length;o++){var r=e[o].split("=");if(""!==r[0]){var i=decodeURIComponent(r[0]);n[i]?(Array.isArray(n[i])||(n[i]=[n[i]]),n[i].push(decodeURIComponent(r[1]||""))):n[i]=decodeURIComponent(r[1]||"")}}return n}function l(t,n){var e,a=h(s(t.currentLocationPath)),l=a[0],p=a[1],d=""===p?null:f(p),v=[];if(c(n.path)){if(e="(?:/^|^)"+s(n.path).replace(o,(function(t,n,e){return v.push(e),"([^/]+)"})).replace(r,"?(?:.*)").replace(i,"/?([^/]+|)")+"$",""===s(n.path)&&""===s(l))return{url:l,queryString:p,hashString:u(t.to),route:n,data:null,params:d}}else e=n.path;var g=new RegExp(e,""),m=l.match(g);if(m){var y=c(n.path)?function(t,n){return 0===n.length?null:t?t.slice(1,t.length).reduce((function(t,e,o){return null===t&&(t={}),t[n[o]]=decodeURIComponent(e),t}),null):null}(m,v):m.groups?m.groups:m.slice(1);return{url:s(l.replace(new RegExp("^"+t.instance.root),"")),queryString:p,hashString:u(t.to),route:n,data:y,params:d}}return!1}function p(){return!("undefined"==typeof window||!window.history||!window.history.pushState)}function d(t,n){return void 0===t[n]||!0===t[n]}function v(){return"undefined"!=typeof window}function g(t,n){return void 0===t&&(t=[]),void 0===n&&(n={}),t.filter((function(t){return t})).forEach((function(t){["before","after","already","leave"].forEach((function(e){t[e]&&(n[e]||(n[e]=[]),n[e].push(t[e]))}))})),n}function m(t,n,e){var o=n||{},r=0;!function n(){t[r]?Array.isArray(t[r])?(t.splice.apply(t,[r,1].concat(t[r][0](o)?t[r][1]:t[r][2])),n()):t[r](o,(function(t){void 0===t||!0===t?(r+=1,n()):e&&e(o)})):e&&e(o)}()}function y(t,n){void 0===t.currentLocationPath&&(t.currentLocationPath=t.to=a(t.instance.root)),t.currentLocationPath=t.instance._checkForAHash(t.currentLocationPath),n()}function _(t,n){for(var e=0;e<t.instance.routes.length;e++){var o=l(t,t.instance.routes[e]);if(o&&(t.matches||(t.matches=[]),t.matches.push(o),"ONE"===t.resolveOptions.strategy))return void n()}n()}function k(t,n){t.navigateOptions&&(void 0!==t.navigateOptions.shouldResolve&&console.warn(\'"shouldResolve" is deprecated. Please check the documentation.\'),void 0!==t.navigateOptions.silent&&console.warn(\'"silent" is deprecated. Please check the documentation.\')),n()}function O(t,n){!0===t.navigateOptions.force?(t.instance._setCurrent([t.instance._pathToMatchObject(t.to)]),n(!1)):n()}m.if=function(t,n,e){return Array.isArray(n)||(n=[n]),Array.isArray(e)||(e=[e]),[t,n,e]};var w=v(),L=p();function b(t,n){if(d(t.navigateOptions,"updateBrowserURL")){var e=("/"+t.to).replace(/\\/\\//g,"/"),o=w&&t.resolveOptions&&!0===t.resolveOptions.hash;L?(history[t.navigateOptions.historyAPIMethod||"pushState"](t.navigateOptions.stateObj||{},t.navigateOptions.title||"",o?"#"+e:e),location&&location.hash&&(t.instance.__freezeListening=!0,setTimeout((function(){if(!o){var n=location.hash;location.hash="",location.hash=n}t.instance.__freezeListening=!1}),1))):w&&(window.location.href=t.to)}n()}function A(t,n){var e=t.instance;e.lastResolved()?m(e.lastResolved().map((function(n){return function(e,o){if(n.route.hooks&&n.route.hooks.leave){var r=!1,i=t.instance.matchLocation(n.route.path,t.currentLocationPath,!1);r="*"!==n.route.path?!i:!(t.matches&&t.matches.find((function(t){return n.route.path===t.route.path}))),d(t.navigateOptions,"callHooks")&&r?m(n.route.hooks.leave.map((function(n){return function(e,o){return n((function(n){!1===n?t.instance.__markAsClean(t):o()}),t.matches&&t.matches.length>0?1===t.matches.length?t.matches[0]:t.matches:void 0)}})).concat([function(){return o()}])):o()}else o()}})),{},(function(){return n()})):n()}function P(t,n){d(t.navigateOptions,"updateState")&&t.instance._setCurrent(t.matches),n()}var R=[function(t,n){var e=t.instance.lastResolved();if(e&&e[0]&&e[0].route===t.match.route&&e[0].url===t.match.url&&e[0].queryString===t.match.queryString)return e.forEach((function(n){n.route.hooks&&n.route.hooks.already&&d(t.navigateOptions,"callHooks")&&n.route.hooks.already.forEach((function(n){return n(t.match)}))})),void n(!1);n()},function(t,n){t.match.route.hooks&&t.match.route.hooks.before&&d(t.navigateOptions,"callHooks")?m(t.match.route.hooks.before.map((function(n){return function(e,o){return n((function(n){!1===n?t.instance.__markAsClean(t):o()}),t.match)}})).concat([function(){return n()}])):n()},function(t,n){d(t.navigateOptions,"callHandler")&&t.match.route.handler(t.match),t.instance.updatePageLinks(),n()},function(t,n){t.match.route.hooks&&t.match.route.hooks.after&&d(t.navigateOptions,"callHooks")&&t.match.route.hooks.after.forEach((function(n){return n(t.match)})),n()}],S=[A,function(t,n){var e=t.instance._notFoundRoute;if(e){t.notFoundHandled=!0;var o=h(t.currentLocationPath),r=o[0],i=o[1],a=u(t.to);e.path=s(r);var c={url:e.path,queryString:i,hashString:a,data:null,route:e,params:""!==i?f(i):null};t.matches=[c],t.match=c}n()},m.if((function(t){return t.notFoundHandled}),R.concat([P]),[function(t,n){t.resolveOptions&&!1!==t.resolveOptions.noMatchWarning&&void 0!==t.resolveOptions.noMatchWarning||console.warn(\'Navigo: "\'+t.currentLocationPath+"\\" didn\'t match any of the registered routes."),n()},function(t,n){t.instance._setCurrent(null),n()}])];function E(){return(E=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o])}return t}).apply(this,arguments)}function x(t,n){var e=0;A(t,(function o(){e!==t.matches.length?m(R,E({},t,{match:t.matches[e]}),(function(){e+=1,o()})):P(t,n)}))}function H(t){t.instance.__markAsClean(t)}function j(){return(j=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o])}return t}).apply(this,arguments)}var C="[data-navigo]";function N(t,n){var e,o=n||{strategy:"ONE",hash:!1,noMatchWarning:!1,linksSelector:C},r=this,i="/",d=null,w=[],L=!1,A=p(),P=v();function R(t){return t.indexOf("#")>=0&&(t=!0===o.hash?t.split("#")[1]||"/":t.split("#")[0]),t}function E(t){return s(i+"/"+s(t))}function N(t,n,e,o){return t=c(t)?E(t):t,{name:o||s(String(t)),path:t,handler:n,hooks:g(e)}}function U(t,n){if(!r.__dirty){r.__dirty=!0,t=t?s(i)+"/"+s(t):void 0;var e={instance:r,to:t,currentLocationPath:t,navigateOptions:{},resolveOptions:j({},o,n)};return m([y,_,m.if((function(t){var n=t.matches;return n&&n.length>0}),x,S)],e,H),!!e.matches&&e.matches}r.__waiting.push((function(){return r.resolve(t,n)}))}function q(t,n){if(r.__dirty)r.__waiting.push((function(){return r.navigate(t,n)}));else{r.__dirty=!0,t=s(i)+"/"+s(t);var e={instance:r,to:t,navigateOptions:n||{},resolveOptions:n&&n.resolveOptions?n.resolveOptions:o,currentLocationPath:R(t)};m([k,O,_,m.if((function(t){var n=t.matches;return n&&n.length>0}),x,S),b,H],e,H)}}function F(){if(P)return(P?[].slice.call(document.querySelectorAll(o.linksSelector||C)):[]).forEach((function(t){"false"!==t.getAttribute("data-navigo")&&"_blank"!==t.getAttribute("target")?t.hasListenerAttached||(t.hasListenerAttached=!0,t.navigoHandler=function(n){if((n.ctrlKey||n.metaKey)&&"a"===n.target.tagName.toLowerCase())return!1;var e=t.getAttribute("href");if(null==e)return!1;if(e.match(/^(http|https)/)&&"undefined"!=typeof URL)try{var o=new URL(e);e=o.pathname+o.search}catch(t){}var i=function(t){if(!t)return{};var n,e=t.split(","),o={};return e.forEach((function(t){var e=t.split(":").map((function(t){return t.replace(/(^ +| +$)/g,"")}));switch(e[0]){case"historyAPIMethod":o.historyAPIMethod=e[1];break;case"resolveOptionsStrategy":n||(n={}),n.strategy=e[1];break;case"resolveOptionsHash":n||(n={}),n.hash="true"===e[1];break;case"updateBrowserURL":case"callHandler":case"updateState":case"force":o[e[0]]="true"===e[1]}})),n&&(o.resolveOptions=n),o}(t.getAttribute("data-navigo-options"));L||(n.preventDefault(),n.stopPropagation(),r.navigate(s(e),i))},t.addEventListener("click",t.navigoHandler)):t.hasListenerAttached&&t.removeEventListener("click",t.navigoHandler)})),r}function I(t,n,e){var o=w.find((function(n){return n.name===t})),r=null;if(o){if(r=o.path,n)for(var a in n)r=r.replace(":"+a,n[a]);r=r.match(/^\\//)?r:"/"+r}return r&&e&&!e.includeRoot&&(r=r.replace(new RegExp("^/"+i),"")),r}function M(t){var n=h(s(t)),o=n[0],r=n[1],i=""===r?null:f(r);return{url:o,queryString:r,hashString:u(t),route:N(o,(function(){}),[e],o),data:null,params:i}}function T(t,n,e){return"string"==typeof n&&(n=z(n)),n?(n.hooks[t]||(n.hooks[t]=[]),n.hooks[t].push(e),function(){n.hooks[t]=n.hooks[t].filter((function(t){return t!==e}))}):(console.warn("Route doesn\'t exists: "+n),function(){})}function z(t){return"string"==typeof t?w.find((function(n){return n.name===E(t)})):w.find((function(n){return n.handler===t}))}t?i=s(t):console.warn(\'Navigo requires a root path in its constructor. If not provided will use "/" as default.\'),this.root=i,this.routes=w,this.destroyed=L,this.current=d,this.__freezeListening=!1,this.__waiting=[],this.__dirty=!1,this.__markAsClean=function(t){t.instance.__dirty=!1,t.instance.__waiting.length>0&&t.instance.__waiting.shift()()},this.on=function(t,n,o){var r=this;return"object"!=typeof t||t instanceof RegExp?("function"==typeof t&&(o=n,n=t,t=i),w.push(N(t,n,[e,o])),this):(Object.keys(t).forEach((function(n){if("function"==typeof t[n])r.on(n,t[n]);else{var o=t[n],i=o.uses,a=o.as,s=o.hooks;w.push(N(n,i,[e,s],a))}})),this)},this.off=function(t){return this.routes=w=w.filter((function(n){return c(t)?s(n.path)!==s(t):"function"==typeof t?t!==n.handler:String(n.path)!==String(t)})),this},this.resolve=U,this.navigate=q,this.navigateByName=function(t,n,e){var o=I(t,n);return null!==o&&(q(o.replace(new RegExp("^/?"+i),""),e),!0)},this.destroy=function(){this.routes=w=[],A&&window.removeEventListener("popstate",this.__popstateListener),this.destroyed=L=!0},this.notFound=function(t,n){return r._notFoundRoute=N("*",t,[e,n],"__NOT_FOUND__"),this},this.updatePageLinks=F,this.link=function(t){return"/"+i+"/"+s(t)},this.hooks=function(t){return e=t,this},this.extractGETParameters=function(t){return h(R(t))},this.lastResolved=function(){return d},this.generate=I,this.getLinkPath=function(t){return t.getAttribute("href")},this.match=function(t){var n={instance:r,currentLocationPath:t,to:t,navigateOptions:{},resolveOptions:o};return _(n,(function(){})),!!n.matches&&n.matches},this.matchLocation=function(t,n,e){void 0===n||void 0!==e&&!e||(n=E(n));var o={instance:r,to:n,currentLocationPath:n};return y(o,(function(){})),"string"==typeof t&&(t=void 0===e||e?E(t):t),l(o,{name:String(t),path:t,handler:function(){},hooks:{}})||!1},this.getCurrentLocation=function(){return M(s(a(i)).replace(new RegExp("^"+i),""))},this.addBeforeHook=T.bind(this,"before"),this.addAfterHook=T.bind(this,"after"),this.addAlreadyHook=T.bind(this,"already"),this.addLeaveHook=T.bind(this,"leave"),this.getRoute=z,this._pathToMatchObject=M,this._clean=s,this._checkForAHash=R,this._setCurrent=function(t){return d=r.current=t},function(){A&&(this.__popstateListener=function(){r.__freezeListening||U()},window.addEventListener("popstate",this.__popstateListener))}.call(this),F.call(this)}}},n={};function e(o){if(n[o])return n[o].exports;var r=n[o]={exports:{}};return t[o](r,r.exports,e),r.exports}return e.d=function(t,n){for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e(407)}().default}));\n//# sourceMappingURL=navigo.min.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTywyREFBMkQsNkJBQTZCLGtCQUFrQixnR0FBZ0csMENBQTBDLGFBQWEsR0FBRyx3REFBd0QsRUFBRSxjQUFjLDZDQUE2QyxxQkFBcUIsdUJBQXVCLHFCQUFxQixHQUFHLHVRQUF1USxvRkFBb0YseUJBQXlCLFdBQVcsbUpBQW1KLHdDQUF3QyxLQUFLLHFDQUFxQyx3QkFBd0IsU0FBUyxzQkFBc0IsMkNBQTJDLDJGQUEyRixRQUFRLG9FQUFvRSxhQUFhLDZEQUE2RCx5QkFBeUIsdUdBQXVHLDZCQUE2Qiw0REFBNEQsOENBQThDLHFCQUFxQix3QkFBd0IsZ0JBQWdCLHVDQUF1QyxlQUFlLDhCQUE4QixTQUFTLDhDQUE4Qyw4QkFBOEIsd0JBQXdCLE9BQU8sd0RBQXdELG1CQUFtQix3QkFBd0IsMEJBQTBCLG9DQUFvQyxxQ0FBcUMsT0FBTyx1Q0FBdUMsd0JBQXdCLHFEQUFxRCwwQ0FBMEMsVUFBVSxNQUFNLG9DQUFvQyxnREFBZ0QsOFFBQThRLHFCQUFxQixZQUFZLHVDQUF1Qyx5QkFBeUIsOERBQThELDJCQUEyQixNQUFNLGNBQWMsNEJBQTRCLFlBQVksWUFBWSxxQ0FBcUMseUJBQXlCLCtEQUErRCx1QkFBdUIsRUFBRSxtQkFBbUIsaURBQWlELFFBQVEsV0FBVztBQUNqM1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vbm9kZV9tb2R1bGVzL25hdmlnby9saWIvbmF2aWdvLm1pbi5qcz8wYmEyIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0LG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4oKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiTmF2aWdvXCIsW10sbik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5OYXZpZ289bigpOnQuTmF2aWdvPW4oKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB0PXs0MDc6ZnVuY3Rpb24odCxuLGUpe2UuZChuLHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIE59fSk7dmFyIG89LyhbOipdKShcXHcrKS9nLHI9L1xcKi9nLGk9L1xcL1xcPy9nO2Z1bmN0aW9uIGEodCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PVwiL1wiKSx2KCk/bG9jYXRpb24ucGF0aG5hbWUrbG9jYXRpb24uc2VhcmNoK2xvY2F0aW9uLmhhc2g6dH1mdW5jdGlvbiBzKHQpe3JldHVybiB0LnJlcGxhY2UoL1xcLyskLyxcIlwiKS5yZXBsYWNlKC9eXFwvKy8sXCJcIil9ZnVuY3Rpb24gYyh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdH1mdW5jdGlvbiB1KHQpe3JldHVybiB0JiZ0LmluZGV4T2YoXCIjXCIpPj0wJiZ0LnNwbGl0KFwiI1wiKS5wb3AoKXx8XCJcIn1mdW5jdGlvbiBoKHQpe3ZhciBuPXModCkuc3BsaXQoL1xcPyguKik/JC8pO3JldHVybltzKG5bMF0pLG4uc2xpY2UoMSkuam9pbihcIlwiKV19ZnVuY3Rpb24gZih0KXtmb3IodmFyIG49e30sZT10LnNwbGl0KFwiJlwiKSxvPTA7bzxlLmxlbmd0aDtvKyspe3ZhciByPWVbb10uc3BsaXQoXCI9XCIpO2lmKFwiXCIhPT1yWzBdKXt2YXIgaT1kZWNvZGVVUklDb21wb25lbnQoclswXSk7bltpXT8oQXJyYXkuaXNBcnJheShuW2ldKXx8KG5baV09W25baV1dKSxuW2ldLnB1c2goZGVjb2RlVVJJQ29tcG9uZW50KHJbMV18fFwiXCIpKSk6bltpXT1kZWNvZGVVUklDb21wb25lbnQoclsxXXx8XCJcIil9fXJldHVybiBufWZ1bmN0aW9uIGwodCxuKXt2YXIgZSxhPWgocyh0LmN1cnJlbnRMb2NhdGlvblBhdGgpKSxsPWFbMF0scD1hWzFdLGQ9XCJcIj09PXA/bnVsbDpmKHApLHY9W107aWYoYyhuLnBhdGgpKXtpZihlPVwiKD86L158XilcIitzKG4ucGF0aCkucmVwbGFjZShvLChmdW5jdGlvbih0LG4sZSl7cmV0dXJuIHYucHVzaChlKSxcIihbXi9dKylcIn0pKS5yZXBsYWNlKHIsXCI/KD86LiopXCIpLnJlcGxhY2UoaSxcIi8/KFteL10rfClcIikrXCIkXCIsXCJcIj09PXMobi5wYXRoKSYmXCJcIj09PXMobCkpcmV0dXJue3VybDpsLHF1ZXJ5U3RyaW5nOnAsaGFzaFN0cmluZzp1KHQudG8pLHJvdXRlOm4sZGF0YTpudWxsLHBhcmFtczpkfX1lbHNlIGU9bi5wYXRoO3ZhciBnPW5ldyBSZWdFeHAoZSxcIlwiKSxtPWwubWF0Y2goZyk7aWYobSl7dmFyIHk9YyhuLnBhdGgpP2Z1bmN0aW9uKHQsbil7cmV0dXJuIDA9PT1uLmxlbmd0aD9udWxsOnQ/dC5zbGljZSgxLHQubGVuZ3RoKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSxvKXtyZXR1cm4gbnVsbD09PXQmJih0PXt9KSx0W25bb11dPWRlY29kZVVSSUNvbXBvbmVudChlKSx0fSksbnVsbCk6bnVsbH0obSx2KTptLmdyb3Vwcz9tLmdyb3VwczptLnNsaWNlKDEpO3JldHVybnt1cmw6cyhsLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIit0Lmluc3RhbmNlLnJvb3QpLFwiXCIpKSxxdWVyeVN0cmluZzpwLGhhc2hTdHJpbmc6dSh0LnRvKSxyb3V0ZTpuLGRhdGE6eSxwYXJhbXM6ZH19cmV0dXJuITF9ZnVuY3Rpb24gcCgpe3JldHVybiEoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvd3x8IXdpbmRvdy5oaXN0b3J5fHwhd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKX1mdW5jdGlvbiBkKHQsbil7cmV0dXJuIHZvaWQgMD09PXRbbl18fCEwPT09dFtuXX1mdW5jdGlvbiB2KCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvd31mdW5jdGlvbiBnKHQsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PVtdKSx2b2lkIDA9PT1uJiYobj17fSksdC5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe1tcImJlZm9yZVwiLFwiYWZ0ZXJcIixcImFscmVhZHlcIixcImxlYXZlXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RbZV0mJihuW2VdfHwobltlXT1bXSksbltlXS5wdXNoKHRbZV0pKX0pKX0pKSxufWZ1bmN0aW9uIG0odCxuLGUpe3ZhciBvPW58fHt9LHI9MDshZnVuY3Rpb24gbigpe3Rbcl0/QXJyYXkuaXNBcnJheSh0W3JdKT8odC5zcGxpY2UuYXBwbHkodCxbciwxXS5jb25jYXQodFtyXVswXShvKT90W3JdWzFdOnRbcl1bMl0pKSxuKCkpOnRbcl0obywoZnVuY3Rpb24odCl7dm9pZCAwPT09dHx8ITA9PT10PyhyKz0xLG4oKSk6ZSYmZShvKX0pKTplJiZlKG8pfSgpfWZ1bmN0aW9uIHkodCxuKXt2b2lkIDA9PT10LmN1cnJlbnRMb2NhdGlvblBhdGgmJih0LmN1cnJlbnRMb2NhdGlvblBhdGg9dC50bz1hKHQuaW5zdGFuY2Uucm9vdCkpLHQuY3VycmVudExvY2F0aW9uUGF0aD10Lmluc3RhbmNlLl9jaGVja0ZvckFIYXNoKHQuY3VycmVudExvY2F0aW9uUGF0aCksbigpfWZ1bmN0aW9uIF8odCxuKXtmb3IodmFyIGU9MDtlPHQuaW5zdGFuY2Uucm91dGVzLmxlbmd0aDtlKyspe3ZhciBvPWwodCx0Lmluc3RhbmNlLnJvdXRlc1tlXSk7aWYobyYmKHQubWF0Y2hlc3x8KHQubWF0Y2hlcz1bXSksdC5tYXRjaGVzLnB1c2gobyksXCJPTkVcIj09PXQucmVzb2x2ZU9wdGlvbnMuc3RyYXRlZ3kpKXJldHVybiB2b2lkIG4oKX1uKCl9ZnVuY3Rpb24gayh0LG4pe3QubmF2aWdhdGVPcHRpb25zJiYodm9pZCAwIT09dC5uYXZpZ2F0ZU9wdGlvbnMuc2hvdWxkUmVzb2x2ZSYmY29uc29sZS53YXJuKCdcInNob3VsZFJlc29sdmVcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3VtZW50YXRpb24uJyksdm9pZCAwIT09dC5uYXZpZ2F0ZU9wdGlvbnMuc2lsZW50JiZjb25zb2xlLndhcm4oJ1wic2lsZW50XCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGNoZWNrIHRoZSBkb2N1bWVudGF0aW9uLicpKSxuKCl9ZnVuY3Rpb24gTyh0LG4peyEwPT09dC5uYXZpZ2F0ZU9wdGlvbnMuZm9yY2U/KHQuaW5zdGFuY2UuX3NldEN1cnJlbnQoW3QuaW5zdGFuY2UuX3BhdGhUb01hdGNoT2JqZWN0KHQudG8pXSksbighMSkpOm4oKX1tLmlmPWZ1bmN0aW9uKHQsbixlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShuKXx8KG49W25dKSxBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLFt0LG4sZV19O3ZhciB3PXYoKSxMPXAoKTtmdW5jdGlvbiBiKHQsbil7aWYoZCh0Lm5hdmlnYXRlT3B0aW9ucyxcInVwZGF0ZUJyb3dzZXJVUkxcIikpe3ZhciBlPShcIi9cIit0LnRvKS5yZXBsYWNlKC9cXC9cXC8vZyxcIi9cIiksbz13JiZ0LnJlc29sdmVPcHRpb25zJiYhMD09PXQucmVzb2x2ZU9wdGlvbnMuaGFzaDtMPyhoaXN0b3J5W3QubmF2aWdhdGVPcHRpb25zLmhpc3RvcnlBUElNZXRob2R8fFwicHVzaFN0YXRlXCJdKHQubmF2aWdhdGVPcHRpb25zLnN0YXRlT2JqfHx7fSx0Lm5hdmlnYXRlT3B0aW9ucy50aXRsZXx8XCJcIixvP1wiI1wiK2U6ZSksbG9jYXRpb24mJmxvY2F0aW9uLmhhc2gmJih0Lmluc3RhbmNlLl9fZnJlZXplTGlzdGVuaW5nPSEwLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoIW8pe3ZhciBuPWxvY2F0aW9uLmhhc2g7bG9jYXRpb24uaGFzaD1cIlwiLGxvY2F0aW9uLmhhc2g9bn10Lmluc3RhbmNlLl9fZnJlZXplTGlzdGVuaW5nPSExfSksMSkpKTp3JiYod2luZG93LmxvY2F0aW9uLmhyZWY9dC50byl9bigpfWZ1bmN0aW9uIEEodCxuKXt2YXIgZT10Lmluc3RhbmNlO2UubGFzdFJlc29sdmVkKCk/bShlLmxhc3RSZXNvbHZlZCgpLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKGUsbyl7aWYobi5yb3V0ZS5ob29rcyYmbi5yb3V0ZS5ob29rcy5sZWF2ZSl7dmFyIHI9ITEsaT10Lmluc3RhbmNlLm1hdGNoTG9jYXRpb24obi5yb3V0ZS5wYXRoLHQuY3VycmVudExvY2F0aW9uUGF0aCwhMSk7cj1cIipcIiE9PW4ucm91dGUucGF0aD8haTohKHQubWF0Y2hlcyYmdC5tYXRjaGVzLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiBuLnJvdXRlLnBhdGg9PT10LnJvdXRlLnBhdGh9KSkpLGQodC5uYXZpZ2F0ZU9wdGlvbnMsXCJjYWxsSG9va3NcIikmJnI/bShuLnJvdXRlLmhvb2tzLmxlYXZlLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKGUsbyl7cmV0dXJuIG4oKGZ1bmN0aW9uKG4peyExPT09bj90Lmluc3RhbmNlLl9fbWFya0FzQ2xlYW4odCk6bygpfSksdC5tYXRjaGVzJiZ0Lm1hdGNoZXMubGVuZ3RoPjA/MT09PXQubWF0Y2hlcy5sZW5ndGg/dC5tYXRjaGVzWzBdOnQubWF0Y2hlczp2b2lkIDApfX0pKS5jb25jYXQoW2Z1bmN0aW9uKCl7cmV0dXJuIG8oKX1dKSk6bygpfWVsc2UgbygpfX0pKSx7fSwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpOm4oKX1mdW5jdGlvbiBQKHQsbil7ZCh0Lm5hdmlnYXRlT3B0aW9ucyxcInVwZGF0ZVN0YXRlXCIpJiZ0Lmluc3RhbmNlLl9zZXRDdXJyZW50KHQubWF0Y2hlcyksbigpfXZhciBSPVtmdW5jdGlvbih0LG4pe3ZhciBlPXQuaW5zdGFuY2UubGFzdFJlc29sdmVkKCk7aWYoZSYmZVswXSYmZVswXS5yb3V0ZT09PXQubWF0Y2gucm91dGUmJmVbMF0udXJsPT09dC5tYXRjaC51cmwmJmVbMF0ucXVlcnlTdHJpbmc9PT10Lm1hdGNoLnF1ZXJ5U3RyaW5nKXJldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKG4pe24ucm91dGUuaG9va3MmJm4ucm91dGUuaG9va3MuYWxyZWFkeSYmZCh0Lm5hdmlnYXRlT3B0aW9ucyxcImNhbGxIb29rc1wiKSYmbi5yb3V0ZS5ob29rcy5hbHJlYWR5LmZvckVhY2goKGZ1bmN0aW9uKG4pe3JldHVybiBuKHQubWF0Y2gpfSkpfSkpLHZvaWQgbighMSk7bigpfSxmdW5jdGlvbih0LG4pe3QubWF0Y2gucm91dGUuaG9va3MmJnQubWF0Y2gucm91dGUuaG9va3MuYmVmb3JlJiZkKHQubmF2aWdhdGVPcHRpb25zLFwiY2FsbEhvb2tzXCIpP20odC5tYXRjaC5yb3V0ZS5ob29rcy5iZWZvcmUubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gZnVuY3Rpb24oZSxvKXtyZXR1cm4gbigoZnVuY3Rpb24obil7ITE9PT1uP3QuaW5zdGFuY2UuX19tYXJrQXNDbGVhbih0KTpvKCl9KSx0Lm1hdGNoKX19KSkuY29uY2F0KFtmdW5jdGlvbigpe3JldHVybiBuKCl9XSkpOm4oKX0sZnVuY3Rpb24odCxuKXtkKHQubmF2aWdhdGVPcHRpb25zLFwiY2FsbEhhbmRsZXJcIikmJnQubWF0Y2gucm91dGUuaGFuZGxlcih0Lm1hdGNoKSx0Lmluc3RhbmNlLnVwZGF0ZVBhZ2VMaW5rcygpLG4oKX0sZnVuY3Rpb24odCxuKXt0Lm1hdGNoLnJvdXRlLmhvb2tzJiZ0Lm1hdGNoLnJvdXRlLmhvb2tzLmFmdGVyJiZkKHQubmF2aWdhdGVPcHRpb25zLFwiY2FsbEhvb2tzXCIpJiZ0Lm1hdGNoLnJvdXRlLmhvb2tzLmFmdGVyLmZvckVhY2goKGZ1bmN0aW9uKG4pe3JldHVybiBuKHQubWF0Y2gpfSkpLG4oKX1dLFM9W0EsZnVuY3Rpb24odCxuKXt2YXIgZT10Lmluc3RhbmNlLl9ub3RGb3VuZFJvdXRlO2lmKGUpe3Qubm90Rm91bmRIYW5kbGVkPSEwO3ZhciBvPWgodC5jdXJyZW50TG9jYXRpb25QYXRoKSxyPW9bMF0saT1vWzFdLGE9dSh0LnRvKTtlLnBhdGg9cyhyKTt2YXIgYz17dXJsOmUucGF0aCxxdWVyeVN0cmluZzppLGhhc2hTdHJpbmc6YSxkYXRhOm51bGwscm91dGU6ZSxwYXJhbXM6XCJcIiE9PWk/ZihpKTpudWxsfTt0Lm1hdGNoZXM9W2NdLHQubWF0Y2g9Y31uKCl9LG0uaWYoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5vdEZvdW5kSGFuZGxlZH0pLFIuY29uY2F0KFtQXSksW2Z1bmN0aW9uKHQsbil7dC5yZXNvbHZlT3B0aW9ucyYmITEhPT10LnJlc29sdmVPcHRpb25zLm5vTWF0Y2hXYXJuaW5nJiZ2b2lkIDAhPT10LnJlc29sdmVPcHRpb25zLm5vTWF0Y2hXYXJuaW5nfHxjb25zb2xlLndhcm4oJ05hdmlnbzogXCInK3QuY3VycmVudExvY2F0aW9uUGF0aCtcIlxcXCIgZGlkbid0IG1hdGNoIGFueSBvZiB0aGUgcmVnaXN0ZXJlZCByb3V0ZXMuXCIpLG4oKX0sZnVuY3Rpb24odCxuKXt0Lmluc3RhbmNlLl9zZXRDdXJyZW50KG51bGwpLG4oKX1dKV07ZnVuY3Rpb24gRSgpe3JldHVybihFPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3ZhciBlPWFyZ3VtZW50c1tuXTtmb3IodmFyIG8gaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSYmKHRbb109ZVtvXSl9cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24geCh0LG4pe3ZhciBlPTA7QSh0LChmdW5jdGlvbiBvKCl7ZSE9PXQubWF0Y2hlcy5sZW5ndGg/bShSLEUoe30sdCx7bWF0Y2g6dC5tYXRjaGVzW2VdfSksKGZ1bmN0aW9uKCl7ZSs9MSxvKCl9KSk6UCh0LG4pfSkpfWZ1bmN0aW9uIEgodCl7dC5pbnN0YW5jZS5fX21hcmtBc0NsZWFuKHQpfWZ1bmN0aW9uIGooKXtyZXR1cm4oaj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXt2YXIgZT1hcmd1bWVudHNbbl07Zm9yKHZhciBvIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbykmJih0W29dPWVbb10pfXJldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBDPVwiW2RhdGEtbmF2aWdvXVwiO2Z1bmN0aW9uIE4odCxuKXt2YXIgZSxvPW58fHtzdHJhdGVneTpcIk9ORVwiLGhhc2g6ITEsbm9NYXRjaFdhcm5pbmc6ITEsbGlua3NTZWxlY3RvcjpDfSxyPXRoaXMsaT1cIi9cIixkPW51bGwsdz1bXSxMPSExLEE9cCgpLFA9digpO2Z1bmN0aW9uIFIodCl7cmV0dXJuIHQuaW5kZXhPZihcIiNcIik+PTAmJih0PSEwPT09by5oYXNoP3Quc3BsaXQoXCIjXCIpWzFdfHxcIi9cIjp0LnNwbGl0KFwiI1wiKVswXSksdH1mdW5jdGlvbiBFKHQpe3JldHVybiBzKGkrXCIvXCIrcyh0KSl9ZnVuY3Rpb24gTih0LG4sZSxvKXtyZXR1cm4gdD1jKHQpP0UodCk6dCx7bmFtZTpvfHxzKFN0cmluZyh0KSkscGF0aDp0LGhhbmRsZXI6bixob29rczpnKGUpfX1mdW5jdGlvbiBVKHQsbil7aWYoIXIuX19kaXJ0eSl7ci5fX2RpcnR5PSEwLHQ9dD9zKGkpK1wiL1wiK3ModCk6dm9pZCAwO3ZhciBlPXtpbnN0YW5jZTpyLHRvOnQsY3VycmVudExvY2F0aW9uUGF0aDp0LG5hdmlnYXRlT3B0aW9uczp7fSxyZXNvbHZlT3B0aW9uczpqKHt9LG8sbil9O3JldHVybiBtKFt5LF8sbS5pZigoZnVuY3Rpb24odCl7dmFyIG49dC5tYXRjaGVzO3JldHVybiBuJiZuLmxlbmd0aD4wfSkseCxTKV0sZSxIKSwhIWUubWF0Y2hlcyYmZS5tYXRjaGVzfXIuX193YWl0aW5nLnB1c2goKGZ1bmN0aW9uKCl7cmV0dXJuIHIucmVzb2x2ZSh0LG4pfSkpfWZ1bmN0aW9uIHEodCxuKXtpZihyLl9fZGlydHkpci5fX3dhaXRpbmcucHVzaCgoZnVuY3Rpb24oKXtyZXR1cm4gci5uYXZpZ2F0ZSh0LG4pfSkpO2Vsc2V7ci5fX2RpcnR5PSEwLHQ9cyhpKStcIi9cIitzKHQpO3ZhciBlPXtpbnN0YW5jZTpyLHRvOnQsbmF2aWdhdGVPcHRpb25zOm58fHt9LHJlc29sdmVPcHRpb25zOm4mJm4ucmVzb2x2ZU9wdGlvbnM/bi5yZXNvbHZlT3B0aW9uczpvLGN1cnJlbnRMb2NhdGlvblBhdGg6Uih0KX07bShbayxPLF8sbS5pZigoZnVuY3Rpb24odCl7dmFyIG49dC5tYXRjaGVzO3JldHVybiBuJiZuLmxlbmd0aD4wfSkseCxTKSxiLEhdLGUsSCl9fWZ1bmN0aW9uIEYoKXtpZihQKXJldHVybihQP1tdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChvLmxpbmtzU2VsZWN0b3J8fEMpKTpbXSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7XCJmYWxzZVwiIT09dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5hdmlnb1wiKSYmXCJfYmxhbmtcIiE9PXQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpP3QuaGFzTGlzdGVuZXJBdHRhY2hlZHx8KHQuaGFzTGlzdGVuZXJBdHRhY2hlZD0hMCx0Lm5hdmlnb0hhbmRsZXI9ZnVuY3Rpb24obil7aWYoKG4uY3RybEtleXx8bi5tZXRhS2V5KSYmXCJhXCI9PT1uLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpcmV0dXJuITE7dmFyIGU9dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO2lmKG51bGw9PWUpcmV0dXJuITE7aWYoZS5tYXRjaCgvXihodHRwfGh0dHBzKS8pJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgVVJMKXRyeXt2YXIgbz1uZXcgVVJMKGUpO2U9by5wYXRobmFtZStvLnNlYXJjaH1jYXRjaCh0KXt9dmFyIGk9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJue307dmFyIG4sZT10LnNwbGl0KFwiLFwiKSxvPXt9O3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPXQuc3BsaXQoXCI6XCIpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVwbGFjZSgvKF4gK3wgKyQpL2csXCJcIil9KSk7c3dpdGNoKGVbMF0pe2Nhc2VcImhpc3RvcnlBUElNZXRob2RcIjpvLmhpc3RvcnlBUElNZXRob2Q9ZVsxXTticmVhaztjYXNlXCJyZXNvbHZlT3B0aW9uc1N0cmF0ZWd5XCI6bnx8KG49e30pLG4uc3RyYXRlZ3k9ZVsxXTticmVhaztjYXNlXCJyZXNvbHZlT3B0aW9uc0hhc2hcIjpufHwobj17fSksbi5oYXNoPVwidHJ1ZVwiPT09ZVsxXTticmVhaztjYXNlXCJ1cGRhdGVCcm93c2VyVVJMXCI6Y2FzZVwiY2FsbEhhbmRsZXJcIjpjYXNlXCJ1cGRhdGVTdGF0ZVwiOmNhc2VcImZvcmNlXCI6b1tlWzBdXT1cInRydWVcIj09PWVbMV19fSkpLG4mJihvLnJlc29sdmVPcHRpb25zPW4pLG99KHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1uYXZpZ28tb3B0aW9uc1wiKSk7THx8KG4ucHJldmVudERlZmF1bHQoKSxuLnN0b3BQcm9wYWdhdGlvbigpLHIubmF2aWdhdGUocyhlKSxpKSl9LHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdC5uYXZpZ29IYW5kbGVyKSk6dC5oYXNMaXN0ZW5lckF0dGFjaGVkJiZ0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHQubmF2aWdvSGFuZGxlcil9KSkscn1mdW5jdGlvbiBJKHQsbixlKXt2YXIgbz13LmZpbmQoKGZ1bmN0aW9uKG4pe3JldHVybiBuLm5hbWU9PT10fSkpLHI9bnVsbDtpZihvKXtpZihyPW8ucGF0aCxuKWZvcih2YXIgYSBpbiBuKXI9ci5yZXBsYWNlKFwiOlwiK2EsblthXSk7cj1yLm1hdGNoKC9eXFwvLyk/cjpcIi9cIityfXJldHVybiByJiZlJiYhZS5pbmNsdWRlUm9vdCYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJeL1wiK2kpLFwiXCIpKSxyfWZ1bmN0aW9uIE0odCl7dmFyIG49aChzKHQpKSxvPW5bMF0scj1uWzFdLGk9XCJcIj09PXI/bnVsbDpmKHIpO3JldHVybnt1cmw6byxxdWVyeVN0cmluZzpyLGhhc2hTdHJpbmc6dSh0KSxyb3V0ZTpOKG8sKGZ1bmN0aW9uKCl7fSksW2VdLG8pLGRhdGE6bnVsbCxwYXJhbXM6aX19ZnVuY3Rpb24gVCh0LG4sZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIG4mJihuPXoobikpLG4/KG4uaG9va3NbdF18fChuLmhvb2tzW3RdPVtdKSxuLmhvb2tzW3RdLnB1c2goZSksZnVuY3Rpb24oKXtuLmhvb2tzW3RdPW4uaG9va3NbdF0uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdCE9PWV9KSl9KTooY29uc29sZS53YXJuKFwiUm91dGUgZG9lc24ndCBleGlzdHM6IFwiK24pLGZ1bmN0aW9uKCl7fSl9ZnVuY3Rpb24geih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD93LmZpbmQoKGZ1bmN0aW9uKG4pe3JldHVybiBuLm5hbWU9PT1FKHQpfSkpOncuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuIG4uaGFuZGxlcj09PXR9KSl9dD9pPXModCk6Y29uc29sZS53YXJuKCdOYXZpZ28gcmVxdWlyZXMgYSByb290IHBhdGggaW4gaXRzIGNvbnN0cnVjdG9yLiBJZiBub3QgcHJvdmlkZWQgd2lsbCB1c2UgXCIvXCIgYXMgZGVmYXVsdC4nKSx0aGlzLnJvb3Q9aSx0aGlzLnJvdXRlcz13LHRoaXMuZGVzdHJveWVkPUwsdGhpcy5jdXJyZW50PWQsdGhpcy5fX2ZyZWV6ZUxpc3RlbmluZz0hMSx0aGlzLl9fd2FpdGluZz1bXSx0aGlzLl9fZGlydHk9ITEsdGhpcy5fX21hcmtBc0NsZWFuPWZ1bmN0aW9uKHQpe3QuaW5zdGFuY2UuX19kaXJ0eT0hMSx0Lmluc3RhbmNlLl9fd2FpdGluZy5sZW5ndGg+MCYmdC5pbnN0YW5jZS5fX3dhaXRpbmcuc2hpZnQoKSgpfSx0aGlzLm9uPWZ1bmN0aW9uKHQsbixvKXt2YXIgcj10aGlzO3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgUmVnRXhwPyhcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobz1uLG49dCx0PWkpLHcucHVzaChOKHQsbixbZSxvXSkpLHRoaXMpOihPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0W25dKXIub24obix0W25dKTtlbHNle3ZhciBvPXRbbl0saT1vLnVzZXMsYT1vLmFzLHM9by5ob29rczt3LnB1c2goTihuLGksW2Usc10sYSkpfX0pKSx0aGlzKX0sdGhpcy5vZmY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucm91dGVzPXc9dy5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVybiBjKHQpP3Mobi5wYXRoKSE9PXModCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdD90IT09bi5oYW5kbGVyOlN0cmluZyhuLnBhdGgpIT09U3RyaW5nKHQpfSkpLHRoaXN9LHRoaXMucmVzb2x2ZT1VLHRoaXMubmF2aWdhdGU9cSx0aGlzLm5hdmlnYXRlQnlOYW1lPWZ1bmN0aW9uKHQsbixlKXt2YXIgbz1JKHQsbik7cmV0dXJuIG51bGwhPT1vJiYocShvLnJlcGxhY2UobmV3IFJlZ0V4cChcIl4vP1wiK2kpLFwiXCIpLGUpLCEwKX0sdGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5yb3V0ZXM9dz1bXSxBJiZ3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsdGhpcy5fX3BvcHN0YXRlTGlzdGVuZXIpLHRoaXMuZGVzdHJveWVkPUw9ITB9LHRoaXMubm90Rm91bmQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gci5fbm90Rm91bmRSb3V0ZT1OKFwiKlwiLHQsW2Usbl0sXCJfX05PVF9GT1VORF9fXCIpLHRoaXN9LHRoaXMudXBkYXRlUGFnZUxpbmtzPUYsdGhpcy5saW5rPWZ1bmN0aW9uKHQpe3JldHVyblwiL1wiK2krXCIvXCIrcyh0KX0sdGhpcy5ob29rcz1mdW5jdGlvbih0KXtyZXR1cm4gZT10LHRoaXN9LHRoaXMuZXh0cmFjdEdFVFBhcmFtZXRlcnM9ZnVuY3Rpb24odCl7cmV0dXJuIGgoUih0KSl9LHRoaXMubGFzdFJlc29sdmVkPWZ1bmN0aW9uKCl7cmV0dXJuIGR9LHRoaXMuZ2VuZXJhdGU9SSx0aGlzLmdldExpbmtQYXRoPWZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEF0dHJpYnV0ZShcImhyZWZcIil9LHRoaXMubWF0Y2g9ZnVuY3Rpb24odCl7dmFyIG49e2luc3RhbmNlOnIsY3VycmVudExvY2F0aW9uUGF0aDp0LHRvOnQsbmF2aWdhdGVPcHRpb25zOnt9LHJlc29sdmVPcHRpb25zOm99O3JldHVybiBfKG4sKGZ1bmN0aW9uKCl7fSkpLCEhbi5tYXRjaGVzJiZuLm1hdGNoZXN9LHRoaXMubWF0Y2hMb2NhdGlvbj1mdW5jdGlvbih0LG4sZSl7dm9pZCAwPT09bnx8dm9pZCAwIT09ZSYmIWV8fChuPUUobikpO3ZhciBvPXtpbnN0YW5jZTpyLHRvOm4sY3VycmVudExvY2F0aW9uUGF0aDpufTtyZXR1cm4geShvLChmdW5jdGlvbigpe30pKSxcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9dm9pZCAwPT09ZXx8ZT9FKHQpOnQpLGwobyx7bmFtZTpTdHJpbmcodCkscGF0aDp0LGhhbmRsZXI6ZnVuY3Rpb24oKXt9LGhvb2tzOnt9fSl8fCExfSx0aGlzLmdldEN1cnJlbnRMb2NhdGlvbj1mdW5jdGlvbigpe3JldHVybiBNKHMoYShpKSkucmVwbGFjZShuZXcgUmVnRXhwKFwiXlwiK2kpLFwiXCIpKX0sdGhpcy5hZGRCZWZvcmVIb29rPVQuYmluZCh0aGlzLFwiYmVmb3JlXCIpLHRoaXMuYWRkQWZ0ZXJIb29rPVQuYmluZCh0aGlzLFwiYWZ0ZXJcIiksdGhpcy5hZGRBbHJlYWR5SG9vaz1ULmJpbmQodGhpcyxcImFscmVhZHlcIiksdGhpcy5hZGRMZWF2ZUhvb2s9VC5iaW5kKHRoaXMsXCJsZWF2ZVwiKSx0aGlzLmdldFJvdXRlPXosdGhpcy5fcGF0aFRvTWF0Y2hPYmplY3Q9TSx0aGlzLl9jbGVhbj1zLHRoaXMuX2NoZWNrRm9yQUhhc2g9Uix0aGlzLl9zZXRDdXJyZW50PWZ1bmN0aW9uKHQpe3JldHVybiBkPXIuY3VycmVudD10fSxmdW5jdGlvbigpe0EmJih0aGlzLl9fcG9wc3RhdGVMaXN0ZW5lcj1mdW5jdGlvbigpe3IuX19mcmVlemVMaXN0ZW5pbmd8fFUoKX0sd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLHRoaXMuX19wb3BzdGF0ZUxpc3RlbmVyKSl9LmNhbGwodGhpcyksRi5jYWxsKHRoaXMpfX19LG49e307ZnVuY3Rpb24gZShvKXtpZihuW29dKXJldHVybiBuW29dLmV4cG9ydHM7dmFyIHI9bltvXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbb10ocixyLmV4cG9ydHMsZSksci5leHBvcnRzfXJldHVybiBlLmQ9ZnVuY3Rpb24odCxuKXtmb3IodmFyIG8gaW4gbillLm8obixvKSYmIWUubyh0LG8pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxvLHtlbnVtZXJhYmxlOiEwLGdldDpuW29dfSl9LGUubz1mdW5jdGlvbih0LG4pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKX0sZSg0MDcpfSgpLmRlZmF1bHR9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ28ubWluLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8123\n')},3690:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3379);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7795);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(569);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3565);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9216);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4589);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_global_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6525);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_global_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_global_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_global_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_global_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY5MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxNQUErRjtBQUMvRixNQUFxRjtBQUNyRixNQUE0RjtBQUM1RixNQUErRztBQUMvRyxNQUF3RztBQUN4RyxNQUF3RztBQUN4RyxNQUE2STtBQUM3STtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixxR0FBbUI7QUFDL0Msd0JBQXdCLGtIQUFhOztBQUVyQyx1QkFBdUIsdUdBQWE7QUFDcEM7QUFDQSxpQkFBaUIsK0ZBQU07QUFDdkIsNkJBQTZCLHNHQUFrQjs7QUFFL0MsYUFBYSwwR0FBRyxDQUFDLHNJQUFPOzs7O0FBSXVGO0FBQy9HLE9BQU8saUVBQWUsc0lBQU8sSUFBSSxvSkFBYyxHQUFHLG9KQUFjLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvZ2xvYmFsLnNjc3M/MmMyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JhbC5zY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmFsLnNjc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3690\n')},3379:module=>{"use strict";eval('\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = "".concat(id, " ").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM3OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3379\n')},569:module=>{"use strict";eval('\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === "undefined") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzP2IyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///569\n')},9216:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement("style");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIxNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/ZGU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9216\n')},3565:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute("nonce", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU2NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYyxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcz9kZGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3565\n')},7795:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = "";\n\n  if (obj.supports) {\n    css += "@supports (".concat(obj.supports, ") {");\n  }\n\n  if (obj.media) {\n    css += "@media ".concat(obj.media, " {");\n  }\n\n  var needLayer = typeof obj.layer !== "undefined";\n\n  if (needLayer) {\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += "}";\n  }\n\n  if (obj.media) {\n    css += "}";\n  }\n\n  if (obj.supports) {\n    css += "}";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== "undefined") {\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc5NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQSxpRkFBaUY7QUFDakY7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsSUFBSTs7QUFFSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7795\n')},4589:module=>{"use strict";eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU4OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzFkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4589\n")},1857:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Charts = void 0;\r\nconst auto_1 = __importDefault(__webpack_require__(8597));\r\nconst api_1 = __webpack_require__(1341);\r\nconst Storage_1 = __webpack_require__(7114);\r\nclass Charts {\r\n    constructor() {\r\n        this.api = api_1.api;\r\n        this.storage = Storage_1.storage;\r\n    }\r\n    // eslint-disable-next-line max-len\r\n    createChart(id, days, wordsCout, descr, type) {\r\n        const ctx = document.getElementById(id);\r\n        const data = {\r\n            labels: days,\r\n            datasets: [{\r\n                    label: descr,\r\n                    backgroundColor: '#332A7C',\r\n                    borderColor: '#332A7C',\r\n                    tension: 0.3,\r\n                    data: wordsCout,\r\n                }],\r\n        };\r\n        const config = {\r\n            type,\r\n            data,\r\n            options: {\r\n                responsive: false,\r\n                maintainAspectRatio: false,\r\n                scales: {\r\n                    x: {\r\n                        min: 0,\r\n                    },\r\n                    y: {\r\n                        min: 0,\r\n                        ticks: {\r\n                            // Include a dollar sign in the ticks\r\n                            // eslint-disable-next-line consistent-return\r\n                            callback(value) {\r\n                                if (Number(value) % 1 === 0) {\r\n                                    return value;\r\n                                }\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        };\r\n        return new auto_1.default(ctx, config);\r\n    }\r\n    async getStatisticForCarts() {\r\n        const userData = this.storage.getUserIdData();\r\n        const data = await this.api.getStatistic(userData);\r\n        if (!data || typeof data === 'string')\r\n            return null;\r\n        const dates = Object.keys(data.optional.words);\r\n        const newWords = [];\r\n        const learnedWords = [];\r\n        dates.forEach((date, index) => {\r\n            newWords.push(data.optional.words[date].newWords);\r\n            if (index === 0)\r\n                learnedWords.push(data.optional.words[date].learnedWords);\r\n            else\r\n                learnedWords.push(data.optional.words[date].learnedWords + learnedWords[index - 1]);\r\n        });\r\n        const result = { dates, newWords, learnedWords };\r\n        return result;\r\n    }\r\n}\r\nexports.Charts = Charts;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixDQUFDO0NBQ0Y7QUFwRUQsd0JBb0VDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL0NoYXJ0cy9DaGFydHMudHM/MjY0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hhcnQsIHsgQ2hhcnRDb25maWd1cmF0aW9uLCBDaGFydEl0ZW0sIENoYXJ0VHlwZVJlZ2lzdHJ5IH0gZnJvbSAnY2hhcnQuanMvYXV0byc7XHJcbmltcG9ydCB7IGFwaSB9IGZyb20gJy4uL01vZGVsL2FwaSc7XHJcbmltcG9ydCB7IHN0b3JhZ2UgfSBmcm9tICcuLi9TdG9yYWdlL1N0b3JhZ2UnO1xyXG5pbXBvcnQgeyBTdGF0aXN0aWNGb3JDYXJ0cyB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIENoYXJ0cyB7XHJcbiAgYXBpOiB0eXBlb2YgYXBpO1xyXG5cclxuICBzdG9yYWdlOiB0eXBlb2Ygc3RvcmFnZTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmFwaSA9IGFwaTtcclxuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgfVxyXG5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxyXG4gIHB1YmxpYyBjcmVhdGVDaGFydChpZDogc3RyaW5nLCBkYXlzOiBzdHJpbmdbXSwgd29yZHNDb3V0OiBudW1iZXJbXSwgZGVzY3I6IHN0cmluZywgdHlwZToga2V5b2YgQ2hhcnRUeXBlUmVnaXN0cnkpOiBDaGFydCB7XHJcbiAgICBjb25zdCBjdHggPSA8Q2hhcnRJdGVtPmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgIGxhYmVsczogZGF5cyxcclxuICAgICAgZGF0YXNldHM6IFt7XHJcbiAgICAgICAgbGFiZWw6IGRlc2NyLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMzMzJBN0MnLFxyXG4gICAgICAgIGJvcmRlckNvbG9yOiAnIzMzMkE3QycsXHJcbiAgICAgICAgdGVuc2lvbjogMC4zLFxyXG4gICAgICAgIGRhdGE6IHdvcmRzQ291dCxcclxuICAgICAgfV0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNvbmZpZzogQ2hhcnRDb25maWd1cmF0aW9uID0ge1xyXG4gICAgICB0eXBlLFxyXG4gICAgICBkYXRhLFxyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgcmVzcG9uc2l2ZTogZmFsc2UsXHJcbiAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXHJcbiAgICAgICAgc2NhbGVzOiB7XHJcbiAgICAgICAgICB4OiB7XHJcbiAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB5OiB7XHJcbiAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgdGlja3M6IHtcclxuICAgICAgICAgICAgICAvLyBJbmNsdWRlIGEgZG9sbGFyIHNpZ24gaW4gdGhlIHRpY2tzXHJcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXHJcbiAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpICUgMSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDaGFydChjdHgsIGNvbmZpZyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2V0U3RhdGlzdGljRm9yQ2FydHMoKTogUHJvbWlzZTxTdGF0aXN0aWNGb3JDYXJ0cyB8IG51bGw+IHtcclxuICAgIGNvbnN0IHVzZXJEYXRhID0gdGhpcy5zdG9yYWdlLmdldFVzZXJJZERhdGEoKTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFwaS5nZXRTdGF0aXN0aWModXNlckRhdGEpO1xyXG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBkYXRlcyA9IE9iamVjdC5rZXlzKGRhdGEub3B0aW9uYWwud29yZHMpO1xyXG4gICAgY29uc3QgbmV3V29yZHM6IG51bWJlcltdID0gW107XHJcbiAgICBjb25zdCBsZWFybmVkV29yZHM6IG51bWJlcltdID0gW107XHJcbiAgICBkYXRlcy5mb3JFYWNoKChkYXRlLCBpbmRleCkgPT4ge1xyXG4gICAgICBuZXdXb3Jkcy5wdXNoKGRhdGEub3B0aW9uYWwud29yZHNbZGF0ZV0ubmV3V29yZHMpO1xyXG4gICAgICBpZiAoaW5kZXggPT09IDApIGxlYXJuZWRXb3Jkcy5wdXNoKGRhdGEub3B0aW9uYWwud29yZHNbZGF0ZV0ubGVhcm5lZFdvcmRzKTtcclxuICAgICAgZWxzZSBsZWFybmVkV29yZHMucHVzaChkYXRhLm9wdGlvbmFsLndvcmRzW2RhdGVdLmxlYXJuZWRXb3JkcyArIGxlYXJuZWRXb3Jkc1tpbmRleCAtIDFdKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVzdWx0ID0geyBkYXRlcywgbmV3V29yZHMsIGxlYXJuZWRXb3JkcyB9O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1857\n")},8096:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { "default": mod };\r\n};\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.MainPage = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nclass MainPage {\r\n    renderMain() {\r\n        const container = document.querySelector(\'.main\');\r\n        container.innerHTML = \'\';\r\n        const template = (0, createNode_1.default)({ tag: \'div\', classes: [\'main-section\'], inner: `${this.makePage()}` });\r\n        container.append(template);\r\n        return container;\r\n    }\r\n    makePage() {\r\n        const template = `<section class="hero-section">\r\n    <h1 class="hero-section-header">Learn Engish and play</h1>\r\n    <p class="hero-section-text">Some text about this cool and great and perfect app goes here may be some words about the rules and the text book and games or about that there are 6 level, but you may get statistic and 7th level after registration</p>\r\n    <a href="https://youtu.be/_86RUdmUWtk" target="_blank">\r\n    <button class="video-btn btn-secondary"><span class="material-icons-outlined video-icon">play_circle_filled</span>как учиться</button>\r\n    </a>\r\n      <section class="advantages-section">\r\n      <div class="advantage_wrapper">\r\n        <img src="./assets/books.jpg" alt="Преимущество - учебник с более чем 3600 слов" class="advantage-image">\r\n        <h2 class="advantage-header">Учебник</h2>\r\n        <p class="advantage-text">Более 3000 слов разделенных на 6 уровней сложности</p>\r\n      </div>\r\n      <div class="advantage_wrapper">\r\n        <img src="./assets/games.jpg" alt="Преимущество - интерактивные игры для изучения слов" class="advantage-image">\r\n        <h2 class="advantage-header">Игры</h2>\r\n        <p class="advantage-text">Интерактивные игры для легкого изучения слов</p>\r\n      </div>\r\n      <div class="advantage_wrapper">\r\n        <img src="./assets/progress.jpg" alt="Преимущество - отслеживание прогресса" class="advantage-image">\r\n        <h2 class="advantage-header">Прогресс</h2>\r\n        <p class="advantage-text">Зарегистрируйса и отлеживай свой прогресс каждый день</p>\r\n      </div>\r\n      <div class="advantage_wrapper">\r\n        <img src="./assets/vocab.jpg" alt="Преимущество - cловарь со сложными словами" class="advantage-image">\r\n        <h2 class="advantage-header">Словарь</h2>\r\n        <p class="advantage-text">Сохраняй слова в словарь, чтобы выучить их позже</p>\r\n      </div>\r\n    </section>\r\n  </section>\r\n  <section class="team-section">\r\n    <h2 class="team-section-header">Наша команда</h2>\r\n    <div class="team-members">\r\n      <div class="team-member">\r\n        <img src="./assets/sveta-photo.jpg" alt="" class="team-member-img">\r\n        <h3 class="team-member-name">Светлана</h3>\r\n        <p class="member-duty">Team lead, developer, designer</p>\r\n        <div class="member-actions">\r\n          <ul>\r\n            <li>Учебник</li>\r\n            <li>Дизайн приложения</li>\r\n            <li>Регистрация и авторизация</li>\r\n            <li>Главная страница</li>\r\n            <li>Рендер страницы статистика</li>\r\n          </ul>\r\n        </div>\r\n        <a class="git-icon" href="https://github.com/svetarachok" target="_blank"></a>\r\n      </div>\r\n      <div class="team-member">\r\n        <img src="./assets/evgen-photo.jpg" alt="" class="team-member-img">\r\n        <h3 class="team-member-name">Евгений</h3>\r\n        <p class="member-duty">Developer, designer</p>\r\n        <div class="member-actions">\r\n          <ul>\r\n            <li>Роутинг</li>\r\n            <li>Игра Спринт</li>\r\n            <li>Логика работы со словами пользователя</li>\r\n            <li>Графики на странице статистики</li>\r\n        </div>\r\n        <a class="git-icon" href="https://github.com/Parxommm" target="_blank"></a>\r\n      </div>\r\n      <div class="team-member">\r\n        <img src="./assets/sergey-photo.jpg" alt="" class="team-member-img">\r\n        <h3 class="team-member-name">Сергей</h3>\r\n        <p class="member-duty">Developer, designer</p>\r\n        <div class="member-actions">\r\n          <ul>\r\n            <li>Деплой и настройка бэкенда</li>\r\n            <li>Взаимодействие с API</li>\r\n            <li>Игра Аудиовызов</li>\r\n            <li>Логика формирования статистики</li>\r\n          </ul>\r\n        </div>\r\n        <a class="git-icon" href="https://github.com/SiarheiHa" target="_blank"></a>\r\n      </div>\r\n    </div>\r\n  </section>`;\r\n        return template;\r\n    }\r\n}\r\nexports.MainPage = MainPage;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA5Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnRUFBNkM7QUFFN0MsTUFBYSxRQUFRO0lBQ25CLFVBQVU7UUFDUixNQUFNLFNBQVMsR0FBZ0IsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQWdCLENBQUM7UUFDOUUsU0FBUyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDekIsTUFBTSxRQUFRLEdBQUcsd0JBQVUsRUFBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3BHLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0IsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELFFBQVE7UUFDTixNQUFNLFFBQVEsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBMkVSLENBQUM7UUFDVixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0NBQ0Y7QUF4RkQsNEJBd0ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL01haW5QYWdlL01haW5QYWdlLnRzP2YwYmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZU5vZGUgZnJvbSAnLi4vdXRpbHMvY3JlYXRlTm9kZSc7XHJcblxyXG5leHBvcnQgY2xhc3MgTWFpblBhZ2Uge1xyXG4gIHJlbmRlck1haW4oKSB7XHJcbiAgICBjb25zdCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4nKSBhcyBIVE1MRWxlbWVudDtcclxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgIGNvbnN0IHRlbXBsYXRlID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnbWFpbi1zZWN0aW9uJ10sIGlubmVyOiBgJHt0aGlzLm1ha2VQYWdlKCl9YCB9KTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmQodGVtcGxhdGUpO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIG1ha2VQYWdlKCkge1xyXG4gICAgY29uc3QgdGVtcGxhdGUgPSBgPHNlY3Rpb24gY2xhc3M9XCJoZXJvLXNlY3Rpb25cIj5cclxuICAgIDxoMSBjbGFzcz1cImhlcm8tc2VjdGlvbi1oZWFkZXJcIj5MZWFybiBFbmdpc2ggYW5kIHBsYXk8L2gxPlxyXG4gICAgPHAgY2xhc3M9XCJoZXJvLXNlY3Rpb24tdGV4dFwiPlNvbWUgdGV4dCBhYm91dCB0aGlzIGNvb2wgYW5kIGdyZWF0IGFuZCBwZXJmZWN0IGFwcCBnb2VzIGhlcmUgbWF5IGJlIHNvbWUgd29yZHMgYWJvdXQgdGhlIHJ1bGVzIGFuZCB0aGUgdGV4dCBib29rIGFuZCBnYW1lcyBvciBhYm91dCB0aGF0IHRoZXJlIGFyZSA2IGxldmVsLCBidXQgeW91IG1heSBnZXQgc3RhdGlzdGljIGFuZCA3dGggbGV2ZWwgYWZ0ZXIgcmVnaXN0cmF0aW9uPC9wPlxyXG4gICAgPGEgaHJlZj1cImh0dHBzOi8veW91dHUuYmUvXzg2UlVkbVVXdGtcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cclxuICAgIDxidXR0b24gY2xhc3M9XCJ2aWRlby1idG4gYnRuLXNlY29uZGFyeVwiPjxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnMtb3V0bGluZWQgdmlkZW8taWNvblwiPnBsYXlfY2lyY2xlX2ZpbGxlZDwvc3Bhbj7QutCw0Log0YPRh9C40YLRjNGB0Y88L2J1dHRvbj5cclxuICAgIDwvYT5cclxuICAgICAgPHNlY3Rpb24gY2xhc3M9XCJhZHZhbnRhZ2VzLXNlY3Rpb25cIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImFkdmFudGFnZV93cmFwcGVyXCI+XHJcbiAgICAgICAgPGltZyBzcmM9XCIuL2Fzc2V0cy9ib29rcy5qcGdcIiBhbHQ9XCLQn9GA0LXQuNC80YPRidC10YHRgtCy0L4gLSDRg9GH0LXQsdC90LjQuiDRgSDQsdC+0LvQtdC1INGH0LXQvCAzNjAwINGB0LvQvtCyXCIgY2xhc3M9XCJhZHZhbnRhZ2UtaW1hZ2VcIj5cclxuICAgICAgICA8aDIgY2xhc3M9XCJhZHZhbnRhZ2UtaGVhZGVyXCI+0KPRh9C10LHQvdC40Lo8L2gyPlxyXG4gICAgICAgIDxwIGNsYXNzPVwiYWR2YW50YWdlLXRleHRcIj7QkdC+0LvQtdC1IDMwMDAg0YHQu9C+0LIg0YDQsNC30LTQtdC70LXQvdC90YvRhSDQvdCwIDYg0YPRgNC+0LLQvdC10Lkg0YHQu9C+0LbQvdC+0YHRgtC4PC9wPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImFkdmFudGFnZV93cmFwcGVyXCI+XHJcbiAgICAgICAgPGltZyBzcmM9XCIuL2Fzc2V0cy9nYW1lcy5qcGdcIiBhbHQ9XCLQn9GA0LXQuNC80YPRidC10YHRgtCy0L4gLSDQuNC90YLQtdGA0LDQutGC0LjQstC90YvQtSDQuNCz0YDRiyDQtNC70Y8g0LjQt9GD0YfQtdC90LjRjyDRgdC70L7QslwiIGNsYXNzPVwiYWR2YW50YWdlLWltYWdlXCI+XHJcbiAgICAgICAgPGgyIGNsYXNzPVwiYWR2YW50YWdlLWhlYWRlclwiPtCY0LPRgNGLPC9oMj5cclxuICAgICAgICA8cCBjbGFzcz1cImFkdmFudGFnZS10ZXh0XCI+0JjQvdGC0LXRgNCw0LrRgtC40LLQvdGL0LUg0LjQs9GA0Ysg0LTQu9GPINC70LXQs9C60L7Qs9C+INC40LfRg9GH0LXQvdC40Y8g0YHQu9C+0LI8L3A+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYWR2YW50YWdlX3dyYXBwZXJcIj5cclxuICAgICAgICA8aW1nIHNyYz1cIi4vYXNzZXRzL3Byb2dyZXNzLmpwZ1wiIGFsdD1cItCf0YDQtdC40LzRg9GJ0LXRgdGC0LLQviAtINC+0YLRgdC70LXQttC40LLQsNC90LjQtSDQv9GA0L7Qs9GA0LXRgdGB0LBcIiBjbGFzcz1cImFkdmFudGFnZS1pbWFnZVwiPlxyXG4gICAgICAgIDxoMiBjbGFzcz1cImFkdmFudGFnZS1oZWFkZXJcIj7Qn9GA0L7Qs9GA0LXRgdGBPC9oMj5cclxuICAgICAgICA8cCBjbGFzcz1cImFkdmFudGFnZS10ZXh0XCI+0JfQsNGA0LXQs9C40YHRgtGA0LjRgNGD0LnRgdCwINC4INC+0YLQu9C10LbQuNCy0LDQuSDRgdCy0L7QuSDQv9GA0L7Qs9GA0LXRgdGBINC60LDQttC00YvQuSDQtNC10L3RjDwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJhZHZhbnRhZ2Vfd3JhcHBlclwiPlxyXG4gICAgICAgIDxpbWcgc3JjPVwiLi9hc3NldHMvdm9jYWIuanBnXCIgYWx0PVwi0J/RgNC10LjQvNGD0YnQtdGB0YLQstC+IC0gY9C70L7QstCw0YDRjCDRgdC+INGB0LvQvtC20L3Ri9C80Lgg0YHQu9C+0LLQsNC80LhcIiBjbGFzcz1cImFkdmFudGFnZS1pbWFnZVwiPlxyXG4gICAgICAgIDxoMiBjbGFzcz1cImFkdmFudGFnZS1oZWFkZXJcIj7QodC70L7QstCw0YDRjDwvaDI+XHJcbiAgICAgICAgPHAgY2xhc3M9XCJhZHZhbnRhZ2UtdGV4dFwiPtCh0L7RhdGA0LDQvdGP0Lkg0YHQu9C+0LLQsCDQsiDRgdC70L7QstCw0YDRjCwg0YfRgtC+0LHRiyDQstGL0YPRh9C40YLRjCDQuNGFINC/0L7Qt9C20LU8L3A+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9zZWN0aW9uPlxyXG4gIDwvc2VjdGlvbj5cclxuICA8c2VjdGlvbiBjbGFzcz1cInRlYW0tc2VjdGlvblwiPlxyXG4gICAgPGgyIGNsYXNzPVwidGVhbS1zZWN0aW9uLWhlYWRlclwiPtCd0LDRiNCwINC60L7QvNCw0L3QtNCwPC9oMj5cclxuICAgIDxkaXYgY2xhc3M9XCJ0ZWFtLW1lbWJlcnNcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cInRlYW0tbWVtYmVyXCI+XHJcbiAgICAgICAgPGltZyBzcmM9XCIuL2Fzc2V0cy9zdmV0YS1waG90by5qcGdcIiBhbHQ9XCJcIiBjbGFzcz1cInRlYW0tbWVtYmVyLWltZ1wiPlxyXG4gICAgICAgIDxoMyBjbGFzcz1cInRlYW0tbWVtYmVyLW5hbWVcIj7QodCy0LXRgtC70LDQvdCwPC9oMz5cclxuICAgICAgICA8cCBjbGFzcz1cIm1lbWJlci1kdXR5XCI+VGVhbSBsZWFkLCBkZXZlbG9wZXIsIGRlc2lnbmVyPC9wPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZW1iZXItYWN0aW9uc1wiPlxyXG4gICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICA8bGk+0KPRh9C10LHQvdC40Lo8L2xpPlxyXG4gICAgICAgICAgICA8bGk+0JTQuNC30LDQudC9INC/0YDQuNC70L7QttC10L3QuNGPPC9saT5cclxuICAgICAgICAgICAgPGxpPtCg0LXQs9C40YHRgtGA0LDRhtC40Y8g0Lgg0LDQstGC0L7RgNC40LfQsNGG0LjRjzwvbGk+XHJcbiAgICAgICAgICAgIDxsaT7Qk9C70LDQstC90LDRjyDRgdGC0YDQsNC90LjRhtCwPC9saT5cclxuICAgICAgICAgICAgPGxpPtCg0LXQvdC00LXRgCDRgdGC0YDQsNC90LjRhtGLINGB0YLQsNGC0LjRgdGC0LjQutCwPC9saT5cclxuICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGEgY2xhc3M9XCJnaXQtaWNvblwiIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vc3ZldGFyYWNob2tcIiB0YXJnZXQ9XCJfYmxhbmtcIj48L2E+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwidGVhbS1tZW1iZXJcIj5cclxuICAgICAgICA8aW1nIHNyYz1cIi4vYXNzZXRzL2V2Z2VuLXBob3RvLmpwZ1wiIGFsdD1cIlwiIGNsYXNzPVwidGVhbS1tZW1iZXItaW1nXCI+XHJcbiAgICAgICAgPGgzIGNsYXNzPVwidGVhbS1tZW1iZXItbmFtZVwiPtCV0LLQs9C10L3QuNC5PC9oMz5cclxuICAgICAgICA8cCBjbGFzcz1cIm1lbWJlci1kdXR5XCI+RGV2ZWxvcGVyLCBkZXNpZ25lcjwvcD5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwibWVtYmVyLWFjdGlvbnNcIj5cclxuICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgPGxpPtCg0L7Rg9GC0LjQvdCzPC9saT5cclxuICAgICAgICAgICAgPGxpPtCY0LPRgNCwINCh0L/RgNC40L3RgjwvbGk+XHJcbiAgICAgICAgICAgIDxsaT7Qm9C+0LPQuNC60LAg0YDQsNCx0L7RgtGLINGB0L4g0YHQu9C+0LLQsNC80Lgg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPPC9saT5cclxuICAgICAgICAgICAgPGxpPtCT0YDQsNGE0LjQutC4INC90LAg0YHRgtGA0LDQvdC40YbQtSDRgdGC0LDRgtC40YHRgtC40LrQuDwvbGk+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGEgY2xhc3M9XCJnaXQtaWNvblwiIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vUGFyeG9tbW1cIiB0YXJnZXQ9XCJfYmxhbmtcIj48L2E+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwidGVhbS1tZW1iZXJcIj5cclxuICAgICAgICA8aW1nIHNyYz1cIi4vYXNzZXRzL3NlcmdleS1waG90by5qcGdcIiBhbHQ9XCJcIiBjbGFzcz1cInRlYW0tbWVtYmVyLWltZ1wiPlxyXG4gICAgICAgIDxoMyBjbGFzcz1cInRlYW0tbWVtYmVyLW5hbWVcIj7QodC10YDQs9C10Lk8L2gzPlxyXG4gICAgICAgIDxwIGNsYXNzPVwibWVtYmVyLWR1dHlcIj5EZXZlbG9wZXIsIGRlc2lnbmVyPC9wPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZW1iZXItYWN0aW9uc1wiPlxyXG4gICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICA8bGk+0JTQtdC/0LvQvtC5INC4INC90LDRgdGC0YDQvtC50LrQsCDQsdGN0LrQtdC90LTQsDwvbGk+XHJcbiAgICAgICAgICAgIDxsaT7QktC30LDQuNC80L7QtNC10LnRgdGC0LLQuNC1INGBIEFQSTwvbGk+XHJcbiAgICAgICAgICAgIDxsaT7QmNCz0YDQsCDQkNGD0LTQuNC+0LLRi9C30L7QsjwvbGk+XHJcbiAgICAgICAgICAgIDxsaT7Qm9C+0LPQuNC60LAg0YTQvtGA0LzQuNGA0L7QstCw0L3QuNGPINGB0YLQsNGC0LjRgdGC0LjQutC4PC9saT5cclxuICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGEgY2xhc3M9XCJnaXQtaWNvblwiIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vU2lhcmhlaUhhXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PC9hPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIDwvc2VjdGlvbj5gO1xyXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8096\n')},1341:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.api = exports.Api = void 0;\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst enums_1 = __webpack_require__(8875);\r\nconst constants_1 = __webpack_require__(5004);\r\nconst functions_1 = __webpack_require__(9593);\r\nconst makeDailyStatObject_1 = __webpack_require__(8105);\r\nclass Api {\r\n    constructor() {\r\n        this.storage = Storage_1.storage;\r\n    }\r\n    async getWords(queryParam) {\r\n        const url = (0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.words, queryParam);\r\n        const response = await fetch(url);\r\n        return response.json();\r\n    }\r\n    async getWordById(id) {\r\n        const url = (0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.words);\r\n        const response = await fetch(`${url}/${id}`);\r\n        return response.json();\r\n    }\r\n    async createUser(userCreationData) {\r\n        const response = await fetch((0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users), {\r\n            method: enums_1.HTTPMethod.POST,\r\n            headers: {\r\n                'Content-Type': enums_1.ContentType.json,\r\n            },\r\n            body: JSON.stringify(userCreationData),\r\n        });\r\n        if (!response.ok)\r\n            return response.text();\r\n        return response.json();\r\n    }\r\n    async authorize(authData) {\r\n        const response = await fetch((0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.signin), {\r\n            method: enums_1.HTTPMethod.POST,\r\n            headers: {\r\n                'Content-Type': enums_1.ContentType.json,\r\n            },\r\n            body: JSON.stringify(authData),\r\n        });\r\n        if (response.status === 404)\r\n            return 'Incorrect e-mail or password';\r\n        const data = await response.json();\r\n        data.tokenExpires = Date.now() + constants_1.TOKEN_LIFETIME_IN_HOURS * 60 * 60 * 1000;\r\n        return data;\r\n    }\r\n    // need tocken check\r\n    async getUserById(authData) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n            headers: {\r\n                Accept: enums_1.ContentType.json,\r\n            },\r\n        });\r\n        if (response.status === 403)\r\n            return 'UserId not found';\r\n        if (response.status === 401)\r\n            return 'Access token is missing or invalid';\r\n        return response.json();\r\n    }\r\n    async getNewUserToken(authData) {\r\n        const response = await fetch(`${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.tokens}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n            headers: {\r\n                Authorization: `Bearer ${authData.refreshToken}`,\r\n            },\r\n        });\r\n        if (response.status === 403 || response.status === 401)\r\n            return 'Access token is missing, expired or invalid';\r\n        return response.json();\r\n    }\r\n    // need tocken check\r\n    async setUserWord(authData, wordId, userWord) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.words}/${wordId}`, {\r\n            method: enums_1.HTTPMethod.POST,\r\n            headers: {\r\n                'Content-Type': enums_1.ContentType.json,\r\n            },\r\n            body: JSON.stringify(userWord),\r\n        });\r\n        if (response.status === 400) {\r\n            const errorMessage = (await response.json()).error.errors[0].message;\r\n            return errorMessage;\r\n        }\r\n        if (!response.ok)\r\n            return response.text();\r\n        return response.json();\r\n    }\r\n    async getUserWords(authData) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.words}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n        });\r\n        if (!response.ok)\r\n            return response.text();\r\n        return response.json();\r\n    }\r\n    async getUserWordById(authData, wordId) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.words}/${wordId}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n        });\r\n        if (response.status === 400) {\r\n            const errorMessage = (await response.json()).error.errors[0].message;\r\n            return errorMessage;\r\n        }\r\n        if (!response.ok)\r\n            return response.text();\r\n        return response.json();\r\n    }\r\n    async changeUserWord(authData, wordId, userWord) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.words}/${wordId}`, {\r\n            method: enums_1.HTTPMethod.PUT,\r\n            headers: {\r\n                'Content-Type': enums_1.ContentType.json,\r\n            },\r\n            body: JSON.stringify(userWord),\r\n        });\r\n        if (response.status === 400) {\r\n            const errorMessage = (await response.json()).error.errors[0].message;\r\n            return errorMessage;\r\n        }\r\n        if (!response.ok)\r\n            return response.text();\r\n        return response.json();\r\n    }\r\n    async deleteUserWord(authData, wordId) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.words}/${wordId}`, {\r\n            method: enums_1.HTTPMethod.DELETE,\r\n        });\r\n        return response.ok;\r\n    }\r\n    async getAggregatedUserWords(authData, queryParam, filterStr) {\r\n        const paramString = filterStr\r\n            ? (0, functions_1.generateQueryString)({ ...queryParam, ...{ filter: filterStr } })\r\n            : (0, functions_1.generateQueryString)(queryParam);\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.aggregatedWords}${paramString}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n        });\r\n        if (!response.ok)\r\n            return response.text();\r\n        const data = await response.json();\r\n        return data[0].paginatedResults;\r\n    }\r\n    async getTotalUserWords(authData, filterStr, queryParam) {\r\n        const paramString = queryParam\r\n            ? (0, functions_1.generateQueryString)({ ...queryParam, ...{ filter: filterStr } })\r\n            : (0, functions_1.generateQueryString)({ filter: filterStr });\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.aggregatedWords}${paramString}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n        });\r\n        if (!response.ok)\r\n            return response.text();\r\n        const data = await response.json();\r\n        if (data[0].totalCount.length) {\r\n            return data[0].totalCount[0].count;\r\n        }\r\n        return 'В вашем учебнике нет Сложных слов';\r\n    }\r\n    async getAggregatedUserWord(authData, wordId) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.aggregatedWords}/${wordId}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n        });\r\n        if (response.status === 400) {\r\n            const errorMessage = (await response.json()).error.errors[0].message;\r\n            return errorMessage;\r\n        }\r\n        if (!response.ok)\r\n            return response.text();\r\n        const data = await response.json();\r\n        return data[0];\r\n    }\r\n    async setStatistic(authData, statistic) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.statistics}`, {\r\n            method: enums_1.HTTPMethod.PUT,\r\n            headers: {\r\n                'Content-Type': enums_1.ContentType.json,\r\n            },\r\n            body: JSON.stringify(statistic),\r\n        });\r\n        const data = await response.json();\r\n        if (!response.ok)\r\n            return response.text();\r\n        return data;\r\n    }\r\n    async getStatistic(authData) {\r\n        const response = await this.fetchWithAuth(authData, `${(0, functions_1.makeUrl)(constants_1.BASE_LINK, enums_1.Endpoint.users)}/${authData.userId}${enums_1.Endpoint.statistics}`, {\r\n            method: enums_1.HTTPMethod.GET,\r\n        });\r\n        if (response.status === 404)\r\n            return null;\r\n        if (!response.ok)\r\n            return response.text();\r\n        const data = await response.json();\r\n        return data;\r\n    }\r\n    async getStatDataForRender() {\r\n        const userData = this.storage.getUserIdData();\r\n        let dailyStat = [];\r\n        const statData = await this.getStatistic(userData);\r\n        if (statData) {\r\n            dailyStat = (0, makeDailyStatObject_1.makeDailyStat)(statData);\r\n            return dailyStat;\r\n        }\r\n        dailyStat = [];\r\n        return dailyStat;\r\n    }\r\n    async fetchWithAuth(authData, url, options) {\r\n        let token;\r\n        if (authData.tokenExpires > Date.now()) {\r\n            token = authData.token;\r\n        }\r\n        else {\r\n            const newUserData = authData;\r\n            const response = await this.getNewUserToken(authData);\r\n            if (typeof response === 'object') {\r\n                newUserData.token = response.token;\r\n                newUserData.refreshToken = response.refreshToken;\r\n                newUserData.tokenExpires = Date.now() + constants_1.TOKEN_LIFETIME_IN_HOURS * 60 * 60 * 1000;\r\n                Storage_1.storage.setData('UserId', newUserData);\r\n                token = newUserData.token;\r\n            }\r\n        }\r\n        const fetchOptions = options;\r\n        fetchOptions.headers = options.headers || {};\r\n        fetchOptions.headers.Authorization = `Bearer ${token}`;\r\n        return fetch(url, fetchOptions);\r\n    }\r\n}\r\nexports.Api = Api;\r\nexports.api = new Api();\r\n// 401 Unauthorized не тот токен\r\n// 403 Forbidden не тот юзерайди\r\n// 404 у юзера нет статистики Couldn't find a(an) statistic with: \"userId: 630a8bf986a1e800749e9556\"\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0MS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSw0Q0FBNkM7QUFDN0MsMENBQW1FO0FBT25FLDhDQUF3RTtBQUN4RSw4Q0FBa0U7QUFDbEUsd0RBQTZEO0FBRTdELE1BQWEsR0FBRztJQUdkO1FBQ0UsSUFBSSxDQUFDLE9BQU8sR0FBRyxpQkFBTyxDQUFDO0lBQ3pCLENBQUM7SUFFTSxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQTRDO1FBQ2hFLE1BQU0sR0FBRyxHQUFRLHVCQUFPLEVBQUMscUJBQVMsRUFBRSxnQkFBUSxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNoRSxNQUFNLFFBQVEsR0FBRyxNQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsQyxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxFQUFVO1FBQ2pDLE1BQU0sR0FBRyxHQUFRLHVCQUFPLEVBQUMscUJBQVMsRUFBRSxnQkFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BELE1BQU0sUUFBUSxHQUFHLE1BQU0sS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDN0MsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVNLEtBQUssQ0FBQyxVQUFVLENBQUMsZ0JBQWtDO1FBQ3hELE1BQU0sUUFBUSxHQUFHLE1BQU0sS0FBSyxDQUFDLHVCQUFPLEVBQUMscUJBQVMsRUFBRSxnQkFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQy9ELE1BQU0sRUFBRSxrQkFBVSxDQUFDLElBQUk7WUFDdkIsT0FBTyxFQUFFO2dCQUNQLGNBQWMsRUFBRSxtQkFBVyxDQUFDLElBQUk7YUFDakM7WUFDRCxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQztTQUN2QyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN6QyxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRU0sS0FBSyxDQUFDLFNBQVMsQ0FBQyxRQUFzRDtRQUMzRSxNQUFNLFFBQVEsR0FBRyxNQUFNLEtBQUssQ0FBQyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNoRSxNQUFNLEVBQUUsa0JBQVUsQ0FBQyxJQUFJO1lBQ3ZCLE9BQU8sRUFBRTtnQkFDUCxjQUFjLEVBQUUsbUJBQVcsQ0FBQyxJQUFJO2FBQ2pDO1lBQ0QsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO1NBQy9CLENBQUMsQ0FBQztRQUVILElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHO1lBQUUsT0FBTyw4QkFBOEIsQ0FBQztRQUNuRSxNQUFNLElBQUksR0FBRyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxtQ0FBdUIsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztRQUMxRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxvQkFBb0I7SUFDYixLQUFLLENBQUMsV0FBVyxDQUFDLFFBQTJCO1FBQ2xELE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBRyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDOUcsTUFBTSxFQUFFLGtCQUFVLENBQUMsR0FBRztZQUN0QixPQUFPLEVBQUU7Z0JBQ1AsTUFBTSxFQUFFLG1CQUFXLENBQUMsSUFBSTthQUN6QjtTQUNGLENBQUMsQ0FBQztRQUVILElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHO1lBQUUsT0FBTyxrQkFBa0IsQ0FBQztRQUN2RCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssR0FBRztZQUFFLE9BQU8sb0NBQW9DLENBQUM7UUFDekUsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVNLEtBQUssQ0FBQyxlQUFlLENBQUMsUUFBNEQ7UUFFdkYsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsR0FBRyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLGdCQUFRLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDekcsTUFBTSxFQUFFLGtCQUFVLENBQUMsR0FBRztZQUN0QixPQUFPLEVBQUU7Z0JBQ1AsYUFBYSxFQUFFLFVBQVUsUUFBUSxDQUFDLFlBQVksRUFBRTthQUNqRDtTQUNGLENBQUMsQ0FBQztRQUVILElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHO1lBQUUsT0FBTyw2Q0FBNkMsQ0FBQztRQUM3RyxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsb0JBQW9CO0lBQ2IsS0FBSyxDQUFDLFdBQVcsQ0FDdEIsUUFBMkIsRUFDM0IsTUFBYSxFQUNiLFFBQXlDO1FBR3pDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBRyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLGdCQUFRLENBQUMsS0FBSyxJQUFJLE1BQU0sRUFBRSxFQUFFO1lBQ3pJLE1BQU0sRUFBRSxrQkFBVSxDQUFDLElBQUk7WUFDdkIsT0FBTyxFQUFFO2dCQUNQLGNBQWMsRUFBRSxtQkFBVyxDQUFDLElBQUk7YUFDakM7WUFDRCxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7U0FDL0IsQ0FBQyxDQUFDO1FBRUgsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRTtZQUMzQixNQUFNLFlBQVksR0FBRyxDQUFDLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFpQixDQUFDO1lBQy9FLE9BQU8sWUFBWSxDQUFDO1NBQ3JCO1FBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQUUsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFekMsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVNLEtBQUssQ0FBQyxZQUFZLENBQUMsUUFBMkI7UUFFbkQsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxHQUFHLHVCQUFPLEVBQUMscUJBQVMsRUFBRSxnQkFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsZ0JBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMvSCxNQUFNLEVBQUUsa0JBQVUsQ0FBQyxHQUFHO1NBQ3ZCLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUFFLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3pDLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFTSxLQUFLLENBQUMsZUFBZSxDQUFDLFFBQTJCLEVBQUUsTUFBYTtRQUVyRSxNQUFNLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLEdBQUcsdUJBQU8sRUFBQyxxQkFBUyxFQUFFLGdCQUFRLENBQUMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxnQkFBUSxDQUFDLEtBQUssSUFBSSxNQUFNLEVBQUUsRUFBRTtZQUN6SSxNQUFNLEVBQUUsa0JBQVUsQ0FBQyxHQUFHO1NBQ3ZCLENBQUMsQ0FBQztRQUNILElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUU7WUFDM0IsTUFBTSxZQUFZLEdBQUcsQ0FBQyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBaUIsQ0FBQztZQUMvRSxPQUFPLFlBQVksQ0FBQztTQUNyQjtRQUNELElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUFFLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3pDLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFTSxLQUFLLENBQUMsY0FBYyxDQUN6QixRQUEyQixFQUMzQixNQUFhLEVBQ2IsUUFBeUM7UUFHekMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxHQUFHLHVCQUFPLEVBQUMscUJBQVMsRUFBRSxnQkFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsZ0JBQVEsQ0FBQyxLQUFLLElBQUksTUFBTSxFQUFFLEVBQUU7WUFDekksTUFBTSxFQUFFLGtCQUFVLENBQUMsR0FBRztZQUN0QixPQUFPLEVBQUU7Z0JBQ1AsY0FBYyxFQUFFLG1CQUFXLENBQUMsSUFBSTthQUNqQztZQUNELElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQztTQUMvQixDQUFDLENBQUM7UUFFSCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO1lBQzNCLE1BQU0sWUFBWSxHQUFHLENBQUMsTUFBTSxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQWlCLENBQUM7WUFDL0UsT0FBTyxZQUFZLENBQUM7U0FDckI7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUV6QyxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRU0sS0FBSyxDQUFDLGNBQWMsQ0FBQyxRQUEyQixFQUFFLE1BQWE7UUFFcEUsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxHQUFHLHVCQUFPLEVBQUMscUJBQVMsRUFBRSxnQkFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsZ0JBQVEsQ0FBQyxLQUFLLElBQUksTUFBTSxFQUFFLEVBQUU7WUFDekksTUFBTSxFQUFFLGtCQUFVLENBQUMsTUFBTTtTQUMxQixDQUFDLENBQUM7UUFDSCxPQUFPLFFBQVEsQ0FBQyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVNLEtBQUssQ0FBQyxzQkFBc0IsQ0FDakMsUUFBMkIsRUFDM0IsVUFBb0UsRUFDcEUsU0FBa0I7UUFHbEIsTUFBTSxXQUFXLEdBQUcsU0FBUztZQUMzQixDQUFDLENBQUMsbUNBQW1CLEVBQUMsRUFBRSxHQUFHLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxFQUFFLENBQUM7WUFDbEUsQ0FBQyxDQUFDLG1DQUFtQixFQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBRyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLGdCQUFRLENBQUMsZUFBZSxHQUFHLFdBQVcsRUFBRSxFQUFFO1lBQ3ZKLE1BQU0sRUFBRSxrQkFBVSxDQUFDLEdBQUc7U0FDdkIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQUUsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDekMsTUFBTSxJQUFJLEdBQWdDLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRWhFLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDO0lBQ2xDLENBQUM7SUFFTSxLQUFLLENBQUMsaUJBQWlCLENBQzVCLFFBQTJCLEVBQzNCLFNBQWlCLEVBQ2pCLFVBQW9FO1FBR3BFLE1BQU0sV0FBVyxHQUFHLFVBQVU7WUFDNUIsQ0FBQyxDQUFDLG1DQUFtQixFQUFDLEVBQUUsR0FBRyxVQUFVLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFDO1lBQ2xFLENBQUMsQ0FBQyxtQ0FBbUIsRUFBQyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQy9DLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBRyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLGdCQUFRLENBQUMsZUFBZSxHQUFHLFdBQVcsRUFBRSxFQUFFO1lBQ3ZKLE1BQU0sRUFBRSxrQkFBVSxDQUFDLEdBQUc7U0FDdkIsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQUUsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDekMsTUFBTSxJQUFJLEdBQWdDLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2hFLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUU7WUFDN0IsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztTQUNwQztRQUFDLE9BQU8sbUNBQW1DLENBQUM7SUFDL0MsQ0FBQztJQUVNLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxRQUEyQixFQUFFLE1BQWE7UUFFM0UsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxHQUFHLHVCQUFPLEVBQUMscUJBQVMsRUFBRSxnQkFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsZ0JBQVEsQ0FBQyxlQUFlLElBQUksTUFBTSxFQUFFLEVBQUU7WUFDbkosTUFBTSxFQUFFLGtCQUFVLENBQUMsR0FBRztTQUN2QixDQUFDLENBQUM7UUFDSCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO1lBQzNCLE1BQU0sWUFBWSxHQUFHLENBQUMsTUFBTSxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQWlCLENBQUM7WUFDL0UsT0FBTyxZQUFZLENBQUM7U0FDckI7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN6QyxNQUFNLElBQUksR0FBeUIsTUFBTSxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFekQsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUVNLEtBQUssQ0FBQyxZQUFZLENBQ3ZCLFFBQTJCLEVBQzNCLFNBQW9CO1FBR3BCLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBRyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLGdCQUFRLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDcEksTUFBTSxFQUFFLGtCQUFVLENBQUMsR0FBRztZQUN0QixPQUFPLEVBQUU7Z0JBQ1AsY0FBYyxFQUFFLG1CQUFXLENBQUMsSUFBSTthQUNqQztZQUNELElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQztTQUNoQyxDQUFDLENBQUM7UUFFSCxNQUFNLElBQUksR0FBRyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFBRSxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUV6QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTSxLQUFLLENBQUMsWUFBWSxDQUFDLFFBQTJCO1FBRW5ELE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBRyx1QkFBTyxFQUFDLHFCQUFTLEVBQUUsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLGdCQUFRLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDcEksTUFBTSxFQUFFLGtCQUFVLENBQUMsR0FBRztTQUN2QixDQUFDLENBQUM7UUFFSCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssR0FBRztZQUFFLE9BQU8sSUFBSSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUFFLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3pDLE1BQU0sSUFBSSxHQUFHLE1BQU0sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ25DLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVNLEtBQUssQ0FBQyxvQkFBb0I7UUFDL0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUM5QyxJQUFJLFNBQVMsR0FBNkIsRUFBRSxDQUFDO1FBQzdDLE1BQU0sUUFBUSxHQUFzQixNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFzQixDQUFDO1FBQzNGLElBQUksUUFBUSxFQUFFO1lBQ1osU0FBUyxHQUFHLHVDQUFhLEVBQUMsUUFBUSxDQUFDLENBQUM7WUFDcEMsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFTyxLQUFLLENBQUMsYUFBYSxDQUFDLFFBQTJCLEVBQUUsR0FBVyxFQUFFLE9BQXFCO1FBQ3pGLElBQUksS0FBSyxDQUFDO1FBQ1YsSUFBSSxRQUFRLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUN0QyxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQztTQUN4QjthQUFNO1lBQ0wsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDO1lBQzdCLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN0RCxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtnQkFDaEMsV0FBVyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDO2dCQUNuQyxXQUFXLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7Z0JBQ2pELFdBQVcsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLG1DQUF1QixHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO2dCQUVqRixpQkFBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUM7Z0JBQ3ZDLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO2FBQzNCO1NBQ0Y7UUFDRCxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUM7UUFDN0IsWUFBWSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQztRQUM3QyxZQUFZLENBQUMsT0FBTyxDQUFDLGFBQWEsR0FBRyxVQUFVLEtBQUssRUFBRSxDQUFDO1FBQ3ZELE9BQU8sS0FBSyxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNsQyxDQUFDO0NBQ0Y7QUExUUQsa0JBMFFDO0FBRVksV0FBRyxHQUFRLElBQUksR0FBRyxFQUFFLENBQUM7QUFFbEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxvR0FBb0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvTW9kZWwvYXBpLnRzP2MwYWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RvcmFnZSB9IGZyb20gJy4uL1N0b3JhZ2UvU3RvcmFnZSc7XHJcbmltcG9ydCB7IEVuZHBvaW50LCBIVFRQTWV0aG9kLCBDb250ZW50VHlwZSB9IGZyb20gJy4uL3R5cGVzL2VudW1zJztcclxuaW1wb3J0IHtcclxuICBXb3JkLCBVc2VyLCBVc2VyQ3JlYXRpb25EYXRhLCBBdXRob3JpemF0aW9uRGF0YSxcclxuICBVc2VyV29yZCwgVXNlckFnZ3JlZ2F0ZWRXb3Jkc1Jlc3VsdCxcclxuICBVc2VyQWdncmVnYXRlZFdvcmQsXHJcbiAgU3RhdGlzdGljLCBTdGF0aXN0aWNSZXNwb25zZSwgRGFpbHlTdGF0T2JqLCBGZXRjaE9wdGlvbnMsXHJcbn0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IEJBU0VfTElOSywgVE9LRU5fTElGRVRJTUVfSU5fSE9VUlMgfSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZVF1ZXJ5U3RyaW5nLCBtYWtlVXJsIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcclxuaW1wb3J0IHsgbWFrZURhaWx5U3RhdCB9IGZyb20gJy4uL3V0aWxzL21ha2VEYWlseVN0YXRPYmplY3QnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaSB7XHJcbiAgc3RvcmFnZTogdHlwZW9mIHN0b3JhZ2U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRXb3JkcyhxdWVyeVBhcmFtPzogeyBncm91cDogc3RyaW5nLCBwYWdlOiBzdHJpbmcgfSk6IFByb21pc2U8V29yZFtdPiB7XHJcbiAgICBjb25zdCB1cmw6IFVSTCA9IG1ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC53b3JkcywgcXVlcnlQYXJhbSk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGdldFdvcmRCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPFdvcmQ+IHtcclxuICAgIGNvbnN0IHVybDogVVJMID0gbWFrZVVybChCQVNFX0xJTkssIEVuZHBvaW50LndvcmRzKTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dXJsfS8ke2lkfWApO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVVc2VyKHVzZXJDcmVhdGlvbkRhdGE6IFVzZXJDcmVhdGlvbkRhdGEpOiBQcm9taXNlPFVzZXIgfCBzdHJpbmc+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobWFrZVVybChCQVNFX0xJTkssIEVuZHBvaW50LnVzZXJzKSwge1xyXG4gICAgICBtZXRob2Q6IEhUVFBNZXRob2QuUE9TVCxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiBDb250ZW50VHlwZS5qc29uLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyQ3JlYXRpb25EYXRhKSxcclxuICAgIH0pO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgYXV0aG9yaXplKGF1dGhEYXRhOiBQaWNrPFVzZXJDcmVhdGlvbkRhdGEsICdlbWFpbCcgfCAncGFzc3dvcmQnPik6IFByb21pc2U8QXV0aG9yaXphdGlvbkRhdGEgfCBzdHJpbmc+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobWFrZVVybChCQVNFX0xJTkssIEVuZHBvaW50LnNpZ25pbiksIHtcclxuICAgICAgbWV0aG9kOiBIVFRQTWV0aG9kLlBPU1QsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogQ29udGVudFR5cGUuanNvbixcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYXV0aERhdGEpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSByZXR1cm4gJ0luY29ycmVjdCBlLW1haWwgb3IgcGFzc3dvcmQnO1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGRhdGEudG9rZW5FeHBpcmVzID0gRGF0ZS5ub3coKSArIFRPS0VOX0xJRkVUSU1FX0lOX0hPVVJTICogNjAgKiA2MCAqIDEwMDA7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIC8vIG5lZWQgdG9ja2VuIGNoZWNrXHJcbiAgcHVibGljIGFzeW5jIGdldFVzZXJCeUlkKGF1dGhEYXRhOiBBdXRob3JpemF0aW9uRGF0YSk6IFByb21pc2U8VXNlciB8IHN0cmluZz4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEF1dGgoYXV0aERhdGEsIGAke21ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC51c2Vycyl9LyR7YXV0aERhdGEudXNlcklkfWAsIHtcclxuICAgICAgbWV0aG9kOiBIVFRQTWV0aG9kLkdFVCxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIEFjY2VwdDogQ29udGVudFR5cGUuanNvbixcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykgcmV0dXJuICdVc2VySWQgbm90IGZvdW5kJztcclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkgcmV0dXJuICdBY2Nlc3MgdG9rZW4gaXMgbWlzc2luZyBvciBpbnZhbGlkJztcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2V0TmV3VXNlclRva2VuKGF1dGhEYXRhOiBQaWNrPEF1dGhvcml6YXRpb25EYXRhLCAncmVmcmVzaFRva2VuJyB8ICd1c2VySWQnPik6XHJcbiAgUHJvbWlzZTxQaWNrPEF1dGhvcml6YXRpb25EYXRhLCAndG9rZW4nIHwgJ3JlZnJlc2hUb2tlbic+IHwgc3RyaW5nPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke21ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC51c2Vycyl9LyR7YXV0aERhdGEudXNlcklkfSR7RW5kcG9pbnQudG9rZW5zfWAsIHtcclxuICAgICAgbWV0aG9kOiBIVFRQTWV0aG9kLkdFVCxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthdXRoRGF0YS5yZWZyZXNoVG9rZW59YCxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwMSkgcmV0dXJuICdBY2Nlc3MgdG9rZW4gaXMgbWlzc2luZywgZXhwaXJlZCBvciBpbnZhbGlkJztcclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfVxyXG5cclxuICAvLyBuZWVkIHRvY2tlbiBjaGVja1xyXG4gIHB1YmxpYyBhc3luYyBzZXRVc2VyV29yZChcclxuICAgIGF1dGhEYXRhOiBBdXRob3JpemF0aW9uRGF0YSxcclxuICAgIHdvcmRJZDpzdHJpbmcsXHJcbiAgICB1c2VyV29yZDogT21pdDxVc2VyV29yZCwgJ2lkJyB8ICd3b3JkSWQnPixcclxuICApOlxyXG4gICAgUHJvbWlzZTxVc2VyV29yZCB8IHN0cmluZz4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEF1dGgoYXV0aERhdGEsIGAke21ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC51c2Vycyl9LyR7YXV0aERhdGEudXNlcklkfSR7RW5kcG9pbnQud29yZHN9LyR7d29yZElkfWAsIHtcclxuICAgICAgbWV0aG9kOiBIVFRQTWV0aG9kLlBPU1QsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogQ29udGVudFR5cGUuanNvbixcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXNlcldvcmQpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpLmVycm9yLmVycm9yc1swXS5tZXNzYWdlIGFzIHN0cmluZztcclxuICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcclxuICAgIH1cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHJldHVybiByZXNwb25zZS50ZXh0KCk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRVc2VyV29yZHMoYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhKTpcclxuICBQcm9taXNlPFJlcXVpcmVkPFVzZXJXb3JkPltdIHwgc3RyaW5nPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoQXV0aChhdXRoRGF0YSwgYCR7bWFrZVVybChCQVNFX0xJTkssIEVuZHBvaW50LnVzZXJzKX0vJHthdXRoRGF0YS51c2VySWR9JHtFbmRwb2ludC53b3Jkc31gLCB7XHJcbiAgICAgIG1ldGhvZDogSFRUUE1ldGhvZC5HRVQsXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRVc2VyV29yZEJ5SWQoYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhLCB3b3JkSWQ6c3RyaW5nKTpcclxuICBQcm9taXNlPFJlcXVpcmVkPFVzZXJXb3JkPiB8IHN0cmluZz4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEF1dGgoYXV0aERhdGEsIGAke21ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC51c2Vycyl9LyR7YXV0aERhdGEudXNlcklkfSR7RW5kcG9pbnQud29yZHN9LyR7d29yZElkfWAsIHtcclxuICAgICAgbWV0aG9kOiBIVFRQTWV0aG9kLkdFVCxcclxuICAgIH0pO1xyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpLmVycm9yLmVycm9yc1swXS5tZXNzYWdlIGFzIHN0cmluZztcclxuICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcclxuICAgIH1cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHJldHVybiByZXNwb25zZS50ZXh0KCk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGNoYW5nZVVzZXJXb3JkKFxyXG4gICAgYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhLFxyXG4gICAgd29yZElkOnN0cmluZyxcclxuICAgIHVzZXJXb3JkOiBPbWl0PFVzZXJXb3JkLCAnaWQnIHwgJ3dvcmRJZCc+LFxyXG4gICk6XHJcbiAgICBQcm9taXNlPFVzZXJXb3JkIHwgc3RyaW5nPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoQXV0aChhdXRoRGF0YSwgYCR7bWFrZVVybChCQVNFX0xJTkssIEVuZHBvaW50LnVzZXJzKX0vJHthdXRoRGF0YS51c2VySWR9JHtFbmRwb2ludC53b3Jkc30vJHt3b3JkSWR9YCwge1xyXG4gICAgICBtZXRob2Q6IEhUVFBNZXRob2QuUFVULFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IENvbnRlbnRUeXBlLmpzb24sXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVzZXJXb3JkKSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xyXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5lcnJvci5lcnJvcnNbMF0ubWVzc2FnZSBhcyBzdHJpbmc7XHJcbiAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZGVsZXRlVXNlcldvcmQoYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhLCB3b3JkSWQ6c3RyaW5nKTpcclxuICBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhBdXRoKGF1dGhEYXRhLCBgJHttYWtlVXJsKEJBU0VfTElOSywgRW5kcG9pbnQudXNlcnMpfS8ke2F1dGhEYXRhLnVzZXJJZH0ke0VuZHBvaW50LndvcmRzfS8ke3dvcmRJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogSFRUUE1ldGhvZC5ERUxFVEUsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXNwb25zZS5vaztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRBZ2dyZWdhdGVkVXNlcldvcmRzKFxyXG4gICAgYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhLFxyXG4gICAgcXVlcnlQYXJhbTogeyBncm91cD86IHN0cmluZywgcGFnZT86IHN0cmluZywgd29yZHNQZXJQYWdlPzogc3RyaW5nIH0sXHJcbiAgICBmaWx0ZXJTdHI/OiBzdHJpbmcsXHJcbiAgKTpcclxuICAgIFByb21pc2U8VXNlckFnZ3JlZ2F0ZWRXb3JkW10gfCBzdHJpbmc+IHtcclxuICAgIGNvbnN0IHBhcmFtU3RyaW5nID0gZmlsdGVyU3RyXHJcbiAgICAgID8gZ2VuZXJhdGVRdWVyeVN0cmluZyh7IC4uLnF1ZXJ5UGFyYW0sIC4uLnsgZmlsdGVyOiBmaWx0ZXJTdHIgfSB9KVxyXG4gICAgICA6IGdlbmVyYXRlUXVlcnlTdHJpbmcocXVlcnlQYXJhbSk7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoQXV0aChhdXRoRGF0YSwgYCR7bWFrZVVybChCQVNFX0xJTkssIEVuZHBvaW50LnVzZXJzKX0vJHthdXRoRGF0YS51c2VySWR9JHtFbmRwb2ludC5hZ2dyZWdhdGVkV29yZHN9JHtwYXJhbVN0cmluZ31gLCB7XHJcbiAgICAgIG1ldGhvZDogSFRUUE1ldGhvZC5HRVQsXHJcbiAgICB9KTtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHJldHVybiByZXNwb25zZS50ZXh0KCk7XHJcbiAgICBjb25zdCBkYXRhOiBVc2VyQWdncmVnYXRlZFdvcmRzUmVzdWx0W10gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGFbMF0ucGFnaW5hdGVkUmVzdWx0cztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRUb3RhbFVzZXJXb3JkcyhcclxuICAgIGF1dGhEYXRhOiBBdXRob3JpemF0aW9uRGF0YSxcclxuICAgIGZpbHRlclN0cjogc3RyaW5nLFxyXG4gICAgcXVlcnlQYXJhbT86IHsgZ3JvdXA6IHN0cmluZywgcGFnZT86IHN0cmluZywgd29yZHNQZXJQYWdlPzogc3RyaW5nIH0sXHJcbiAgKTpcclxuICAgIFByb21pc2U8bnVtYmVyIHwgc3RyaW5nPiB7XHJcbiAgICBjb25zdCBwYXJhbVN0cmluZyA9IHF1ZXJ5UGFyYW1cclxuICAgICAgPyBnZW5lcmF0ZVF1ZXJ5U3RyaW5nKHsgLi4ucXVlcnlQYXJhbSwgLi4ueyBmaWx0ZXI6IGZpbHRlclN0ciB9IH0pXHJcbiAgICAgIDogZ2VuZXJhdGVRdWVyeVN0cmluZyh7IGZpbHRlcjogZmlsdGVyU3RyIH0pO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEF1dGgoYXV0aERhdGEsIGAke21ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC51c2Vycyl9LyR7YXV0aERhdGEudXNlcklkfSR7RW5kcG9pbnQuYWdncmVnYXRlZFdvcmRzfSR7cGFyYW1TdHJpbmd9YCwge1xyXG4gICAgICBtZXRob2Q6IEhUVFBNZXRob2QuR0VULFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgY29uc3QgZGF0YTogVXNlckFnZ3JlZ2F0ZWRXb3Jkc1Jlc3VsdFtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgaWYgKGRhdGFbMF0udG90YWxDb3VudC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGRhdGFbMF0udG90YWxDb3VudFswXS5jb3VudDtcclxuICAgIH0gcmV0dXJuICfQkiDQstCw0YjQtdC8INGD0YfQtdCx0L3QuNC60LUg0L3QtdGCINCh0LvQvtC20L3Ri9GFINGB0LvQvtCyJztcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRBZ2dyZWdhdGVkVXNlcldvcmQoYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhLCB3b3JkSWQ6c3RyaW5nKTpcclxuICBQcm9taXNlPFVzZXJBZ2dyZWdhdGVkV29yZCB8IHN0cmluZz4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEF1dGgoYXV0aERhdGEsIGAke21ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC51c2Vycyl9LyR7YXV0aERhdGEudXNlcklkfSR7RW5kcG9pbnQuYWdncmVnYXRlZFdvcmRzfS8ke3dvcmRJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogSFRUUE1ldGhvZC5HRVQsXHJcbiAgICB9KTtcclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xyXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5lcnJvci5lcnJvcnNbMF0ubWVzc2FnZSBhcyBzdHJpbmc7XHJcbiAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgY29uc3QgZGF0YTogVXNlckFnZ3JlZ2F0ZWRXb3JkW10gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGFbMF07XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgc2V0U3RhdGlzdGljKFxyXG4gICAgYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhLFxyXG4gICAgc3RhdGlzdGljOiBTdGF0aXN0aWMsXHJcbiAgKTpcclxuICAgIFByb21pc2U8U3RhdGlzdGljUmVzcG9uc2UgfCBzdHJpbmc+IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhBdXRoKGF1dGhEYXRhLCBgJHttYWtlVXJsKEJBU0VfTElOSywgRW5kcG9pbnQudXNlcnMpfS8ke2F1dGhEYXRhLnVzZXJJZH0ke0VuZHBvaW50LnN0YXRpc3RpY3N9YCwge1xyXG4gICAgICBtZXRob2Q6IEhUVFBNZXRob2QuUFVULFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6IENvbnRlbnRUeXBlLmpzb24sXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHN0YXRpc3RpYyksXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRTdGF0aXN0aWMoYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhKTpcclxuICBQcm9taXNlPFN0YXRpc3RpY1Jlc3BvbnNlIHwgc3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEF1dGgoYXV0aERhdGEsIGAke21ha2VVcmwoQkFTRV9MSU5LLCBFbmRwb2ludC51c2Vycyl9LyR7YXV0aERhdGEudXNlcklkfSR7RW5kcG9pbnQuc3RhdGlzdGljc31gLCB7XHJcbiAgICAgIG1ldGhvZDogSFRUUE1ldGhvZC5HRVQsXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHJldHVybiBudWxsO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBnZXRTdGF0RGF0YUZvclJlbmRlcigpIHtcclxuICAgIGNvbnN0IHVzZXJEYXRhID0gdGhpcy5zdG9yYWdlLmdldFVzZXJJZERhdGEoKTtcclxuICAgIGxldCBkYWlseVN0YXQ6IFtzdHJpbmcsIERhaWx5U3RhdE9ial1bXSA9IFtdO1xyXG4gICAgY29uc3Qgc3RhdERhdGE6IFN0YXRpc3RpY1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRTdGF0aXN0aWModXNlckRhdGEpIGFzIFN0YXRpc3RpY1Jlc3BvbnNlO1xyXG4gICAgaWYgKHN0YXREYXRhKSB7XHJcbiAgICAgIGRhaWx5U3RhdCA9IG1ha2VEYWlseVN0YXQoc3RhdERhdGEpO1xyXG4gICAgICByZXR1cm4gZGFpbHlTdGF0O1xyXG4gICAgfSBkYWlseVN0YXQgPSBbXTtcclxuICAgIHJldHVybiBkYWlseVN0YXQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGZldGNoV2l0aEF1dGgoYXV0aERhdGE6IEF1dGhvcml6YXRpb25EYXRhLCB1cmw6IHN0cmluZywgb3B0aW9uczogRmV0Y2hPcHRpb25zKSB7XHJcbiAgICBsZXQgdG9rZW47XHJcbiAgICBpZiAoYXV0aERhdGEudG9rZW5FeHBpcmVzID4gRGF0ZS5ub3coKSkge1xyXG4gICAgICB0b2tlbiA9IGF1dGhEYXRhLnRva2VuO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbmV3VXNlckRhdGEgPSBhdXRoRGF0YTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldE5ld1VzZXJUb2tlbihhdXRoRGF0YSk7XHJcbiAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgbmV3VXNlckRhdGEudG9rZW4gPSByZXNwb25zZS50b2tlbjtcclxuICAgICAgICBuZXdVc2VyRGF0YS5yZWZyZXNoVG9rZW4gPSByZXNwb25zZS5yZWZyZXNoVG9rZW47XHJcbiAgICAgICAgbmV3VXNlckRhdGEudG9rZW5FeHBpcmVzID0gRGF0ZS5ub3coKSArIFRPS0VOX0xJRkVUSU1FX0lOX0hPVVJTICogNjAgKiA2MCAqIDEwMDA7XHJcblxyXG4gICAgICAgIHN0b3JhZ2Uuc2V0RGF0YSgnVXNlcklkJywgbmV3VXNlckRhdGEpO1xyXG4gICAgICAgIHRva2VuID0gbmV3VXNlckRhdGEudG9rZW47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcclxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgIHJldHVybiBmZXRjaCh1cmwsIGZldGNoT3B0aW9ucyk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYXBpOiBBcGkgPSBuZXcgQXBpKCk7XHJcblxyXG4vLyA0MDEgVW5hdXRob3JpemVkINC90LUg0YLQvtGCINGC0L7QutC10L1cclxuLy8gNDAzIEZvcmJpZGRlbiDQvdC1INGC0L7RgiDRjtC30LXRgNCw0LnQtNC4XHJcbi8vIDQwNCDRgyDRjtC30LXRgNCwINC90LXRgiDRgdGC0LDRgtC40YHRgtC40LrQuCBDb3VsZG4ndCBmaW5kIGEoYW4pIHN0YXRpc3RpYyB3aXRoOiBcInVzZXJJZDogNjMwYThiZjk4NmExZTgwMDc0OWU5NTU2XCJcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1341\n")},7114:(__unused_webpack_module,exports)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.storage = exports.Storage = void 0;\r\nclass Storage {\r\n    setData(key, value) {\r\n        if (typeof value === 'object') {\r\n            const strValue = JSON.stringify(value);\r\n            localStorage.setItem(key, strValue);\r\n        }\r\n        else {\r\n            localStorage.setItem(key, value);\r\n        }\r\n    }\r\n    getData(key) {\r\n        const data = localStorage.getItem(key);\r\n        if (data) {\r\n            const parsedData = JSON.parse(data);\r\n            return parsedData;\r\n        }\r\n        return false;\r\n    }\r\n    getUserIdData() {\r\n        const data = localStorage.getItem('UserId');\r\n        const parsedData = JSON.parse(data);\r\n        return parsedData;\r\n    }\r\n    checkData(key) {\r\n        const keyToCheck = localStorage.getItem(key);\r\n        if (keyToCheck)\r\n            return true;\r\n        return false;\r\n    }\r\n    clear() {\r\n        localStorage.clear();\r\n    }\r\n}\r\nexports.Storage = Storage;\r\nexports.storage = new Storage();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzExNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFFQSxNQUFhLE9BQU87SUFDbEIsT0FBTyxDQUFDLEdBQVcsRUFBRSxLQUFzQjtRQUN6QyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUM3QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3ZDLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ3JDO2FBQU07WUFDTCxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNsQztJQUNILENBQUM7SUFFRCxPQUFPLENBQUMsR0FBVztRQUNqQixNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksSUFBSSxFQUFFO1lBQ1IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNwQyxPQUFPLFVBQVUsQ0FBQztTQUNuQjtRQUFDLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxhQUFhO1FBQ1gsTUFBTSxJQUFJLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUUsQ0FBQztRQUM3QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxTQUFTLENBQUMsR0FBVztRQUNuQixNQUFNLFVBQVUsR0FBa0IsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM1RCxJQUFJLFVBQVU7WUFBRSxPQUFPLElBQUksQ0FBQztRQUM1QixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxLQUFLO1FBQ0gsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3ZCLENBQUM7Q0FDRjtBQWpDRCwwQkFpQ0M7QUFFWSxlQUFPLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy9TdG9yYWdlL1N0b3JhZ2UudHM/OTA1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdXRob3JpemF0aW9uRGF0YSB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFN0b3JhZ2Uge1xyXG4gIHNldERhdGEoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgfCBvYmplY3QpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGNvbnN0IHN0clZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHN0clZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0RGF0YShrZXk6IHN0cmluZykge1xyXG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgcmV0dXJuIHBhcnNlZERhdGE7XHJcbiAgICB9IHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGdldFVzZXJJZERhdGEoKTogQXV0aG9yaXphdGlvbkRhdGEge1xyXG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdVc2VySWQnKSE7XHJcbiAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgIHJldHVybiBwYXJzZWREYXRhO1xyXG4gIH1cclxuXHJcbiAgY2hlY2tEYXRhKGtleTogc3RyaW5nKTogQm9vbGVhbiB7XHJcbiAgICBjb25zdCBrZXlUb0NoZWNrOiBzdHJpbmcgfCBudWxsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgIGlmIChrZXlUb0NoZWNrKSByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCkge1xyXG4gICAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7114\n")},8909:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DayStatUI = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst findCorrectAnswersPercent_1 = __webpack_require__(8346);\r\nconst constants_1 = __webpack_require__(5004);\r\nclass DayStatUI {\r\n    constructor(data) {\r\n        this.wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['wrapper_day-stat'] });\r\n        [this.date, this.obj] = data;\r\n    }\r\n    drawFirstDayStat() {\r\n        const dayWrap = (0, createNode_1.default)({ tag: 'div', classes: ['todaystat-wrapper'] });\r\n        const textRow = (0, createNode_1.default)({ tag: 'div', classes: ['date-row'] });\r\n        const firstRow = (0, createNode_1.default)({ tag: 'div', classes: ['data-wrapper-row1'] });\r\n        const secondRow = (0, createNode_1.default)({ tag: 'div', classes: ['data-wrapper-row2'] });\r\n        const dayText = (0, createNode_1.default)({ tag: 'p', classes: ['first-day-text'], inner: 'Последний раз вы занимались' });\r\n        const dayData = (0, createNode_1.default)({ tag: 'p', classes: ['first-day-date'] });\r\n        const today = new Date();\r\n        if (this.date === today.toLocaleDateString()) {\r\n            dayData.innerHTML = 'Сегодня';\r\n        }\r\n        else {\r\n            dayData.innerHTML = `${this.date}`;\r\n        }\r\n        const corrWordAnsw = (0, findCorrectAnswersPercent_1.findCorrectAnswPercent)(this.obj.words.correctAnswers, this.obj.words.incorrectAnswers);\r\n        const corrAudioAnsw = (0, findCorrectAnswersPercent_1.findCorrectAnswPercent)(this.obj.games.audiocall.correctAnswers, this.obj.games.audiocall.incorrectAnswers);\r\n        const corrSprintAnsw = (0, findCorrectAnswersPercent_1.findCorrectAnswPercent)(this.obj.games.sprint.correctAnswers, this.obj.games.sprint.incorrectAnswers);\r\n        const wordWrap = this.createColumn('word', 'Слова', constants_1.WORDS_DATA_TEXT, [this.obj.words.newWords, this.obj.words.learnedWords, corrWordAnsw]);\r\n        const audioWrap = this.createColumn('word', 'Игра Audiocall', constants_1.GAMES_DATA_TEXT, [this.obj.games.audiocall.newWords, corrAudioAnsw, this.obj.games.audiocall.bestSeries]);\r\n        const sprintWrap = this.createColumn('word', 'Игра Sprint', constants_1.GAMES_DATA_TEXT, [this.obj.games.sprint.newWords, corrSprintAnsw, this.obj.games.sprint.bestSeries]);\r\n        textRow.append(dayText, dayData);\r\n        firstRow.append(textRow, audioWrap);\r\n        secondRow.append(wordWrap, sprintWrap);\r\n        dayWrap.append(firstRow, secondRow);\r\n        return dayWrap;\r\n    }\r\n    drawDayStat() {\r\n        const dayWrap = (0, createNode_1.default)({ tag: 'div', classes: ['daystat-wrapper'] });\r\n        const day = (0, createNode_1.default)({ tag: 'p', classes: ['date-text'], inner: `${this.date}` });\r\n        const corrWordAnsw = (0, findCorrectAnswersPercent_1.findCorrectAnswPercent)(this.obj.words.correctAnswers, this.obj.words.incorrectAnswers);\r\n        const corrAudioAnsw = (0, findCorrectAnswersPercent_1.findCorrectAnswPercent)(this.obj.games.audiocall.correctAnswers, this.obj.games.audiocall.incorrectAnswers);\r\n        const corrSprintAnsw = (0, findCorrectAnswersPercent_1.findCorrectAnswPercent)(this.obj.games.sprint.correctAnswers, this.obj.games.sprint.incorrectAnswers);\r\n        const wordWrap = this.createColumn('word', 'Слова', constants_1.WORDS_DATA_TEXT, [this.obj.words.newWords, this.obj.words.learnedWords, corrWordAnsw]);\r\n        const audioWrap = this.createColumn('word', 'Игра Audiocall', constants_1.GAMES_DATA_TEXT, [this.obj.games.audiocall.newWords, corrAudioAnsw, this.obj.games.audiocall.bestSeries]);\r\n        const sprintWrap = this.createColumn('word', 'Игра Sprint', constants_1.GAMES_DATA_TEXT, [this.obj.games.sprint.newWords, corrSprintAnsw, this.obj.games.sprint.bestSeries]);\r\n        dayWrap.append(day, wordWrap, audioWrap, sprintWrap);\r\n        return dayWrap;\r\n    }\r\n    createColumn(classData, inner, params, values) {\r\n        const wrap = (0, createNode_1.default)({ tag: 'div', classes: [`${classData}-wrapper`] });\r\n        const text = (0, createNode_1.default)({ tag: 'p', classes: [`${classData}-text`], inner: `${inner}` });\r\n        const list = (0, createNode_1.default)({ tag: 'div', classes: ['stat-data-items'] });\r\n        const listParams = [];\r\n        params.forEach((param) => {\r\n            const paramText = (0, createNode_1.default)({ tag: 'p', classes: ['stat-data-param'], inner: param });\r\n            listParams.push(paramText);\r\n        });\r\n        const listValues = [];\r\n        values.forEach((value) => {\r\n            const valueText = (0, createNode_1.default)({ tag: 'p', classes: ['stat-data-value'], inner: `${String(value)}` });\r\n            listValues.push(valueText);\r\n        });\r\n        for (let i = 0; i < params.length; i += 1) {\r\n            const listItem = (0, createNode_1.default)({ tag: 'div', classes: ['stat-data-item'] });\r\n            listItem.append(listParams[i], listValues[i]);\r\n            list.append(listItem);\r\n        }\r\n        wrap.append(text, list);\r\n        return wrap;\r\n    }\r\n}\r\nexports.DayStatUI = DayStatUI;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUssRUFBRSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNqSCxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQyxDQUFDO1FBRUgsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN6QyxNQUFNLFFBQVEsR0FBRyx3QkFBVSxFQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN6RSxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3ZCO1FBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0Y7QUFqR0QsOEJBaUdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL1VzZXJTdGF0aXN0aWMvRGF5U3RhdFVJLnRzPzE4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGFpbHlTdGF0T2JqIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCBjcmVhdGVOb2RlIGZyb20gJy4uL3V0aWxzL2NyZWF0ZU5vZGUnO1xyXG5pbXBvcnQgeyBmaW5kQ29ycmVjdEFuc3dQZXJjZW50IH0gZnJvbSAnLi4vdXRpbHMvZmluZENvcnJlY3RBbnN3ZXJzUGVyY2VudCc7XHJcbmltcG9ydCB7IFdPUkRTX0RBVEFfVEVYVCwgR0FNRVNfREFUQV9URVhUIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbnRzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBEYXlTdGF0VUkge1xyXG4gIG9iajogRGFpbHlTdGF0T2JqO1xyXG5cclxuICBkYXRlOiBzdHJpbmc7XHJcblxyXG4gIHdyYXBwZXI6IEhUTUxFbGVtZW50O1xyXG5cclxuICBjb25zdHJ1Y3RvcihkYXRhOiBbc3RyaW5nLCBEYWlseVN0YXRPYmpdKSB7XHJcbiAgICB0aGlzLndyYXBwZXIgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWyd3cmFwcGVyX2RheS1zdGF0J10gfSk7XHJcbiAgICBbdGhpcy5kYXRlLCB0aGlzLm9ial0gPSBkYXRhO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRyYXdGaXJzdERheVN0YXQoKSB7XHJcbiAgICBjb25zdCBkYXlXcmFwID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsndG9kYXlzdGF0LXdyYXBwZXInXSB9KTtcclxuICAgIGNvbnN0IHRleHRSb3cgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydkYXRlLXJvdyddIH0pO1xyXG4gICAgY29uc3QgZmlyc3RSb3cgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydkYXRhLXdyYXBwZXItcm93MSddIH0pO1xyXG4gICAgY29uc3Qgc2Vjb25kUm93ID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnZGF0YS13cmFwcGVyLXJvdzInXSB9KTtcclxuICAgIGNvbnN0IGRheVRleHQgPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFsnZmlyc3QtZGF5LXRleHQnXSwgaW5uZXI6ICfQn9C+0YHQu9C10LTQvdC40Lkg0YDQsNC3INCy0Ysg0LfQsNC90LjQvNCw0LvQuNGB0YwnIH0pO1xyXG4gICAgY29uc3QgZGF5RGF0YSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdwJywgY2xhc3NlczogWydmaXJzdC1kYXktZGF0ZSddIH0pO1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgaWYgKHRoaXMuZGF0ZSA9PT0gdG9kYXkudG9Mb2NhbGVEYXRlU3RyaW5nKCkpIHtcclxuICAgICAgZGF5RGF0YS5pbm5lckhUTUwgPSAn0KHQtdCz0L7QtNC90Y8nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF5RGF0YS5pbm5lckhUTUwgPSBgJHt0aGlzLmRhdGV9YDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvcnJXb3JkQW5zdyA9IGZpbmRDb3JyZWN0QW5zd1BlcmNlbnQoXHJcbiAgICAgIHRoaXMub2JqLndvcmRzLmNvcnJlY3RBbnN3ZXJzLFxyXG4gICAgICB0aGlzLm9iai53b3Jkcy5pbmNvcnJlY3RBbnN3ZXJzLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGNvcnJBdWRpb0Fuc3cgPSBmaW5kQ29ycmVjdEFuc3dQZXJjZW50KFxyXG4gICAgICB0aGlzLm9iai5nYW1lcy5hdWRpb2NhbGwuY29ycmVjdEFuc3dlcnMsXHJcbiAgICAgIHRoaXMub2JqLmdhbWVzLmF1ZGlvY2FsbC5pbmNvcnJlY3RBbnN3ZXJzLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGNvcnJTcHJpbnRBbnN3ID0gZmluZENvcnJlY3RBbnN3UGVyY2VudChcclxuICAgICAgdGhpcy5vYmouZ2FtZXMuc3ByaW50LmNvcnJlY3RBbnN3ZXJzLFxyXG4gICAgICB0aGlzLm9iai5nYW1lcy5zcHJpbnQuaW5jb3JyZWN0QW5zd2VycyxcclxuICAgICk7XHJcbiAgICBjb25zdCB3b3JkV3JhcCA9IHRoaXMuY3JlYXRlQ29sdW1uKCd3b3JkJywgJ9Ch0LvQvtCy0LAnLCBXT1JEU19EQVRBX1RFWFQsIFt0aGlzLm9iai53b3Jkcy5uZXdXb3JkcywgdGhpcy5vYmoud29yZHMubGVhcm5lZFdvcmRzLCBjb3JyV29yZEFuc3ddKTtcclxuICAgIGNvbnN0IGF1ZGlvV3JhcCA9IHRoaXMuY3JlYXRlQ29sdW1uKCd3b3JkJywgJ9CY0LPRgNCwIEF1ZGlvY2FsbCcsIEdBTUVTX0RBVEFfVEVYVCwgW3RoaXMub2JqLmdhbWVzLmF1ZGlvY2FsbC5uZXdXb3JkcywgY29yckF1ZGlvQW5zdywgdGhpcy5vYmouZ2FtZXMuYXVkaW9jYWxsLmJlc3RTZXJpZXNdKTtcclxuICAgIGNvbnN0IHNwcmludFdyYXAgPSB0aGlzLmNyZWF0ZUNvbHVtbignd29yZCcsICfQmNCz0YDQsCBTcHJpbnQnLCBHQU1FU19EQVRBX1RFWFQsIFt0aGlzLm9iai5nYW1lcy5zcHJpbnQubmV3V29yZHMsIGNvcnJTcHJpbnRBbnN3LCB0aGlzLm9iai5nYW1lcy5zcHJpbnQuYmVzdFNlcmllc10pO1xyXG4gICAgdGV4dFJvdy5hcHBlbmQoZGF5VGV4dCwgZGF5RGF0YSk7XHJcbiAgICBmaXJzdFJvdy5hcHBlbmQodGV4dFJvdywgYXVkaW9XcmFwKTtcclxuICAgIHNlY29uZFJvdy5hcHBlbmQod29yZFdyYXAsIHNwcmludFdyYXApO1xyXG4gICAgZGF5V3JhcC5hcHBlbmQoZmlyc3RSb3csIHNlY29uZFJvdyk7XHJcbiAgICByZXR1cm4gZGF5V3JhcDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBkcmF3RGF5U3RhdCgpIHtcclxuICAgIGNvbnN0IGRheVdyYXAgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydkYXlzdGF0LXdyYXBwZXInXSB9KTtcclxuICAgIGNvbnN0IGRheSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdwJywgY2xhc3NlczogWydkYXRlLXRleHQnXSwgaW5uZXI6IGAke3RoaXMuZGF0ZX1gIH0pO1xyXG4gICAgY29uc3QgY29ycldvcmRBbnN3ID0gZmluZENvcnJlY3RBbnN3UGVyY2VudChcclxuICAgICAgdGhpcy5vYmoud29yZHMuY29ycmVjdEFuc3dlcnMsXHJcbiAgICAgIHRoaXMub2JqLndvcmRzLmluY29ycmVjdEFuc3dlcnMsXHJcbiAgICApO1xyXG4gICAgY29uc3QgY29yckF1ZGlvQW5zdyA9IGZpbmRDb3JyZWN0QW5zd1BlcmNlbnQoXHJcbiAgICAgIHRoaXMub2JqLmdhbWVzLmF1ZGlvY2FsbC5jb3JyZWN0QW5zd2VycyxcclxuICAgICAgdGhpcy5vYmouZ2FtZXMuYXVkaW9jYWxsLmluY29ycmVjdEFuc3dlcnMsXHJcbiAgICApO1xyXG4gICAgY29uc3QgY29yclNwcmludEFuc3cgPSBmaW5kQ29ycmVjdEFuc3dQZXJjZW50KFxyXG4gICAgICB0aGlzLm9iai5nYW1lcy5zcHJpbnQuY29ycmVjdEFuc3dlcnMsXHJcbiAgICAgIHRoaXMub2JqLmdhbWVzLnNwcmludC5pbmNvcnJlY3RBbnN3ZXJzLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHdvcmRXcmFwID0gdGhpcy5jcmVhdGVDb2x1bW4oJ3dvcmQnLCAn0KHQu9C+0LLQsCcsIFdPUkRTX0RBVEFfVEVYVCwgW3RoaXMub2JqLndvcmRzLm5ld1dvcmRzLCB0aGlzLm9iai53b3Jkcy5sZWFybmVkV29yZHMsIGNvcnJXb3JkQW5zd10pO1xyXG4gICAgY29uc3QgYXVkaW9XcmFwID0gdGhpcy5jcmVhdGVDb2x1bW4oJ3dvcmQnLCAn0JjQs9GA0LAgQXVkaW9jYWxsJywgR0FNRVNfREFUQV9URVhULCBbdGhpcy5vYmouZ2FtZXMuYXVkaW9jYWxsLm5ld1dvcmRzLCBjb3JyQXVkaW9BbnN3LCB0aGlzLm9iai5nYW1lcy5hdWRpb2NhbGwuYmVzdFNlcmllc10pO1xyXG4gICAgY29uc3Qgc3ByaW50V3JhcCA9IHRoaXMuY3JlYXRlQ29sdW1uKCd3b3JkJywgJ9CY0LPRgNCwIFNwcmludCcsIEdBTUVTX0RBVEFfVEVYVCwgW3RoaXMub2JqLmdhbWVzLnNwcmludC5uZXdXb3JkcywgY29yclNwcmludEFuc3csIHRoaXMub2JqLmdhbWVzLnNwcmludC5iZXN0U2VyaWVzXSk7XHJcbiAgICBkYXlXcmFwLmFwcGVuZChkYXksIHdvcmRXcmFwLCBhdWRpb1dyYXAsIHNwcmludFdyYXApO1xyXG4gICAgcmV0dXJuIGRheVdyYXA7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUNvbHVtbihcclxuICAgIGNsYXNzRGF0YTogc3RyaW5nLFxyXG4gICAgaW5uZXI6IHN0cmluZyxcclxuICAgIHBhcmFtczogc3RyaW5nW10sXHJcbiAgICB2YWx1ZXM6IChudW1iZXIgfCBzdHJpbmcpW10sXHJcbiAgKSB7XHJcbiAgICBjb25zdCB3cmFwID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFtgJHtjbGFzc0RhdGF9LXdyYXBwZXJgXSB9KTtcclxuICAgIGNvbnN0IHRleHQgPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFtgJHtjbGFzc0RhdGF9LXRleHRgXSwgaW5uZXI6IGAke2lubmVyfWAgfSk7XHJcbiAgICBjb25zdCBsaXN0ID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnc3RhdC1kYXRhLWl0ZW1zJ10gfSk7XHJcbiAgICBjb25zdCBsaXN0UGFyYW1zOiBIVE1MRWxlbWVudFtdID0gW107XHJcbiAgICBwYXJhbXMuZm9yRWFjaCgocGFyYW06IHN0cmluZyk6IHZvaWQgPT4ge1xyXG4gICAgICBjb25zdCBwYXJhbVRleHQgPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFsnc3RhdC1kYXRhLXBhcmFtJ10sIGlubmVyOiBwYXJhbSB9KTtcclxuICAgICAgbGlzdFBhcmFtcy5wdXNoKHBhcmFtVGV4dCk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGxpc3RWYWx1ZXM6IEhUTUxFbGVtZW50W10gPSBbXTtcclxuICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKTogdm9pZCA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbHVlVGV4dDogSFRNTEVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFsnc3RhdC1kYXRhLXZhbHVlJ10sIGlubmVyOiBgJHtTdHJpbmcodmFsdWUpfWAgfSk7XHJcbiAgICAgIGxpc3RWYWx1ZXMucHVzaCh2YWx1ZVRleHQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgY29uc3QgbGlzdEl0ZW0gPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydzdGF0LWRhdGEtaXRlbSddIH0pO1xyXG4gICAgICBsaXN0SXRlbS5hcHBlbmQobGlzdFBhcmFtc1tpXSwgbGlzdFZhbHVlc1tpXSk7XHJcbiAgICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcclxuICAgIH1cclxuICAgIHdyYXAuYXBwZW5kKHRleHQsIGxpc3QpO1xyXG4gICAgcmV0dXJuIHdyYXA7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8909\n")},5021:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StatisticUI = void 0;\r\nconst api_1 = __webpack_require__(1341);\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst DayStatUI_1 = __webpack_require__(8909);\r\nclass StatisticUI {\r\n    // mainWrapper: HTMLElement;\r\n    constructor() {\r\n        this.api = api_1.api;\r\n        this.storage = Storage_1.storage;\r\n        // this.mainWrapper = createNode({ tag: 'div', classes: ['wrapper_statistic'] });\r\n        this.dailyWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['wrapper_daily-stat'] });\r\n    }\r\n    async drawDailyStat() {\r\n        this.dailyWrapper.innerHTML = '';\r\n        const data = await this.api.getStatDataForRender();\r\n        if (data.length) {\r\n            data.shift();\r\n            data.forEach((date) => {\r\n                const day = new DayStatUI_1.DayStatUI(date);\r\n                const card = day.drawDayStat();\r\n                this.dailyWrapper.append(card);\r\n            });\r\n            return this.dailyWrapper;\r\n        }\r\n        this.dailyWrapper.innerHTML = '<p>У вас пока нет статистики. Поиграйте в игру и она появится.</p>';\r\n        return this.dailyWrapper;\r\n    }\r\n    async drawTodayStat() {\r\n        const data = await this.api.getStatDataForRender();\r\n        console.log(data);\r\n        if (data.length) {\r\n            const dayUi = new DayStatUI_1.DayStatUI(data.shift());\r\n            const dailyCard = dayUi.drawFirstDayStat();\r\n            return dailyCard;\r\n        }\r\n        // this.dailyWrapper.innerHTML = '';\r\n        return this.dailyWrapper;\r\n    }\r\n}\r\nexports.StatisticUI = StatisticUI;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAyMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx3Q0FBbUM7QUFDbkMsNENBQTZDO0FBRTdDLGdFQUE2QztBQUM3Qyw4Q0FBd0M7QUFFeEMsTUFBYSxXQUFXO0lBT3RCLDRCQUE0QjtJQUU1QjtRQUNFLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBRyxDQUFDO1FBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxpQkFBTyxDQUFDO1FBQ3ZCLGlGQUFpRjtRQUNqRixJQUFJLENBQUMsWUFBWSxHQUFHLHdCQUFVLEVBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2xGLENBQUM7SUFFTSxLQUFLLENBQUMsYUFBYTtRQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDakMsTUFBTSxJQUFJLEdBQTZCLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQzdFLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDcEIsTUFBTSxHQUFHLEdBQUcsSUFBSSxxQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNoQyxNQUFNLElBQUksR0FBRyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQy9CLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2pDLENBQUMsQ0FBQyxDQUFDO1lBQ0gsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO1NBQzFCO1FBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEdBQUcsb0VBQW9FLENBQUM7UUFDckcsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzNCLENBQUM7SUFFTSxLQUFLLENBQUMsYUFBYTtRQUN4QixNQUFNLElBQUksR0FBNkIsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFDN0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixNQUFNLEtBQUssR0FBRyxJQUFJLHFCQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBNEIsQ0FBQyxDQUFDO1lBQ3BFLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQzNDLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0Qsb0NBQW9DO1FBQ3BDLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0NBQ0Y7QUExQ0Qsa0NBMENDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL1VzZXJTdGF0aXN0aWMvU3RhdGlzdGljVUkudHM/YTY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcGkgfSBmcm9tICcuLi9Nb2RlbC9hcGknO1xyXG5pbXBvcnQgeyBzdG9yYWdlIH0gZnJvbSAnLi4vU3RvcmFnZS9TdG9yYWdlJztcclxuaW1wb3J0IHsgRGFpbHlTdGF0T2JqIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCBjcmVhdGVOb2RlIGZyb20gJy4uL3V0aWxzL2NyZWF0ZU5vZGUnO1xyXG5pbXBvcnQgeyBEYXlTdGF0VUkgfSBmcm9tICcuL0RheVN0YXRVSSc7XHJcblxyXG5leHBvcnQgY2xhc3MgU3RhdGlzdGljVUkge1xyXG4gIGFwaTogdHlwZW9mIGFwaTtcclxuXHJcbiAgc3RvcmFnZTogdHlwZW9mIHN0b3JhZ2U7XHJcblxyXG4gIGRhaWx5V3JhcHBlcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIC8vIG1haW5XcmFwcGVyOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmFwaSA9IGFwaTtcclxuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAvLyB0aGlzLm1haW5XcmFwcGVyID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnd3JhcHBlcl9zdGF0aXN0aWMnXSB9KTtcclxuICAgIHRoaXMuZGFpbHlXcmFwcGVyID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnd3JhcHBlcl9kYWlseS1zdGF0J10gfSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZHJhd0RhaWx5U3RhdCgpIHtcclxuICAgIHRoaXMuZGFpbHlXcmFwcGVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgY29uc3QgZGF0YTogW3N0cmluZywgRGFpbHlTdGF0T2JqXVtdID0gYXdhaXQgdGhpcy5hcGkuZ2V0U3RhdERhdGFGb3JSZW5kZXIoKTtcclxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xyXG4gICAgICBkYXRhLnNoaWZ0KCk7XHJcbiAgICAgIGRhdGEuZm9yRWFjaCgoZGF0ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRheSA9IG5ldyBEYXlTdGF0VUkoZGF0ZSk7XHJcbiAgICAgICAgY29uc3QgY2FyZCA9IGRheS5kcmF3RGF5U3RhdCgpO1xyXG4gICAgICAgIHRoaXMuZGFpbHlXcmFwcGVyLmFwcGVuZChjYXJkKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhaWx5V3JhcHBlcjtcclxuICAgIH0gdGhpcy5kYWlseVdyYXBwZXIuaW5uZXJIVE1MID0gJzxwPtCjINCy0LDRgSDQv9C+0LrQsCDQvdC10YIg0YHRgtCw0YLQuNGB0YLQuNC60LguINCf0L7QuNCz0YDQsNC50YLQtSDQsiDQuNCz0YDRgyDQuCDQvtC90LAg0L/QvtGP0LLQuNGC0YHRjy48L3A+JztcclxuICAgIHJldHVybiB0aGlzLmRhaWx5V3JhcHBlcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBkcmF3VG9kYXlTdGF0KCkge1xyXG4gICAgY29uc3QgZGF0YTogW3N0cmluZywgRGFpbHlTdGF0T2JqXVtdID0gYXdhaXQgdGhpcy5hcGkuZ2V0U3RhdERhdGFGb3JSZW5kZXIoKTtcclxuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgaWYgKGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGRheVVpID0gbmV3IERheVN0YXRVSShkYXRhLnNoaWZ0KCkgYXMgW3N0cmluZywgRGFpbHlTdGF0T2JqXSk7XHJcbiAgICAgIGNvbnN0IGRhaWx5Q2FyZCA9IGRheVVpLmRyYXdGaXJzdERheVN0YXQoKTtcclxuICAgICAgcmV0dXJuIGRhaWx5Q2FyZDtcclxuICAgIH1cclxuICAgIC8vIHRoaXMuZGFpbHlXcmFwcGVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgcmV0dXJuIHRoaXMuZGFpbHlXcmFwcGVyO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5021\n")},7605:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UserStatistic = void 0;\r\n/* eslint-disable no-restricted-syntax */\r\nconst api_1 = __webpack_require__(1341);\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst enums_1 = __webpack_require__(8875);\r\nfunction getEmptyStatObject() {\r\n    const date = (new Date()).toLocaleDateString();\r\n    const statObj = {\r\n        learnedWords: 0,\r\n        optional: {\r\n            words: {\r\n                [date]: {\r\n                    newWords: 0,\r\n                    learnedWords: 0,\r\n                    correctAnswers: 0,\r\n                    incorrectAnswers: 0,\r\n                },\r\n            },\r\n            games: {\r\n                audiocall: {\r\n                    [date]: {\r\n                        newWords: 0,\r\n                        currentSeries: 0,\r\n                        bestSeries: 0,\r\n                        correctAnswers: 0,\r\n                        incorrectAnswers: 0,\r\n                    },\r\n                },\r\n                sprint: {\r\n                    [date]: {\r\n                        newWords: 0,\r\n                        currentSeries: 0,\r\n                        bestSeries: 0,\r\n                        correctAnswers: 0,\r\n                        incorrectAnswers: 0,\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    };\r\n    return statObj;\r\n}\r\nclass UserStatistic {\r\n    constructor(userData, currentGame, isCorrect, userWord) {\r\n        this.userData = userData;\r\n        this.currentGame = currentGame;\r\n        this.isCorrect = isCorrect;\r\n        this.learnedWords = 0;\r\n        this.words = {};\r\n        this.games = { audiocall: {}, sprint: {} };\r\n        this.gameNames = [enums_1.GAME.AUDIOCALL, enums_1.GAME.SPRINT];\r\n        this.userData = userData;\r\n        this.currentGame = currentGame;\r\n        this.isCorrect = isCorrect;\r\n        this.isWordNew = typeof userWord === 'string';\r\n    }\r\n    static async increaseLearnedWordsCount() {\r\n        const userData = Storage_1.storage.getUserIdData();\r\n        const statisticObj = await api_1.api.getStatistic(userData);\r\n        const date = (new Date()).toLocaleDateString();\r\n        if (statisticObj !== null && typeof statisticObj === 'object') {\r\n            statisticObj.learnedWords += 1;\r\n            if (!statisticObj.optional.words[date]) {\r\n                const emptyObject = getEmptyStatObject();\r\n                statisticObj.optional.words[date] = emptyObject.optional.words[date];\r\n                statisticObj.optional.games.audiocall[date] = emptyObject.optional.games.audiocall[date];\r\n                statisticObj.optional.games.sprint[date] = emptyObject.optional.games.sprint[date];\r\n            }\r\n            statisticObj.optional.words[date].learnedWords += 1;\r\n            const statistic = {\r\n                learnedWords: statisticObj.learnedWords,\r\n                optional: statisticObj.optional,\r\n            };\r\n            api_1.api.setStatistic(userData, statistic);\r\n            // return\r\n        }\r\n        else if (statisticObj === null) {\r\n            const statistic = getEmptyStatObject();\r\n            statistic.learnedWords += 1;\r\n            statistic.optional.words[date].learnedWords += 1;\r\n            api_1.api.setStatistic(userData, statistic);\r\n        }\r\n    }\r\n    static async decreaseLearnedWordsCount() {\r\n        const userData = Storage_1.storage.getUserIdData();\r\n        const statisticObj = await api_1.api.getStatistic(userData);\r\n        const date = (new Date()).toLocaleDateString();\r\n        if (statisticObj !== null && typeof statisticObj === 'object') {\r\n            if (statisticObj.learnedWords <= 0)\r\n                return;\r\n            statisticObj.learnedWords -= 1;\r\n            statisticObj.optional.words[date].learnedWords -= 1;\r\n            const statistic = {\r\n                learnedWords: statisticObj.learnedWords,\r\n                optional: statisticObj.optional,\r\n            };\r\n            api_1.api.setStatistic(userData, statistic);\r\n        }\r\n        else if (statisticObj === null) {\r\n            api_1.api.setStatistic(userData, getEmptyStatObject());\r\n        }\r\n    }\r\n    async update() {\r\n        const statisticObj = await api_1.api.getStatistic(this.userData);\r\n        if (typeof statisticObj === 'object' && statisticObj !== null) {\r\n            this.learnedWords = statisticObj.learnedWords;\r\n            this.words = statisticObj.optional.words;\r\n            this.games = statisticObj.optional.games;\r\n        }\r\n        this.updateStatistic();\r\n    }\r\n    updateStatistic() {\r\n        const date = (new Date()).toLocaleDateString();\r\n        // words\r\n        if (!this.words[date])\r\n            this.initDateInWordStatistic(date);\r\n        if (this.isWordNew)\r\n            this.words[date].newWords += 1;\r\n        if (this.isCorrect) {\r\n            this.words[date].correctAnswers += 1;\r\n        }\r\n        else {\r\n            this.words[date].incorrectAnswers += 1;\r\n        }\r\n        // games\r\n        for (const game of this.gameNames) {\r\n            if (!this.games[game][date])\r\n                this.initDateInGameStatistic(date, game);\r\n        }\r\n        const gameStatistic = this.games[this.currentGame][date];\r\n        if (this.isWordNew)\r\n            gameStatistic.newWords += 1;\r\n        if (this.isCorrect) {\r\n            gameStatistic.correctAnswers += 1;\r\n            gameStatistic.currentSeries += 1;\r\n            if (gameStatistic.currentSeries > gameStatistic.bestSeries) {\r\n                gameStatistic.bestSeries = gameStatistic.currentSeries;\r\n            }\r\n        }\r\n        else {\r\n            gameStatistic.incorrectAnswers += 1;\r\n            gameStatistic.currentSeries = 0;\r\n        }\r\n        this.sendStatistic();\r\n    }\r\n    sendStatistic() {\r\n        const test = api_1.api.setStatistic(this.userData, {\r\n            learnedWords: this.learnedWords,\r\n            optional: {\r\n                words: this.words,\r\n                games: this.games,\r\n            },\r\n        });\r\n        console.log(test);\r\n    }\r\n    initDateInWordStatistic(date) {\r\n        this.words[date] = {\r\n            newWords: 0,\r\n            learnedWords: 0,\r\n            correctAnswers: 0,\r\n            incorrectAnswers: 0,\r\n        };\r\n    }\r\n    initDateInGameStatistic(date, game) {\r\n        this.games[game][date] = {\r\n            newWords: 0,\r\n            currentSeries: 0,\r\n            bestSeries: 0,\r\n            correctAnswers: 0,\r\n            incorrectAnswers: 0,\r\n        };\r\n    }\r\n}\r\nexports.UserStatistic = UserStatistic;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixJQUFJLENBQUMsQ0FBQztZQUNwQyxhQUFhLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztTQUNqQztRQUVELElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRUQsYUFBYTtRQUNYLE1BQU0sSUFBSSxHQUFHLFNBQUcsQ0FBQyxZQUFZLENBQzNCLElBQUksQ0FBQyxRQUFRLEVBQ2I7WUFDRSxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDL0IsUUFBUSxFQUFFO2dCQUNSLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztnQkFDakIsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO2FBQ2xCO1NBQ0YsQ0FDRixDQUFDO1FBQ0YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQsdUJBQXVCLENBQUMsSUFBWTtRQUNsQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHO1lBQ2pCLFFBQVEsRUFBRSxDQUFDO1lBQ1gsWUFBWSxFQUFFLENBQUM7WUFDZixjQUFjLEVBQUUsQ0FBQztZQUNqQixnQkFBZ0IsRUFBRSxDQUFDO1NBQ3BCLENBQUM7SUFDSixDQUFDO0lBRUQsdUJBQXVCLENBQUMsSUFBWSxFQUFFLElBQVU7UUFDOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRztZQUN2QixRQUFRLEVBQUUsQ0FBQztZQUNYLGFBQWEsRUFBRSxDQUFDO1lBQ2hCLFVBQVUsRUFBRSxDQUFDO1lBQ2IsY0FBYyxFQUFFLENBQUM7WUFDakIsZ0JBQWdCLEVBQUUsQ0FBQztTQUNwQixDQUFDO0lBQ0osQ0FBQztDQUNGO0FBN0lELHNDQTZJQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy9Vc2VyU3RhdGlzdGljL1VzZXJTdGF0aXN0aWMudHM/NzAzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xyXG5pbXBvcnQgeyBhcGkgfSBmcm9tICcuLi9Nb2RlbC9hcGknO1xyXG5pbXBvcnQgeyBzdG9yYWdlIH0gZnJvbSAnLi4vU3RvcmFnZS9TdG9yYWdlJztcclxuaW1wb3J0IHsgR0FNRSB9IGZyb20gJy4uL3R5cGVzL2VudW1zJztcclxuaW1wb3J0IHtcclxuICBBdXRob3JpemF0aW9uRGF0YSwgR2FtZVN0YXRpc3RpYywgU3RhdGlzdGljLCBVc2VyV29yZCwgV29yZHNTdGF0aXN0aWMsXHJcbn0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XHJcblxyXG5mdW5jdGlvbiBnZXRFbXB0eVN0YXRPYmplY3QoKSB7XHJcbiAgY29uc3QgZGF0ZSA9IChuZXcgRGF0ZSgpKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICBjb25zdCBzdGF0T2JqOiBTdGF0aXN0aWMgPSB7XHJcbiAgICBsZWFybmVkV29yZHM6IDAsXHJcbiAgICBvcHRpb25hbDoge1xyXG4gICAgICB3b3Jkczoge1xyXG4gICAgICAgIFtkYXRlXToge1xyXG4gICAgICAgICAgbmV3V29yZHM6IDAsXHJcbiAgICAgICAgICBsZWFybmVkV29yZHM6IDAsXHJcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyczogMCxcclxuICAgICAgICAgIGluY29ycmVjdEFuc3dlcnM6IDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgZ2FtZXM6IHtcclxuICAgICAgICBhdWRpb2NhbGw6IHtcclxuICAgICAgICAgIFtkYXRlXToge1xyXG4gICAgICAgICAgICBuZXdXb3JkczogMCxcclxuICAgICAgICAgICAgY3VycmVudFNlcmllczogMCxcclxuICAgICAgICAgICAgYmVzdFNlcmllczogMCxcclxuICAgICAgICAgICAgY29ycmVjdEFuc3dlcnM6IDAsXHJcbiAgICAgICAgICAgIGluY29ycmVjdEFuc3dlcnM6IDAsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3ByaW50OiB7XHJcbiAgICAgICAgICBbZGF0ZV06IHtcclxuICAgICAgICAgICAgbmV3V29yZHM6IDAsXHJcbiAgICAgICAgICAgIGN1cnJlbnRTZXJpZXM6IDAsXHJcbiAgICAgICAgICAgIGJlc3RTZXJpZXM6IDAsXHJcbiAgICAgICAgICAgIGNvcnJlY3RBbnN3ZXJzOiAwLFxyXG4gICAgICAgICAgICBpbmNvcnJlY3RBbnN3ZXJzOiAwLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG4gIHJldHVybiBzdGF0T2JqO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVXNlclN0YXRpc3RpYyB7XHJcbiAgcHJpdmF0ZSBsZWFybmVkV29yZHM6IG51bWJlciA9IDA7XHJcblxyXG4gIHByaXZhdGUgd29yZHM6IFJlY29yZDxzdHJpbmcsIFdvcmRzU3RhdGlzdGljPiA9IHt9O1xyXG5cclxuICBwcml2YXRlIGdhbWVzOiB7IGF1ZGlvY2FsbDogUmVjb3JkPHN0cmluZywgR2FtZVN0YXRpc3RpYz4sXHJcbiAgICBzcHJpbnQ6IFJlY29yZDxzdHJpbmcsIEdhbWVTdGF0aXN0aWM+IH0gPSB7IGF1ZGlvY2FsbDoge30sIHNwcmludDoge30gfTtcclxuXHJcbiAgcHJpdmF0ZSBpc1dvcmROZXc6IGJvb2xlYW47XHJcblxyXG4gIHByaXZhdGUgZ2FtZU5hbWVzOiBHQU1FW10gPSBbR0FNRS5BVURJT0NBTEwsIEdBTUUuU1BSSU5UXTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHVzZXJEYXRhOiBBdXRob3JpemF0aW9uRGF0YSxcclxuICAgIHByaXZhdGUgY3VycmVudEdhbWU6IEdBTUUsXHJcbiAgICBwcml2YXRlIGlzQ29ycmVjdDogYm9vbGVhbixcclxuICAgIHVzZXJXb3JkOiBzdHJpbmcgfCBSZXF1aXJlZDxVc2VyV29yZD4sXHJcbiAgKSB7XHJcbiAgICB0aGlzLnVzZXJEYXRhID0gdXNlckRhdGE7XHJcbiAgICB0aGlzLmN1cnJlbnRHYW1lID0gY3VycmVudEdhbWU7XHJcbiAgICB0aGlzLmlzQ29ycmVjdCA9IGlzQ29ycmVjdDtcclxuICAgIHRoaXMuaXNXb3JkTmV3ID0gdHlwZW9mIHVzZXJXb3JkID09PSAnc3RyaW5nJztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyBpbmNyZWFzZUxlYXJuZWRXb3Jkc0NvdW50KCkge1xyXG4gICAgY29uc3QgdXNlckRhdGEgPSBzdG9yYWdlLmdldFVzZXJJZERhdGEoKTtcclxuICAgIGNvbnN0IHN0YXRpc3RpY09iaiA9IGF3YWl0IGFwaS5nZXRTdGF0aXN0aWModXNlckRhdGEpO1xyXG4gICAgY29uc3QgZGF0ZSA9IChuZXcgRGF0ZSgpKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICAgIGlmIChzdGF0aXN0aWNPYmogIT09IG51bGwgJiYgdHlwZW9mIHN0YXRpc3RpY09iaiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgc3RhdGlzdGljT2JqLmxlYXJuZWRXb3JkcyArPSAxO1xyXG4gICAgICBpZiAoIXN0YXRpc3RpY09iai5vcHRpb25hbC53b3Jkc1tkYXRlXSkge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5T2JqZWN0ID0gZ2V0RW1wdHlTdGF0T2JqZWN0KCk7XHJcbiAgICAgICAgc3RhdGlzdGljT2JqLm9wdGlvbmFsLndvcmRzW2RhdGVdID0gZW1wdHlPYmplY3Qub3B0aW9uYWwud29yZHNbZGF0ZV07XHJcbiAgICAgICAgc3RhdGlzdGljT2JqLm9wdGlvbmFsLmdhbWVzLmF1ZGlvY2FsbFtkYXRlXSA9IGVtcHR5T2JqZWN0Lm9wdGlvbmFsLmdhbWVzLmF1ZGlvY2FsbFtkYXRlXTtcclxuICAgICAgICBzdGF0aXN0aWNPYmoub3B0aW9uYWwuZ2FtZXMuc3ByaW50W2RhdGVdID0gZW1wdHlPYmplY3Qub3B0aW9uYWwuZ2FtZXMuc3ByaW50W2RhdGVdO1xyXG4gICAgICB9XHJcbiAgICAgIHN0YXRpc3RpY09iai5vcHRpb25hbC53b3Jkc1tkYXRlXS5sZWFybmVkV29yZHMgKz0gMTtcclxuICAgICAgY29uc3Qgc3RhdGlzdGljOiBTdGF0aXN0aWMgPSB7XHJcbiAgICAgICAgbGVhcm5lZFdvcmRzOiBzdGF0aXN0aWNPYmoubGVhcm5lZFdvcmRzLFxyXG4gICAgICAgIG9wdGlvbmFsOiBzdGF0aXN0aWNPYmoub3B0aW9uYWwsXHJcbiAgICAgIH07XHJcbiAgICAgIGFwaS5zZXRTdGF0aXN0aWModXNlckRhdGEsIHN0YXRpc3RpYyk7XHJcbiAgICAgIC8vIHJldHVyblxyXG4gICAgfSBlbHNlIGlmIChzdGF0aXN0aWNPYmogPT09IG51bGwpIHtcclxuICAgICAgY29uc3Qgc3RhdGlzdGljOiBTdGF0aXN0aWMgPSBnZXRFbXB0eVN0YXRPYmplY3QoKTtcclxuICAgICAgc3RhdGlzdGljLmxlYXJuZWRXb3JkcyArPSAxO1xyXG4gICAgICBzdGF0aXN0aWMub3B0aW9uYWwud29yZHNbZGF0ZV0ubGVhcm5lZFdvcmRzICs9IDE7XHJcbiAgICAgIGFwaS5zZXRTdGF0aXN0aWModXNlckRhdGEsIHN0YXRpc3RpYyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgZGVjcmVhc2VMZWFybmVkV29yZHNDb3VudCgpIHtcclxuICAgIGNvbnN0IHVzZXJEYXRhID0gc3RvcmFnZS5nZXRVc2VySWREYXRhKCk7XHJcbiAgICBjb25zdCBzdGF0aXN0aWNPYmogPSBhd2FpdCBhcGkuZ2V0U3RhdGlzdGljKHVzZXJEYXRhKTtcclxuICAgIGNvbnN0IGRhdGUgPSAobmV3IERhdGUoKSkudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICBpZiAoc3RhdGlzdGljT2JqICE9PSBudWxsICYmIHR5cGVvZiBzdGF0aXN0aWNPYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGlmIChzdGF0aXN0aWNPYmoubGVhcm5lZFdvcmRzIDw9IDApIHJldHVybjtcclxuICAgICAgc3RhdGlzdGljT2JqLmxlYXJuZWRXb3JkcyAtPSAxO1xyXG4gICAgICBzdGF0aXN0aWNPYmoub3B0aW9uYWwud29yZHNbZGF0ZV0ubGVhcm5lZFdvcmRzIC09IDE7XHJcbiAgICAgIGNvbnN0IHN0YXRpc3RpYzogU3RhdGlzdGljID0ge1xyXG4gICAgICAgIGxlYXJuZWRXb3Jkczogc3RhdGlzdGljT2JqLmxlYXJuZWRXb3JkcyxcclxuICAgICAgICBvcHRpb25hbDogc3RhdGlzdGljT2JqLm9wdGlvbmFsLFxyXG4gICAgICB9O1xyXG4gICAgICBhcGkuc2V0U3RhdGlzdGljKHVzZXJEYXRhLCBzdGF0aXN0aWMpO1xyXG4gICAgfSBlbHNlIGlmIChzdGF0aXN0aWNPYmogPT09IG51bGwpIHtcclxuICAgICAgYXBpLnNldFN0YXRpc3RpYyh1c2VyRGF0YSwgZ2V0RW1wdHlTdGF0T2JqZWN0KCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIHVwZGF0ZSgpIHtcclxuICAgIGNvbnN0IHN0YXRpc3RpY09iaiA9IGF3YWl0IGFwaS5nZXRTdGF0aXN0aWModGhpcy51c2VyRGF0YSk7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRpc3RpY09iaiA9PT0gJ29iamVjdCcgJiYgc3RhdGlzdGljT2JqICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMubGVhcm5lZFdvcmRzID0gc3RhdGlzdGljT2JqLmxlYXJuZWRXb3JkcztcclxuICAgICAgdGhpcy53b3JkcyA9IHN0YXRpc3RpY09iai5vcHRpb25hbC53b3JkcztcclxuICAgICAgdGhpcy5nYW1lcyA9IHN0YXRpc3RpY09iai5vcHRpb25hbC5nYW1lcztcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlU3RhdGlzdGljKCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVTdGF0aXN0aWMoKSB7XHJcbiAgICBjb25zdCBkYXRlID0gKG5ldyBEYXRlKCkpLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG5cclxuICAgIC8vIHdvcmRzXHJcbiAgICBpZiAoIXRoaXMud29yZHNbZGF0ZV0pIHRoaXMuaW5pdERhdGVJbldvcmRTdGF0aXN0aWMoZGF0ZSk7XHJcbiAgICBpZiAodGhpcy5pc1dvcmROZXcpIHRoaXMud29yZHNbZGF0ZV0ubmV3V29yZHMgKz0gMTtcclxuICAgIGlmICh0aGlzLmlzQ29ycmVjdCkge1xyXG4gICAgICB0aGlzLndvcmRzW2RhdGVdLmNvcnJlY3RBbnN3ZXJzICs9IDE7XHJcbiAgICB9IGVsc2UgeyB0aGlzLndvcmRzW2RhdGVdLmluY29ycmVjdEFuc3dlcnMgKz0gMTsgfVxyXG5cclxuICAgIC8vIGdhbWVzXHJcbiAgICBmb3IgKGNvbnN0IGdhbWUgb2YgdGhpcy5nYW1lTmFtZXMpIHtcclxuICAgICAgaWYgKCF0aGlzLmdhbWVzW2dhbWVdW2RhdGVdKSB0aGlzLmluaXREYXRlSW5HYW1lU3RhdGlzdGljKGRhdGUsIGdhbWUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZ2FtZVN0YXRpc3RpYyA9IHRoaXMuZ2FtZXNbdGhpcy5jdXJyZW50R2FtZV1bZGF0ZV07XHJcbiAgICBpZiAodGhpcy5pc1dvcmROZXcpIGdhbWVTdGF0aXN0aWMubmV3V29yZHMgKz0gMTtcclxuICAgIGlmICh0aGlzLmlzQ29ycmVjdCkge1xyXG4gICAgICBnYW1lU3RhdGlzdGljLmNvcnJlY3RBbnN3ZXJzICs9IDE7XHJcbiAgICAgIGdhbWVTdGF0aXN0aWMuY3VycmVudFNlcmllcyArPSAxO1xyXG4gICAgICBpZiAoZ2FtZVN0YXRpc3RpYy5jdXJyZW50U2VyaWVzID4gZ2FtZVN0YXRpc3RpYy5iZXN0U2VyaWVzKSB7XHJcbiAgICAgICAgZ2FtZVN0YXRpc3RpYy5iZXN0U2VyaWVzID0gZ2FtZVN0YXRpc3RpYy5jdXJyZW50U2VyaWVzO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBnYW1lU3RhdGlzdGljLmluY29ycmVjdEFuc3dlcnMgKz0gMTtcclxuICAgICAgZ2FtZVN0YXRpc3RpYy5jdXJyZW50U2VyaWVzID0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNlbmRTdGF0aXN0aWMoKTtcclxuICB9XHJcblxyXG4gIHNlbmRTdGF0aXN0aWMoKSB7XHJcbiAgICBjb25zdCB0ZXN0ID0gYXBpLnNldFN0YXRpc3RpYyhcclxuICAgICAgdGhpcy51c2VyRGF0YSxcclxuICAgICAge1xyXG4gICAgICAgIGxlYXJuZWRXb3JkczogdGhpcy5sZWFybmVkV29yZHMsXHJcbiAgICAgICAgb3B0aW9uYWw6IHtcclxuICAgICAgICAgIHdvcmRzOiB0aGlzLndvcmRzLFxyXG4gICAgICAgICAgZ2FtZXM6IHRoaXMuZ2FtZXMsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICk7XHJcbiAgICBjb25zb2xlLmxvZyh0ZXN0KTtcclxuICB9XHJcblxyXG4gIGluaXREYXRlSW5Xb3JkU3RhdGlzdGljKGRhdGU6IHN0cmluZykge1xyXG4gICAgdGhpcy53b3Jkc1tkYXRlXSA9IHtcclxuICAgICAgbmV3V29yZHM6IDAsXHJcbiAgICAgIGxlYXJuZWRXb3JkczogMCxcclxuICAgICAgY29ycmVjdEFuc3dlcnM6IDAsXHJcbiAgICAgIGluY29ycmVjdEFuc3dlcnM6IDAsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaW5pdERhdGVJbkdhbWVTdGF0aXN0aWMoZGF0ZTogc3RyaW5nLCBnYW1lOiBHQU1FKSB7XHJcbiAgICB0aGlzLmdhbWVzW2dhbWVdW2RhdGVdID0ge1xyXG4gICAgICBuZXdXb3JkczogMCxcclxuICAgICAgY3VycmVudFNlcmllczogMCxcclxuICAgICAgYmVzdFNlcmllczogMCxcclxuICAgICAgY29ycmVjdEFuc3dlcnM6IDAsXHJcbiAgICAgIGluY29ycmVjdEFuc3dlcnM6IDAsXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7605\n")},3584:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.wordController = exports.WordController = void 0;\r\nconst api_1 = __webpack_require__(1341);\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst UserStatistic_1 = __webpack_require__(7605);\r\nclass WordController {\r\n    constructor() {\r\n        this.api = api_1.api;\r\n        this.storage = Storage_1.storage;\r\n        this.isAuthorized = this.checkAuthorized();\r\n    }\r\n    checkAuthorized() {\r\n        if (localStorage.getItem('UserId') !== null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    createNewUserWord() {\r\n        return {\r\n            difficulty: 'easy',\r\n            optional: {\r\n                learned: false,\r\n                learnedDate: 'not learned',\r\n                correctAnswers: 0,\r\n                incorrectAnswers: 0,\r\n                correctSeries: 0,\r\n            },\r\n        };\r\n    }\r\n    createUserWordByAnswer(correct) {\r\n        const newWord = this.createNewUserWord();\r\n        if (correct) {\r\n            newWord.optional.correctAnswers = 1;\r\n            newWord.optional.correctSeries = 1;\r\n        }\r\n        else {\r\n            newWord.optional.incorrectAnswers = 1;\r\n        }\r\n        return newWord;\r\n    }\r\n    changeUserWordByAnswer(userWord, correct) {\r\n        const changedWord = userWord;\r\n        if (correct) {\r\n            changedWord.optional.correctAnswers += 1;\r\n            changedWord.optional.correctSeries += 1;\r\n            if ((changedWord.difficulty === 'easy' && changedWord.optional.correctSeries === 3)\r\n                || (changedWord.difficulty === 'hard' && changedWord.optional.correctSeries === 5)) {\r\n                changedWord.optional.learned = true;\r\n                changedWord.difficulty = 'easy';\r\n                UserStatistic_1.UserStatistic.increaseLearnedWordsCount();\r\n            }\r\n        }\r\n        else {\r\n            if ((changedWord.difficulty === 'easy' && changedWord.optional.correctSeries >= 3)\r\n                || (changedWord.difficulty === 'hard' && changedWord.optional.correctSeries >= 5)) {\r\n                if (changedWord.optional.learnedDate === (new Date()).toLocaleDateString()) {\r\n                    UserStatistic_1.UserStatistic.decreaseLearnedWordsCount();\r\n                }\r\n            }\r\n            changedWord.optional.correctSeries = 0;\r\n            changedWord.optional.incorrectAnswers += 1;\r\n            changedWord.optional.learned = false;\r\n        }\r\n        return changedWord;\r\n    }\r\n    async sendWordOnServer(wordId, correct, game) {\r\n        if (!this.isAuthorized)\r\n            return;\r\n        const userData = this.storage.getUserIdData();\r\n        const userWord = await this.api.getUserWordById(userData, wordId);\r\n        new UserStatistic_1.UserStatistic(userData, game, correct, userWord).update();\r\n        if (typeof userWord === 'object') {\r\n            const changedWord = this.changeUserWordByAnswer(userWord, correct);\r\n            this.api.changeUserWord(userData, wordId, { difficulty: changedWord.difficulty, optional: changedWord.optional });\r\n        }\r\n        else {\r\n            const newUserWord = this.createUserWordByAnswer(correct);\r\n            this.api.setUserWord(userData, wordId, newUserWord);\r\n        }\r\n    }\r\n    async getUserWords() {\r\n        const userData = this.storage.getUserIdData();\r\n        const userWords = await this.api.getUserWords(userData);\r\n        console.log(userWords);\r\n    }\r\n    async updateHardWord(difficulty, wordId) {\r\n        const userData = this.storage.getData('UserId');\r\n        const word = await api_1.api.getUserWordById(userData, wordId);\r\n        if (typeof word === 'object') {\r\n            word.difficulty = difficulty;\r\n            await api_1.api.changeUserWord(userData, wordId, { difficulty: word.difficulty, optional: word.optional });\r\n        }\r\n        else {\r\n            const newWord = this.createNewUserWord();\r\n            newWord.difficulty = difficulty;\r\n            await api_1.api.setUserWord(userData, wordId, newWord);\r\n        }\r\n    }\r\n    async updateLearnedWord(learned, wordId) {\r\n        const data = this.storage.getData('UserId');\r\n        const word = await api_1.api.getUserWordById(data, wordId);\r\n        if (typeof word === 'object') {\r\n            word.optional.learned = learned;\r\n            if (!learned) {\r\n                word.optional.correctSeries = 0;\r\n                // only words learned today are removed from the statistics\r\n                if (word.optional.learnedDate === (new Date()).toLocaleDateString()) {\r\n                    UserStatistic_1.UserStatistic.decreaseLearnedWordsCount();\r\n                }\r\n            }\r\n            else {\r\n                UserStatistic_1.UserStatistic.increaseLearnedWordsCount();\r\n                word.optional.learnedDate = (new Date()).toLocaleDateString();\r\n            }\r\n            word.difficulty = 'easy';\r\n            await api_1.api.changeUserWord(data, wordId, { difficulty: word.difficulty, optional: word.optional });\r\n        }\r\n        else {\r\n            const newWord = this.createNewUserWord();\r\n            newWord.optional.learned = learned;\r\n            if (learned) {\r\n                UserStatistic_1.UserStatistic.increaseLearnedWordsCount();\r\n                newWord.optional.learnedDate = new Date().toLocaleDateString();\r\n            }\r\n            await api_1.api.setUserWord(data, wordId, newWord);\r\n        }\r\n    }\r\n    async updateUserWordInfo(wordId) {\r\n        const data = this.storage.getData('UserId');\r\n        const word = await api_1.api.getUserWordById(data, wordId);\r\n        const resp = { difficulty: word.difficulty, learned: word.optional.learned };\r\n        return resp;\r\n    }\r\n    async getUserBookWords() {\r\n        const logined = this.storage.getData('UserId');\r\n        const totalWords = await this.api.getTotalUserWords(logined, '{\"$and\":[{\"userWord.difficulty\":\"hard\", \"userWord.optional.learned\":false}]}');\r\n        if (typeof totalWords === 'number') {\r\n            const newData = await this.api.getAggregatedUserWords(logined, { wordsPerPage: String(totalWords) }, '{\"$and\":[{\"userWord.difficulty\":\"hard\", \"userWord.optional.learned\":false}]}');\r\n            return newData;\r\n        }\r\n        return String(totalWords);\r\n    }\r\n}\r\nexports.WordController = WordController;\r\nexports.wordController = new WordController();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUksRUFBRSxNQUFNLENBQWEsQ0FBQztRQUMzRSxNQUFNLElBQUksR0FBRyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzdFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVNLEtBQUssQ0FBQyxnQkFBZ0I7UUFDM0IsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDL0MsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUNqRCxPQUFPLEVBQ1AsOEVBQThFLENBQy9FLENBQUM7UUFDRixJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsRUFBRTtZQUNsQyxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQ25ELE9BQU8sRUFDUCxFQUFFLFlBQVksRUFBRSxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFDcEMsOEVBQThFLENBQ3ZELENBQUM7WUFDMUIsT0FBTyxPQUFPLENBQUM7U0FDaEI7UUFBQyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5QixDQUFDO0NBQ0Y7QUFwS0Qsd0NBb0tDO0FBRVksc0JBQWMsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL1dvcmRDb250cm9sbGVyL1dvcmRDb250cm9sbGVyLnRzP2Q3OTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBpIH0gZnJvbSAnLi4vTW9kZWwvYXBpJztcclxuaW1wb3J0IHsgc3RvcmFnZSB9IGZyb20gJy4uL1N0b3JhZ2UvU3RvcmFnZSc7XHJcbmltcG9ydCB7IEdBTUUgfSBmcm9tICcuLi90eXBlcy9lbnVtcyc7XHJcbmltcG9ydCB7IFVzZXJBZ2dyZWdhdGVkV29yZCwgVXNlcldvcmQgfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgVXNlclN0YXRpc3RpYyB9IGZyb20gJy4uL1VzZXJTdGF0aXN0aWMvVXNlclN0YXRpc3RpYyc7XHJcblxyXG5leHBvcnQgY2xhc3MgV29yZENvbnRyb2xsZXIge1xyXG4gIGFwaTogdHlwZW9mIGFwaTtcclxuXHJcbiAgc3RvcmFnZTogdHlwZW9mIHN0b3JhZ2U7XHJcblxyXG4gIGlzQXV0aG9yaXplZDogYm9vbGVhbjtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmFwaSA9IGFwaTtcclxuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICB0aGlzLmlzQXV0aG9yaXplZCA9IHRoaXMuY2hlY2tBdXRob3JpemVkKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNoZWNrQXV0aG9yaXplZCgpOiBib29sZWFuIHtcclxuICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnVXNlcklkJykgIT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZU5ld1VzZXJXb3JkKCk6IFVzZXJXb3JkIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGRpZmZpY3VsdHk6ICdlYXN5JyxcclxuICAgICAgb3B0aW9uYWw6IHtcclxuICAgICAgICBsZWFybmVkOiBmYWxzZSxcclxuICAgICAgICBsZWFybmVkRGF0ZTogJ25vdCBsZWFybmVkJyxcclxuICAgICAgICBjb3JyZWN0QW5zd2VyczogMCxcclxuICAgICAgICBpbmNvcnJlY3RBbnN3ZXJzOiAwLFxyXG4gICAgICAgIGNvcnJlY3RTZXJpZXM6IDAsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVVc2VyV29yZEJ5QW5zd2VyKGNvcnJlY3Q6IGJvb2xlYW4pOiBPbWl0PFVzZXJXb3JkLCAnaWQnIHwgJ3dvcmRJZCc+IHtcclxuICAgIGNvbnN0IG5ld1dvcmQ6IFVzZXJXb3JkID0gdGhpcy5jcmVhdGVOZXdVc2VyV29yZCgpO1xyXG4gICAgaWYgKGNvcnJlY3QpIHtcclxuICAgICAgbmV3V29yZC5vcHRpb25hbC5jb3JyZWN0QW5zd2VycyA9IDE7XHJcbiAgICAgIG5ld1dvcmQub3B0aW9uYWwuY29ycmVjdFNlcmllcyA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXdXb3JkLm9wdGlvbmFsLmluY29ycmVjdEFuc3dlcnMgPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1dvcmQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNoYW5nZVVzZXJXb3JkQnlBbnN3ZXIodXNlcldvcmQ6IFVzZXJXb3JkLCBjb3JyZWN0OiBib29sZWFuKTogVXNlcldvcmQge1xyXG4gICAgY29uc3QgY2hhbmdlZFdvcmQgPSB1c2VyV29yZDtcclxuICAgIGlmIChjb3JyZWN0KSB7XHJcbiAgICAgIGNoYW5nZWRXb3JkLm9wdGlvbmFsLmNvcnJlY3RBbnN3ZXJzICs9IDE7XHJcbiAgICAgIGNoYW5nZWRXb3JkLm9wdGlvbmFsLmNvcnJlY3RTZXJpZXMgKz0gMTtcclxuICAgICAgaWYgKChjaGFuZ2VkV29yZC5kaWZmaWN1bHR5ID09PSAnZWFzeScgJiYgY2hhbmdlZFdvcmQub3B0aW9uYWwuY29ycmVjdFNlcmllcyA9PT0gMylcclxuICAgICAgfHwgKGNoYW5nZWRXb3JkLmRpZmZpY3VsdHkgPT09ICdoYXJkJyAmJiBjaGFuZ2VkV29yZC5vcHRpb25hbC5jb3JyZWN0U2VyaWVzID09PSA1KSkge1xyXG4gICAgICAgIGNoYW5nZWRXb3JkLm9wdGlvbmFsLmxlYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgIGNoYW5nZWRXb3JkLmRpZmZpY3VsdHkgPSAnZWFzeSc7XHJcbiAgICAgICAgVXNlclN0YXRpc3RpYy5pbmNyZWFzZUxlYXJuZWRXb3Jkc0NvdW50KCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICgoY2hhbmdlZFdvcmQuZGlmZmljdWx0eSA9PT0gJ2Vhc3knICYmIGNoYW5nZWRXb3JkLm9wdGlvbmFsLmNvcnJlY3RTZXJpZXMgPj0gMylcclxuICAgICAgfHwgKGNoYW5nZWRXb3JkLmRpZmZpY3VsdHkgPT09ICdoYXJkJyAmJiBjaGFuZ2VkV29yZC5vcHRpb25hbC5jb3JyZWN0U2VyaWVzID49IDUpKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZWRXb3JkLm9wdGlvbmFsLmxlYXJuZWREYXRlID09PSAobmV3IERhdGUoKSkudG9Mb2NhbGVEYXRlU3RyaW5nKCkpIHtcclxuICAgICAgICAgIFVzZXJTdGF0aXN0aWMuZGVjcmVhc2VMZWFybmVkV29yZHNDb3VudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjaGFuZ2VkV29yZC5vcHRpb25hbC5jb3JyZWN0U2VyaWVzID0gMDtcclxuICAgICAgY2hhbmdlZFdvcmQub3B0aW9uYWwuaW5jb3JyZWN0QW5zd2VycyArPSAxO1xyXG4gICAgICBjaGFuZ2VkV29yZC5vcHRpb25hbC5sZWFybmVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbmdlZFdvcmQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgc2VuZFdvcmRPblNlcnZlcih3b3JkSWQ6IHN0cmluZywgY29ycmVjdDogYm9vbGVhbiwgZ2FtZTogR0FNRSkge1xyXG4gICAgaWYgKCF0aGlzLmlzQXV0aG9yaXplZCkgcmV0dXJuO1xyXG4gICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnN0b3JhZ2UuZ2V0VXNlcklkRGF0YSgpO1xyXG4gICAgY29uc3QgdXNlcldvcmQgPSBhd2FpdCB0aGlzLmFwaS5nZXRVc2VyV29yZEJ5SWQodXNlckRhdGEsIHdvcmRJZCk7XHJcbiAgICBuZXcgVXNlclN0YXRpc3RpYyh1c2VyRGF0YSwgZ2FtZSwgY29ycmVjdCwgdXNlcldvcmQpLnVwZGF0ZSgpO1xyXG4gICAgaWYgKHR5cGVvZiB1c2VyV29yZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgY29uc3QgY2hhbmdlZFdvcmQgPSB0aGlzLmNoYW5nZVVzZXJXb3JkQnlBbnN3ZXIodXNlcldvcmQsIGNvcnJlY3QpO1xyXG4gICAgICB0aGlzLmFwaS5jaGFuZ2VVc2VyV29yZChcclxuICAgICAgICB1c2VyRGF0YSxcclxuICAgICAgICB3b3JkSWQsXHJcbiAgICAgICAgeyBkaWZmaWN1bHR5OiBjaGFuZ2VkV29yZC5kaWZmaWN1bHR5LCBvcHRpb25hbDogY2hhbmdlZFdvcmQub3B0aW9uYWwgfSxcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG5ld1VzZXJXb3JkID0gdGhpcy5jcmVhdGVVc2VyV29yZEJ5QW5zd2VyKGNvcnJlY3QpO1xyXG4gICAgICB0aGlzLmFwaS5zZXRVc2VyV29yZCh1c2VyRGF0YSwgd29yZElkLCBuZXdVc2VyV29yZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2V0VXNlcldvcmRzKCkge1xyXG4gICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnN0b3JhZ2UuZ2V0VXNlcklkRGF0YSgpO1xyXG4gICAgY29uc3QgdXNlcldvcmRzID0gYXdhaXQgdGhpcy5hcGkuZ2V0VXNlcldvcmRzKHVzZXJEYXRhKTtcclxuICAgIGNvbnNvbGUubG9nKHVzZXJXb3Jkcyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgdXBkYXRlSGFyZFdvcmQoZGlmZmljdWx0eTogJ2Vhc3knIHwgJ2hhcmQnLCB3b3JkSWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnN0b3JhZ2UuZ2V0RGF0YSgnVXNlcklkJyk7XHJcbiAgICBjb25zdCB3b3JkOiBVc2VyV29yZCA9IGF3YWl0IGFwaS5nZXRVc2VyV29yZEJ5SWQodXNlckRhdGEsIHdvcmRJZCkgYXMgVXNlcldvcmQ7XHJcbiAgICBpZiAodHlwZW9mIHdvcmQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHdvcmQuZGlmZmljdWx0eSA9IGRpZmZpY3VsdHk7XHJcbiAgICAgIGF3YWl0IGFwaS5jaGFuZ2VVc2VyV29yZChcclxuICAgICAgICB1c2VyRGF0YSxcclxuICAgICAgICB3b3JkSWQsXHJcbiAgICAgICAgeyBkaWZmaWN1bHR5OiB3b3JkLmRpZmZpY3VsdHksIG9wdGlvbmFsOiB3b3JkLm9wdGlvbmFsIH0sXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBuZXdXb3JkOiBVc2VyV29yZCA9IHRoaXMuY3JlYXRlTmV3VXNlcldvcmQoKTtcclxuICAgICAgbmV3V29yZC5kaWZmaWN1bHR5ID0gZGlmZmljdWx0eTtcclxuICAgICAgYXdhaXQgYXBpLnNldFVzZXJXb3JkKHVzZXJEYXRhLCB3b3JkSWQsIG5ld1dvcmQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIHVwZGF0ZUxlYXJuZWRXb3JkKGxlYXJuZWQ6IGJvb2xlYW4sIHdvcmRJZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zdG9yYWdlLmdldERhdGEoJ1VzZXJJZCcpO1xyXG4gICAgY29uc3Qgd29yZCA9IGF3YWl0IGFwaS5nZXRVc2VyV29yZEJ5SWQoZGF0YSwgd29yZElkKTtcclxuICAgIGlmICh0eXBlb2Ygd29yZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgd29yZC5vcHRpb25hbC5sZWFybmVkID0gbGVhcm5lZDtcclxuICAgICAgaWYgKCFsZWFybmVkKSB7XHJcbiAgICAgICAgd29yZC5vcHRpb25hbC5jb3JyZWN0U2VyaWVzID0gMDtcclxuICAgICAgICAvLyBvbmx5IHdvcmRzIGxlYXJuZWQgdG9kYXkgYXJlIHJlbW92ZWQgZnJvbSB0aGUgc3RhdGlzdGljc1xyXG4gICAgICAgIGlmICh3b3JkLm9wdGlvbmFsLmxlYXJuZWREYXRlID09PSAobmV3IERhdGUoKSkudG9Mb2NhbGVEYXRlU3RyaW5nKCkpIHtcclxuICAgICAgICAgIFVzZXJTdGF0aXN0aWMuZGVjcmVhc2VMZWFybmVkV29yZHNDb3VudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBVc2VyU3RhdGlzdGljLmluY3JlYXNlTGVhcm5lZFdvcmRzQ291bnQoKTtcclxuICAgICAgICB3b3JkLm9wdGlvbmFsLmxlYXJuZWREYXRlID0gKG5ldyBEYXRlKCkpLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICB9XHJcbiAgICAgIHdvcmQuZGlmZmljdWx0eSA9ICdlYXN5JztcclxuICAgICAgYXdhaXQgYXBpLmNoYW5nZVVzZXJXb3JkKFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgd29yZElkLFxyXG4gICAgICAgIHsgZGlmZmljdWx0eTogd29yZC5kaWZmaWN1bHR5LCBvcHRpb25hbDogd29yZC5vcHRpb25hbCB9LFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbmV3V29yZDogVXNlcldvcmQgPSB0aGlzLmNyZWF0ZU5ld1VzZXJXb3JkKCk7XHJcbiAgICAgIG5ld1dvcmQub3B0aW9uYWwubGVhcm5lZCA9IGxlYXJuZWQ7XHJcbiAgICAgIGlmIChsZWFybmVkKSB7XHJcbiAgICAgICAgVXNlclN0YXRpc3RpYy5pbmNyZWFzZUxlYXJuZWRXb3Jkc0NvdW50KCk7XHJcbiAgICAgICAgbmV3V29yZC5vcHRpb25hbC5sZWFybmVkRGF0ZSA9IG5ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgYXdhaXQgYXBpLnNldFVzZXJXb3JkKGRhdGEsIHdvcmRJZCwgbmV3V29yZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgdXBkYXRlVXNlcldvcmRJbmZvKHdvcmRJZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zdG9yYWdlLmdldERhdGEoJ1VzZXJJZCcpO1xyXG4gICAgY29uc3Qgd29yZDogVXNlcldvcmQgPSBhd2FpdCBhcGkuZ2V0VXNlcldvcmRCeUlkKGRhdGEsIHdvcmRJZCkgYXMgVXNlcldvcmQ7XHJcbiAgICBjb25zdCByZXNwID0geyBkaWZmaWN1bHR5OiB3b3JkLmRpZmZpY3VsdHksIGxlYXJuZWQ6IHdvcmQub3B0aW9uYWwubGVhcm5lZCB9O1xyXG4gICAgcmV0dXJuIHJlc3A7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZ2V0VXNlckJvb2tXb3JkcygpIHtcclxuICAgIGNvbnN0IGxvZ2luZWQgPSB0aGlzLnN0b3JhZ2UuZ2V0RGF0YSgnVXNlcklkJyk7XHJcbiAgICBjb25zdCB0b3RhbFdvcmRzID0gYXdhaXQgdGhpcy5hcGkuZ2V0VG90YWxVc2VyV29yZHMoXHJcbiAgICAgIGxvZ2luZWQsXHJcbiAgICAgICd7XCIkYW5kXCI6W3tcInVzZXJXb3JkLmRpZmZpY3VsdHlcIjpcImhhcmRcIiwgXCJ1c2VyV29yZC5vcHRpb25hbC5sZWFybmVkXCI6ZmFsc2V9XX0nLFxyXG4gICAgKTtcclxuICAgIGlmICh0eXBlb2YgdG90YWxXb3JkcyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgY29uc3QgbmV3RGF0YSA9IGF3YWl0IHRoaXMuYXBpLmdldEFnZ3JlZ2F0ZWRVc2VyV29yZHMoXHJcbiAgICAgICAgbG9naW5lZCxcclxuICAgICAgICB7IHdvcmRzUGVyUGFnZTogU3RyaW5nKHRvdGFsV29yZHMpIH0sXHJcbiAgICAgICAgJ3tcIiRhbmRcIjpbe1widXNlcldvcmQuZGlmZmljdWx0eVwiOlwiaGFyZFwiLCBcInVzZXJXb3JkLm9wdGlvbmFsLmxlYXJuZWRcIjpmYWxzZX1dfScsXHJcbiAgICAgICkgYXMgVXNlckFnZ3JlZ2F0ZWRXb3JkW107XHJcbiAgICAgIHJldHVybiBuZXdEYXRhO1xyXG4gICAgfSByZXR1cm4gU3RyaW5nKHRvdGFsV29yZHMpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHdvcmRDb250cm9sbGVyID0gbmV3IFdvcmRDb250cm9sbGVyKCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3584\n")},9775:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Answer = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nclass Answer {\r\n    constructor(word, number, isCorrect, callback) {\r\n        this.eventHandler = () => {\r\n            console.log('eventHandler');\r\n            this.addEndStageStyleByClick();\r\n            this.callback(this);\r\n        };\r\n        this.word = word;\r\n        this.number = number;\r\n        this.isCorrect = isCorrect;\r\n        this.callback = callback;\r\n        this.answerNumberSpan = (0, createNode_1.default)({ tag: 'span', classes: ['answer__number'], inner: String(this.number) });\r\n        this.answerTextSpan = (0, createNode_1.default)({ tag: 'span', classes: ['answer__text'], inner: this.word.wordTranslate });\r\n        this.div = (0, createNode_1.default)({ tag: 'div', classes: ['answer'], atributesAdnValues: [['data-id', this.word.id]] });\r\n        this.div.append(this.answerNumberSpan, this.answerTextSpan);\r\n        this.div.addEventListener('click', this.eventHandler);\r\n    }\r\n    addTextOpacity() {\r\n        if (this.isCorrect)\r\n            return;\r\n        this.answerTextSpan.style.opacity = '0.5';\r\n    }\r\n    addEndStageStyleByClick() {\r\n        if (this.isCorrect) {\r\n            this.answerNumberSpan.innerText = '✔';\r\n            this.answerNumberSpan.classList.add('checked');\r\n        }\r\n        else {\r\n            this.answerTextSpan.style.textDecoration = 'line-through';\r\n        }\r\n    }\r\n    addEndStageStyleByKeyboard(answer) {\r\n        console.log(answer === this);\r\n        if (answer === this)\r\n            this.addEndStageStyleByClick();\r\n    }\r\n    removeListener() {\r\n        this.div.removeEventListener('click', this.eventHandler);\r\n        this.addTextOpacity();\r\n    }\r\n}\r\nexports.Answer = Answer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc3NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxnRUFBNkM7QUFFN0MsTUFBYSxNQUFNO0lBZWpCLFlBQVksSUFBVSxFQUFFLE1BQWMsRUFBRSxTQUFrQixFQUFFLFFBQWtDO1FBWXRGLGlCQUFZLEdBQUcsR0FBRyxFQUFFO1lBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7WUFDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QixDQUFDLENBQUM7UUFmQSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsd0JBQVUsRUFBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDN0csSUFBSSxDQUFDLGNBQWMsR0FBRyx3QkFBVSxFQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQyxjQUFjLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1FBQzdHLElBQUksQ0FBQyxHQUFHLEdBQUcsd0JBQVUsRUFBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzVHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFRTyxjQUFjO1FBQ3BCLElBQUksSUFBSSxDQUFDLFNBQVM7WUFBRSxPQUFPO1FBQzNCLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7SUFDNUMsQ0FBQztJQUVPLHVCQUF1QjtRQUM3QixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUM7WUFDdEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDaEQ7YUFBTTtZQUNMLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7U0FDM0Q7SUFDSCxDQUFDO0lBRU0sMEJBQTBCLENBQUMsTUFBYztRQUM5QyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQztRQUM3QixJQUFJLE1BQU0sS0FBSyxJQUFJO1lBQUUsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUVNLGNBQWM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN4QixDQUFDO0NBQ0Y7QUF4REQsd0JBd0RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL2F1ZGlvY2FsbC9hbnN3ZXIudHM/MjE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXb3JkIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCBjcmVhdGVOb2RlIGZyb20gJy4uL3V0aWxzL2NyZWF0ZU5vZGUnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFuc3dlciB7XHJcbiAgcHJpdmF0ZSB3b3JkOiBXb3JkO1xyXG5cclxuICBwdWJsaWMgbnVtYmVyOiBudW1iZXI7XHJcblxyXG4gIHB1YmxpYyBpc0NvcnJlY3Q6IGJvb2xlYW47XHJcblxyXG4gIHByaXZhdGUgY2FsbGJhY2s6IChhbnN3ZXI6IEFuc3dlcikgPT4gdm9pZDtcclxuXHJcbiAgcHVibGljIGRpdjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgYW5zd2VyTnVtYmVyU3BhbjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgYW5zd2VyVGV4dFNwYW46IEhUTUxFbGVtZW50O1xyXG5cclxuICBjb25zdHJ1Y3Rvcih3b3JkOiBXb3JkLCBudW1iZXI6IG51bWJlciwgaXNDb3JyZWN0OiBib29sZWFuLCBjYWxsYmFjazogKGFuc3dlcjogQW5zd2VyKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLndvcmQgPSB3b3JkO1xyXG4gICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XHJcbiAgICB0aGlzLmlzQ29ycmVjdCA9IGlzQ29ycmVjdDtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMuYW5zd2VyTnVtYmVyU3BhbiA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdzcGFuJywgY2xhc3NlczogWydhbnN3ZXJfX251bWJlciddLCBpbm5lcjogU3RyaW5nKHRoaXMubnVtYmVyKSB9KTtcclxuICAgIHRoaXMuYW5zd2VyVGV4dFNwYW4gPSBjcmVhdGVOb2RlKHsgdGFnOiAnc3BhbicsIGNsYXNzZXM6IFsnYW5zd2VyX190ZXh0J10sIGlubmVyOiB0aGlzLndvcmQud29yZFRyYW5zbGF0ZSB9KTtcclxuICAgIHRoaXMuZGl2ID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnYW5zd2VyJ10sIGF0cmlidXRlc0FkblZhbHVlczogW1snZGF0YS1pZCcsIHRoaXMud29yZC5pZF1dIH0pO1xyXG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuYW5zd2VyTnVtYmVyU3BhbiwgdGhpcy5hbnN3ZXJUZXh0U3Bhbik7XHJcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZXZlbnRIYW5kbGVyKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXZlbnRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ2V2ZW50SGFuZGxlcicpO1xyXG4gICAgdGhpcy5hZGRFbmRTdGFnZVN0eWxlQnlDbGljaygpO1xyXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzKTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIGFkZFRleHRPcGFjaXR5KCkge1xyXG4gICAgaWYgKHRoaXMuaXNDb3JyZWN0KSByZXR1cm47XHJcbiAgICB0aGlzLmFuc3dlclRleHRTcGFuLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkRW5kU3RhZ2VTdHlsZUJ5Q2xpY2soKSB7XHJcbiAgICBpZiAodGhpcy5pc0NvcnJlY3QpIHtcclxuICAgICAgdGhpcy5hbnN3ZXJOdW1iZXJTcGFuLmlubmVyVGV4dCA9ICfinJQnO1xyXG4gICAgICB0aGlzLmFuc3dlck51bWJlclNwYW4uY2xhc3NMaXN0LmFkZCgnY2hlY2tlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5hbnN3ZXJUZXh0U3Bhbi5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9ICdsaW5lLXRocm91Z2gnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGFkZEVuZFN0YWdlU3R5bGVCeUtleWJvYXJkKGFuc3dlcjogQW5zd2VyKSB7XHJcbiAgICBjb25zb2xlLmxvZyhhbnN3ZXIgPT09IHRoaXMpO1xyXG4gICAgaWYgKGFuc3dlciA9PT0gdGhpcykgdGhpcy5hZGRFbmRTdGFnZVN0eWxlQnlDbGljaygpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbW92ZUxpc3RlbmVyKCkge1xyXG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmV2ZW50SGFuZGxlcik7XHJcbiAgICB0aGlzLmFkZFRleHRPcGFjaXR5KCk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9775\n")},1787:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.AudioCall = void 0;\r\nconst api_1 = __webpack_require__(1341);\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst enums_1 = __webpack_require__(8875);\r\nconst convertAggregatedWordToWord_1 = __webpack_require__(1682);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst getRandomWords_1 = __webpack_require__(9721);\r\nconst shuffleArray_1 = __webpack_require__(4879);\r\nconst WordController_1 = __webpack_require__(3584);\r\nconst levelSelect_1 = __webpack_require__(4712);\r\n// eslint-disable-next-line import/no-cycle\r\nconst resultPage_1 = __webpack_require__(8247);\r\nconst stage_1 = __webpack_require__(9990);\r\nconst startPage_1 = __webpack_require__(9392);\r\nconst MAX_COUNT_WORDS_PER_GAME = 10;\r\nconst INCORRECT_SERIES = 5;\r\nclass AudioCall {\r\n    constructor() {\r\n        this.words = [];\r\n        this.result = {\r\n            correct: [],\r\n            incorrect: [],\r\n        };\r\n        this.currentStage = 0;\r\n        this.isMute = false;\r\n        this.muteButtonHandler = () => {\r\n            this.muteButton.innerHTML = this.isMute ? 'volume_up' : 'volume_off';\r\n            this.isMute = !this.isMute;\r\n        };\r\n        this.closeButtonHandler = () => {\r\n            this.container.remove();\r\n        };\r\n        this.wordController = new WordController_1.WordController();\r\n        this.container = (0, createNode_1.default)({ tag: 'div', classes: ['audio-call'] });\r\n        this.closeButton = (0, createNode_1.default)({\r\n            tag: 'a',\r\n            classes: ['close-button'],\r\n            atributesAdnValues: [['href', '/'], ['data-navigo', 'true']],\r\n            inner: 'X',\r\n        });\r\n        this.muteButton = (0, createNode_1.default)({ tag: 'span', classes: ['material-icons-outlined', 'mute-button'], inner: 'volume_up' });\r\n        this.userData = Storage_1.storage.getUserIdData();\r\n    }\r\n    start(settings) {\r\n        this.render();\r\n        if (!settings) {\r\n            const levelSelect = new levelSelect_1.LevelSelect(this.container, this.startGameFromMenu.bind(this));\r\n            levelSelect.render();\r\n        }\r\n        else {\r\n            this.closeButton.setAttribute('href', '/book');\r\n            this.settings = {\r\n                group: String(settings.group),\r\n                page: String(settings.page),\r\n            };\r\n            const startPage = new startPage_1.StartPage(this.container, this.startGameFromBook.bind(this));\r\n            startPage.render();\r\n        }\r\n    }\r\n    render() {\r\n        const main = document.querySelector('main');\r\n        this.muteButton.addEventListener('click', this.muteButtonHandler);\r\n        this.closeButton.addEventListener('click', this.closeButtonHandler);\r\n        main.innerHTML = '';\r\n        const buttonsWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['buttons-wrapper'] });\r\n        const wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['container'] });\r\n        buttonsWrapper.append(this.muteButton, this.closeButton);\r\n        wrapper.append(buttonsWrapper);\r\n        this.container.append(wrapper);\r\n        main.append(this.container);\r\n    }\r\n    async startGameFromMenu(wordsGroup) {\r\n        this.words = await (0, getRandomWords_1.getRandomWordsByGroup)(wordsGroup, MAX_COUNT_WORDS_PER_GAME);\r\n        this.startGameStage();\r\n    }\r\n    async startGameFromBook() {\r\n        if (this.settings)\r\n            this.words = await this.getWordsForGame(this.settings);\r\n        if (this.words.length === 0) {\r\n            const levelSelect = new levelSelect_1.LevelSelect(this.container, this.startGameFromMenu.bind(this));\r\n            levelSelect.render();\r\n            return;\r\n        }\r\n        this.startGameStage();\r\n    }\r\n    async getWordsForGame(settings) {\r\n        if (!this.userData) {\r\n            const wordsOnPage = await api_1.api.getWords(settings);\r\n            return (0, shuffleArray_1.shuffleArray)(wordsOnPage).slice(0, MAX_COUNT_WORDS_PER_GAME);\r\n        }\r\n        // game from group 6\r\n        if (settings.group === '6') {\r\n            const userAggregatedWords = await this.wordController.getUserBookWords();\r\n            const words = userAggregatedWords\r\n                .map((word) => (0, convertAggregatedWordToWord_1.convertAggregatedWordToWord)(word));\r\n            console.log(words);\r\n            return (0, shuffleArray_1.shuffleArray)(words).slice(0, MAX_COUNT_WORDS_PER_GAME);\r\n        }\r\n        // game from group 0-5\r\n        let userAggregatedWords = await this.getAggregatedWords(settings);\r\n        let page = Number(settings.page);\r\n        while (userAggregatedWords.length < MAX_COUNT_WORDS_PER_GAME && Number(page) > 0) {\r\n            page -= 1;\r\n            userAggregatedWords = userAggregatedWords.concat(\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this.getAggregatedWords({ group: settings.group, page: String(page) }));\r\n        }\r\n        const words = userAggregatedWords.map((word) => (0, convertAggregatedWordToWord_1.convertAggregatedWordToWord)(word));\r\n        return words.slice(0, MAX_COUNT_WORDS_PER_GAME);\r\n    }\r\n    async getAggregatedWords(settings) {\r\n        let userAggregatedWords = await api_1.api.getAggregatedUserWords(this.userData, { page: settings.page, group: settings.group, wordsPerPage: '20' });\r\n        userAggregatedWords = userAggregatedWords.filter((word) => !word?.userWord?.optional?.learned);\r\n        return (0, shuffleArray_1.shuffleArray)(userAggregatedWords);\r\n    }\r\n    startGameStage() {\r\n        const stage = new stage_1.Stage(this.container, this.words[this.currentStage], this.stageHandler.bind(this), this.playAnswerSound.bind(this));\r\n        stage.start();\r\n    }\r\n    stageHandler(word, stageResult) {\r\n        this.wordController.sendWordOnServer(word.id, stageResult, enums_1.GAME.AUDIOCALL);\r\n        if (stageResult)\r\n            this.result.correct.push(word);\r\n        else\r\n            this.result.incorrect.push(word);\r\n        if (this.currentStage < this.words.length - 1\r\n            && this.result.incorrect.length < INCORRECT_SERIES) {\r\n            this.currentStage += 1;\r\n            this.startGameStage();\r\n        }\r\n        else {\r\n            this.endGameHandler();\r\n        }\r\n    }\r\n    endGameHandler() {\r\n        const resultPage = new resultPage_1.ResultPage(this.container, this.result, this.settings);\r\n        resultPage.start();\r\n    }\r\n    playAnswerSound(isCorrect) {\r\n        if (this.isMute)\r\n            return;\r\n        const audio = new Audio(`./assets/audiocall/sounds/${isCorrect}.mp3`);\r\n        audio.addEventListener('canplaythrough', audio.play);\r\n    }\r\n}\r\nexports.AudioCall = AudioCall;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7UUFDOUUsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFPTyxlQUFlLENBQUMsU0FBa0I7UUFDeEMsSUFBSSxJQUFJLENBQUMsTUFBTTtZQUFFLE9BQU87UUFDeEIsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsNkJBQTZCLFNBQVMsTUFBTSxDQUFDLENBQUM7UUFDdEUsS0FBSyxDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxDQUFDO0NBS0Y7QUE5SkQsOEJBOEpDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL2F1ZGlvY2FsbC9hdWRpb0NhbGwudHM/NmRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcGkgfSBmcm9tICcuLi9Nb2RlbC9hcGknO1xyXG5pbXBvcnQgeyBzdG9yYWdlIH0gZnJvbSAnLi4vU3RvcmFnZS9TdG9yYWdlJztcclxuaW1wb3J0IHsgR0FNRSB9IGZyb20gJy4uL3R5cGVzL2VudW1zJztcclxuaW1wb3J0IHtcclxuICBBdXRob3JpemF0aW9uRGF0YSwgR2FtZVJlc3VsdCwgV29yZCwgVXNlckFnZ3JlZ2F0ZWRXb3JkLFxyXG59IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBjb252ZXJ0QWdncmVnYXRlZFdvcmRUb1dvcmQgfSBmcm9tICcuLi91dGlscy9jb252ZXJ0QWdncmVnYXRlZFdvcmRUb1dvcmQnO1xyXG5pbXBvcnQgY3JlYXRlTm9kZSBmcm9tICcuLi91dGlscy9jcmVhdGVOb2RlJztcclxuaW1wb3J0IHsgZ2V0UmFuZG9tV29yZHNCeUdyb3VwIH0gZnJvbSAnLi4vdXRpbHMvZ2V0UmFuZG9tV29yZHMnO1xyXG5pbXBvcnQgeyBzaHVmZmxlQXJyYXkgfSBmcm9tICcuLi91dGlscy9zaHVmZmxlQXJyYXknO1xyXG5pbXBvcnQgeyBXb3JkQ29udHJvbGxlciB9IGZyb20gJy4uL1dvcmRDb250cm9sbGVyL1dvcmRDb250cm9sbGVyJztcclxuaW1wb3J0IHsgTGV2ZWxTZWxlY3QgfSBmcm9tICcuL2xldmVsU2VsZWN0JztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1jeWNsZVxyXG5pbXBvcnQgeyBSZXN1bHRQYWdlIH0gZnJvbSAnLi9yZXN1bHRQYWdlJztcclxuaW1wb3J0IHsgU3RhZ2UgfSBmcm9tICcuL3N0YWdlJztcclxuaW1wb3J0IHsgU3RhcnRQYWdlIH0gZnJvbSAnLi9zdGFydFBhZ2UnO1xyXG5cclxuY29uc3QgTUFYX0NPVU5UX1dPUkRTX1BFUl9HQU1FID0gMTA7XHJcbmNvbnN0IElOQ09SUkVDVF9TRVJJRVMgPSA1O1xyXG5cclxuZXhwb3J0IGNsYXNzIEF1ZGlvQ2FsbCB7XHJcbiAgcHJpdmF0ZSBjb250YWluZXI6IEhUTUxFbGVtZW50O1xyXG5cclxuICBwcml2YXRlIHdvcmRzOiBXb3JkW10gPSBbXTtcclxuXHJcbiAgcHJpdmF0ZSByZXN1bHQ6IEdhbWVSZXN1bHQgPSB7XHJcbiAgICBjb3JyZWN0OiBbXSxcclxuICAgIGluY29ycmVjdDogW10sXHJcbiAgfTtcclxuXHJcbiAgcHJpdmF0ZSBjdXJyZW50U3RhZ2U6IG51bWJlciA9IDA7XHJcblxyXG4gIHByaXZhdGUgY2xvc2VCdXR0b246IEhUTUxFbGVtZW50O1xyXG5cclxuICBwcml2YXRlIG11dGVCdXR0b246IEhUTUxFbGVtZW50O1xyXG5cclxuICBwcml2YXRlIGlzTXV0ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIHNldHRpbmdzOiB7IGdyb3VwOiBzdHJpbmc7IHBhZ2U6IHN0cmluZzsgfSB8IHVuZGVmaW5lZDtcclxuXHJcbiAgcHJpdmF0ZSB1c2VyRGF0YTogQXV0aG9yaXphdGlvbkRhdGEgfCBudWxsO1xyXG5cclxuICBwcml2YXRlIHdvcmRDb250cm9sbGVyOiBXb3JkQ29udHJvbGxlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLndvcmRDb250cm9sbGVyID0gbmV3IFdvcmRDb250cm9sbGVyKCk7XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ2F1ZGlvLWNhbGwnXSB9KTtcclxuICAgIHRoaXMuY2xvc2VCdXR0b24gPSBjcmVhdGVOb2RlKHtcclxuICAgICAgdGFnOiAnYScsXHJcbiAgICAgIGNsYXNzZXM6IFsnY2xvc2UtYnV0dG9uJ10sXHJcbiAgICAgIGF0cmlidXRlc0FkblZhbHVlczogW1snaHJlZicsICcvJ10sIFsnZGF0YS1uYXZpZ28nLCAndHJ1ZSddXSxcclxuICAgICAgaW5uZXI6ICdYJyxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5tdXRlQnV0dG9uID0gY3JlYXRlTm9kZSh7IHRhZzogJ3NwYW4nLCBjbGFzc2VzOiBbJ21hdGVyaWFsLWljb25zLW91dGxpbmVkJywgJ211dGUtYnV0dG9uJ10sIGlubmVyOiAndm9sdW1lX3VwJyB9KTtcclxuICAgIHRoaXMudXNlckRhdGEgPSBzdG9yYWdlLmdldFVzZXJJZERhdGEoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdGFydChzZXR0aW5ncz86IHsgZ3JvdXA6IG51bWJlciwgcGFnZTogbnVtYmVyIH0pIHtcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICBpZiAoIXNldHRpbmdzKSB7XHJcbiAgICAgIGNvbnN0IGxldmVsU2VsZWN0ID0gbmV3IExldmVsU2VsZWN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnN0YXJ0R2FtZUZyb21NZW51LmJpbmQodGhpcykpO1xyXG4gICAgICBsZXZlbFNlbGVjdC5yZW5kZXIoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuY2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdocmVmJywgJy9ib29rJyk7XHJcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgZ3JvdXA6IFN0cmluZyhzZXR0aW5ncy5ncm91cCksXHJcbiAgICAgICAgcGFnZTogU3RyaW5nKHNldHRpbmdzLnBhZ2UpLFxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBzdGFydFBhZ2UgPSBuZXcgU3RhcnRQYWdlKHRoaXMuY29udGFpbmVyLCB0aGlzLnN0YXJ0R2FtZUZyb21Cb29rLmJpbmQodGhpcykpO1xyXG4gICAgICBzdGFydFBhZ2UucmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbmRlcigpIHtcclxuICAgIGNvbnN0IG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYWluJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICB0aGlzLm11dGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm11dGVCdXR0b25IYW5kbGVyKTtcclxuICAgIHRoaXMuY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlQnV0dG9uSGFuZGxlcik7XHJcbiAgICBtYWluLmlubmVySFRNTCA9ICcnO1xyXG4gICAgY29uc3QgYnV0dG9uc1dyYXBwZXIgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydidXR0b25zLXdyYXBwZXInXSB9KTtcclxuICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydjb250YWluZXInXSB9KTtcclxuICAgIGJ1dHRvbnNXcmFwcGVyLmFwcGVuZCh0aGlzLm11dGVCdXR0b24sIHRoaXMuY2xvc2VCdXR0b24pO1xyXG4gICAgd3JhcHBlci5hcHBlbmQoYnV0dG9uc1dyYXBwZXIpO1xyXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHdyYXBwZXIpO1xyXG4gICAgbWFpbi5hcHBlbmQodGhpcy5jb250YWluZXIpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzdGFydEdhbWVGcm9tTWVudSh3b3Jkc0dyb3VwOiBzdHJpbmcpIHtcclxuICAgIHRoaXMud29yZHMgPSBhd2FpdCBnZXRSYW5kb21Xb3Jkc0J5R3JvdXAod29yZHNHcm91cCwgTUFYX0NPVU5UX1dPUkRTX1BFUl9HQU1FKTtcclxuICAgIHRoaXMuc3RhcnRHYW1lU3RhZ2UoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc3RhcnRHYW1lRnJvbUJvb2soKSB7XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncykgdGhpcy53b3JkcyA9IGF3YWl0IHRoaXMuZ2V0V29yZHNGb3JHYW1lKHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgaWYgKHRoaXMud29yZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnN0IGxldmVsU2VsZWN0ID0gbmV3IExldmVsU2VsZWN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnN0YXJ0R2FtZUZyb21NZW51LmJpbmQodGhpcykpO1xyXG4gICAgICBsZXZlbFNlbGVjdC5yZW5kZXIoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdGFydEdhbWVTdGFnZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRXb3Jkc0ZvckdhbWUoc2V0dGluZ3M6IHsgZ3JvdXA6IHN0cmluZywgcGFnZTogc3RyaW5nIH0pIHtcclxuICAgIGlmICghdGhpcy51c2VyRGF0YSkge1xyXG4gICAgICBjb25zdCB3b3Jkc09uUGFnZSA9IGF3YWl0IGFwaS5nZXRXb3JkcyhzZXR0aW5ncyk7XHJcbiAgICAgIHJldHVybiBzaHVmZmxlQXJyYXkod29yZHNPblBhZ2UpLnNsaWNlKDAsIE1BWF9DT1VOVF9XT1JEU19QRVJfR0FNRSk7XHJcbiAgICB9XHJcbiAgICAvLyBnYW1lIGZyb20gZ3JvdXAgNlxyXG4gICAgaWYgKHNldHRpbmdzLmdyb3VwID09PSAnNicpIHtcclxuICAgICAgY29uc3QgdXNlckFnZ3JlZ2F0ZWRXb3JkcyA9IGF3YWl0IHRoaXMud29yZENvbnRyb2xsZXIuZ2V0VXNlckJvb2tXb3JkcygpO1xyXG4gICAgICBjb25zdCB3b3JkcyA9ICh1c2VyQWdncmVnYXRlZFdvcmRzIGFzIFVzZXJBZ2dyZWdhdGVkV29yZFtdKVxyXG4gICAgICAgIC5tYXAoKHdvcmQpID0+IGNvbnZlcnRBZ2dyZWdhdGVkV29yZFRvV29yZCh3b3JkKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHdvcmRzKTtcclxuICAgICAgcmV0dXJuIHNodWZmbGVBcnJheSh3b3Jkcykuc2xpY2UoMCwgTUFYX0NPVU5UX1dPUkRTX1BFUl9HQU1FKTtcclxuICAgIH1cclxuICAgIC8vIGdhbWUgZnJvbSBncm91cCAwLTVcclxuICAgIGxldCB1c2VyQWdncmVnYXRlZFdvcmRzID0gYXdhaXQgdGhpcy5nZXRBZ2dyZWdhdGVkV29yZHMoc2V0dGluZ3MpO1xyXG4gICAgbGV0IHBhZ2UgPSBOdW1iZXIoc2V0dGluZ3MucGFnZSk7XHJcbiAgICB3aGlsZSAodXNlckFnZ3JlZ2F0ZWRXb3Jkcy5sZW5ndGggPCBNQVhfQ09VTlRfV09SRFNfUEVSX0dBTUUgJiYgTnVtYmVyKHBhZ2UpID4gMCkge1xyXG4gICAgICBwYWdlIC09IDE7XHJcbiAgICAgIHVzZXJBZ2dyZWdhdGVkV29yZHMgPSB1c2VyQWdncmVnYXRlZFdvcmRzLmNvbmNhdChcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxyXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0QWdncmVnYXRlZFdvcmRzKHsgZ3JvdXA6IHNldHRpbmdzLmdyb3VwLCBwYWdlOiBTdHJpbmcocGFnZSkgfSksXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3b3JkcyA9IHVzZXJBZ2dyZWdhdGVkV29yZHMubWFwKCh3b3JkKSA9PiBjb252ZXJ0QWdncmVnYXRlZFdvcmRUb1dvcmQod29yZCkpO1xyXG4gICAgcmV0dXJuIHdvcmRzLnNsaWNlKDAsIE1BWF9DT1VOVF9XT1JEU19QRVJfR0FNRSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldEFnZ3JlZ2F0ZWRXb3JkcyhzZXR0aW5nczogeyBncm91cDogc3RyaW5nLCBwYWdlOiBzdHJpbmcgfSkge1xyXG4gICAgbGV0IHVzZXJBZ2dyZWdhdGVkV29yZHMgPSBhd2FpdCBhcGkuZ2V0QWdncmVnYXRlZFVzZXJXb3JkcyhcclxuICAgICAgdGhpcy51c2VyRGF0YSBhcyBBdXRob3JpemF0aW9uRGF0YSxcclxuICAgICAgeyBwYWdlOiBzZXR0aW5ncy5wYWdlLCBncm91cDogc2V0dGluZ3MuZ3JvdXAsIHdvcmRzUGVyUGFnZTogJzIwJyB9LFxyXG4gICAgKSBhcyBVc2VyQWdncmVnYXRlZFdvcmRbXTtcclxuICAgIHVzZXJBZ2dyZWdhdGVkV29yZHMgPSB1c2VyQWdncmVnYXRlZFdvcmRzLmZpbHRlcigod29yZCkgPT4gIXdvcmQ/LnVzZXJXb3JkPy5vcHRpb25hbD8ubGVhcm5lZCk7XHJcbiAgICByZXR1cm4gc2h1ZmZsZUFycmF5KHVzZXJBZ2dyZWdhdGVkV29yZHMpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGFydEdhbWVTdGFnZSgpIHtcclxuICAgIGNvbnN0IHN0YWdlID0gbmV3IFN0YWdlKFxyXG4gICAgICB0aGlzLmNvbnRhaW5lcixcclxuICAgICAgdGhpcy53b3Jkc1t0aGlzLmN1cnJlbnRTdGFnZV0sXHJcbiAgICAgIHRoaXMuc3RhZ2VIYW5kbGVyLmJpbmQodGhpcyksXHJcbiAgICAgIHRoaXMucGxheUFuc3dlclNvdW5kLmJpbmQodGhpcyksXHJcbiAgICApO1xyXG4gICAgc3RhZ2Uuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhZ2VIYW5kbGVyKHdvcmQ6IFdvcmQsIHN0YWdlUmVzdWx0OiBib29sZWFuKSB7XHJcbiAgICB0aGlzLndvcmRDb250cm9sbGVyLnNlbmRXb3JkT25TZXJ2ZXIod29yZC5pZCwgc3RhZ2VSZXN1bHQsIEdBTUUuQVVESU9DQUxMKTtcclxuICAgIGlmIChzdGFnZVJlc3VsdCkgdGhpcy5yZXN1bHQuY29ycmVjdC5wdXNoKHdvcmQpO1xyXG4gICAgZWxzZSB0aGlzLnJlc3VsdC5pbmNvcnJlY3QucHVzaCh3b3JkKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50U3RhZ2UgPCB0aGlzLndvcmRzLmxlbmd0aCAtIDFcclxuICAgICAgJiYgdGhpcy5yZXN1bHQuaW5jb3JyZWN0Lmxlbmd0aCA8IElOQ09SUkVDVF9TRVJJRVMpIHtcclxuICAgICAgdGhpcy5jdXJyZW50U3RhZ2UgKz0gMTtcclxuICAgICAgdGhpcy5zdGFydEdhbWVTdGFnZSgpO1xyXG4gICAgfSBlbHNlIHsgdGhpcy5lbmRHYW1lSGFuZGxlcigpOyB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGVuZEdhbWVIYW5kbGVyKCkge1xyXG4gICAgY29uc3QgcmVzdWx0UGFnZSA9IG5ldyBSZXN1bHRQYWdlKHRoaXMuY29udGFpbmVyLCB0aGlzLnJlc3VsdCwgdGhpcy5zZXR0aW5ncyk7XHJcbiAgICByZXN1bHRQYWdlLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG11dGVCdXR0b25IYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgdGhpcy5tdXRlQnV0dG9uLmlubmVySFRNTCA9IHRoaXMuaXNNdXRlID8gJ3ZvbHVtZV91cCcgOiAndm9sdW1lX29mZic7XHJcbiAgICB0aGlzLmlzTXV0ZSA9ICF0aGlzLmlzTXV0ZTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIHBsYXlBbnN3ZXJTb3VuZChpc0NvcnJlY3Q6IGJvb2xlYW4pIHtcclxuICAgIGlmICh0aGlzLmlzTXV0ZSkgcmV0dXJuO1xyXG4gICAgY29uc3QgYXVkaW8gPSBuZXcgQXVkaW8oYC4vYXNzZXRzL2F1ZGlvY2FsbC9zb3VuZHMvJHtpc0NvcnJlY3R9Lm1wM2ApO1xyXG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBhdWRpby5wbGF5KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2xvc2VCdXR0b25IYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1787\n")},4712:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LevelSelect = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst AUDIO_CALL_DESCRIPTION = 'Тренировка улучшает восприятие речи на слух.';\r\nconst GAME_NAME = 'Аудиовызов';\r\nconst LEVEL_COUNT = 6;\r\nclass LevelSelect {\r\n    constructor(container, callback) {\r\n        this.selectedValue = '0';\r\n        this.levelButtons = [];\r\n        this.returnLevel = () => {\r\n            this.wrapper.remove();\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            this.callback(this.selectedValue);\r\n        };\r\n        this.keyHandler = (e) => {\r\n            if (e.key === 'Enter') {\r\n                this.returnLevel();\r\n                return;\r\n            }\r\n            const level = Number(e.key) - 1;\r\n            if (level >= 0 && level < LEVEL_COUNT) {\r\n                this.selectedValue = String(level);\r\n                this.levelButtons.forEach((levelButton) => levelButton.classList.remove('selected'));\r\n                const selectedButton = this.levelButtons\r\n                    .find((button) => button.dataset.level === this.selectedValue);\r\n                selectedButton?.classList.add('selected');\r\n            }\r\n        };\r\n        this.removeListeners = () => {\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            this.links.forEach((link) => link.removeEventListener('click', this.removeListeners));\r\n        };\r\n        this.container = container;\r\n        this.callback = callback;\r\n        this.wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['level-select'] });\r\n        this.links = document.querySelectorAll('a');\r\n    }\r\n    render() {\r\n        const title = (0, createNode_1.default)({ tag: 'h2', classes: ['game__title'], inner: GAME_NAME });\r\n        const description = (0, createNode_1.default)({ tag: 'p', classes: ['game__descpiption'], inner: AUDIO_CALL_DESCRIPTION });\r\n        const selectBlock = this.createSelectBlock('Выбери уровень сложности');\r\n        const button = (0, createNode_1.default)({ tag: 'button', atributesAdnValues: [['type', 'button']], inner: 'начать' });\r\n        button.addEventListener('click', this.returnLevel);\r\n        document.addEventListener('keydown', this.keyHandler);\r\n        this.links.forEach((link) => link.addEventListener('click', () => {\r\n            if (!link.href.includes('/audiocall')) {\r\n                this.removeListeners();\r\n                this.container.remove();\r\n            }\r\n        }));\r\n        this.wrapper.append(title, description, selectBlock, button);\r\n        this.container.append(this.wrapper);\r\n    }\r\n    createSelectBlock(title) {\r\n        const wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['select-block'] });\r\n        const titleNode = (0, createNode_1.default)({ tag: 'div', classes: ['select-block__title'], inner: title });\r\n        const select = (0, createNode_1.default)({ tag: 'div', classes: ['select-block__select'] });\r\n        for (let i = 1; i <= LEVEL_COUNT; i += 1) {\r\n            const levelButton = (0, createNode_1.default)({ tag: 'button', atributesAdnValues: [['data-level', String(i - 1)]], inner: String(i) });\r\n            if (i === 1)\r\n                levelButton.classList.add('selected');\r\n            this.levelButtons.push(levelButton);\r\n            select.append(levelButton);\r\n        }\r\n        this.levelButtons.forEach((button) => this.addSelectButtonHandler(button));\r\n        wrapper.append(titleNode, select);\r\n        return wrapper;\r\n    }\r\n    addSelectButtonHandler(button) {\r\n        button.addEventListener('click', (e) => {\r\n            const target = e.target;\r\n            this.selectedValue = target.dataset.level || this.selectedValue;\r\n            this.levelButtons.forEach((levelButton) => levelButton.classList.remove('selected'));\r\n            target.classList.add('selected');\r\n        });\r\n    }\r\n}\r\nexports.LevelSelect = LevelSelect;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQXFCLENBQUM7WUFDdkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDO1lBQ2hFLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JGLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQTJCRjtBQXZGRCxrQ0F1RkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvYXVkaW9jYWxsL2xldmVsU2VsZWN0LnRzP2FkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZU5vZGUgZnJvbSAnLi4vdXRpbHMvY3JlYXRlTm9kZSc7XHJcblxyXG5jb25zdCBBVURJT19DQUxMX0RFU0NSSVBUSU9OID0gJ9Ci0YDQtdC90LjRgNC+0LLQutCwINGD0LvRg9GH0YjQsNC10YIg0LLQvtGB0L/RgNC40Y/RgtC40LUg0YDQtdGH0Lgg0L3QsCDRgdC70YPRhS4nO1xyXG5jb25zdCBHQU1FX05BTUUgPSAn0JDRg9C00LjQvtCy0YvQt9C+0LInO1xyXG5jb25zdCBMRVZFTF9DT1VOVCA9IDY7XHJcblxyXG5leHBvcnQgY2xhc3MgTGV2ZWxTZWxlY3Qge1xyXG4gIHByaXZhdGUgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcHJpdmF0ZSBzZWxlY3RlZFZhbHVlOiBzdHJpbmcgPSAnMCc7XHJcblxyXG4gIHByaXZhdGUgY2FsbGJhY2s6IChzZWxlY3RlZFZhbHVlOiBzdHJpbmcpID0+IHZvaWQ7XHJcblxyXG4gIHByaXZhdGUgd3JhcHBlcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgbGV2ZWxCdXR0b25zOiBIVE1MRWxlbWVudFtdID0gW107XHJcblxyXG4gIHByaXZhdGUgbGlua3M6IE5vZGVMaXN0T2Y8SFRNTEFuY2hvckVsZW1lbnQ+O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCBjYWxsYmFjazogKHNlbGVjdGVkVmFsdWU6IHN0cmluZyk9PiB2b2lkKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMud3JhcHBlciA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ2xldmVsLXNlbGVjdCddIH0pO1xyXG4gICAgdGhpcy5saW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB0aXRsZSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdoMicsIGNsYXNzZXM6IFsnZ2FtZV9fdGl0bGUnXSwgaW5uZXI6IEdBTUVfTkFNRSB9KTtcclxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ2dhbWVfX2Rlc2NwaXB0aW9uJ10sIGlubmVyOiBBVURJT19DQUxMX0RFU0NSSVBUSU9OIH0pO1xyXG4gICAgY29uc3Qgc2VsZWN0QmxvY2sgPSB0aGlzLmNyZWF0ZVNlbGVjdEJsb2NrKCfQktGL0LHQtdGA0Lgg0YPRgNC+0LLQtdC90Ywg0YHQu9C+0LbQvdC+0YHRgtC4Jyk7XHJcbiAgICBjb25zdCBidXR0b24gPSBjcmVhdGVOb2RlKHsgdGFnOiAnYnV0dG9uJywgYXRyaWJ1dGVzQWRuVmFsdWVzOiBbWyd0eXBlJywgJ2J1dHRvbiddXSwgaW5uZXI6ICfQvdCw0YfQsNGC0YwnIH0pO1xyXG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZXR1cm5MZXZlbCk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlIYW5kbGVyKTtcclxuICAgIHRoaXMubGlua3MuZm9yRWFjaCgobGluaykgPT4gbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgaWYgKCFsaW5rLmhyZWYuaW5jbHVkZXMoJy9hdWRpb2NhbGwnKSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICB0aGlzLndyYXBwZXIuYXBwZW5kKHRpdGxlLCBkZXNjcmlwdGlvbiwgc2VsZWN0QmxvY2ssIGJ1dHRvbik7XHJcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQodGhpcy53cmFwcGVyKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlU2VsZWN0QmxvY2sodGl0bGU6IHN0cmluZykge1xyXG4gICAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ3NlbGVjdC1ibG9jayddIH0pO1xyXG4gICAgY29uc3QgdGl0bGVOb2RlID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnc2VsZWN0LWJsb2NrX190aXRsZSddLCBpbm5lcjogdGl0bGUgfSk7XHJcbiAgICBjb25zdCBzZWxlY3QgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydzZWxlY3QtYmxvY2tfX3NlbGVjdCddIH0pO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gTEVWRUxfQ09VTlQ7IGkgKz0gMSkge1xyXG4gICAgICBjb25zdCBsZXZlbEJ1dHRvbiA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdidXR0b24nLCBhdHJpYnV0ZXNBZG5WYWx1ZXM6IFtbJ2RhdGEtbGV2ZWwnLCBTdHJpbmcoaSAtIDEpXV0sIGlubmVyOiBTdHJpbmcoaSkgfSk7XHJcbiAgICAgIGlmIChpID09PSAxKSBsZXZlbEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xyXG4gICAgICB0aGlzLmxldmVsQnV0dG9ucy5wdXNoKGxldmVsQnV0dG9uKTtcclxuICAgICAgc2VsZWN0LmFwcGVuZChsZXZlbEJ1dHRvbik7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxldmVsQnV0dG9ucy5mb3JFYWNoKChidXR0b24pID0+IHRoaXMuYWRkU2VsZWN0QnV0dG9uSGFuZGxlcihidXR0b24pKTtcclxuICAgIHdyYXBwZXIuYXBwZW5kKHRpdGxlTm9kZSwgc2VsZWN0KTtcclxuICAgIHJldHVybiB3cmFwcGVyO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhZGRTZWxlY3RCdXR0b25IYW5kbGVyKGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB0YXJnZXQuZGF0YXNldC5sZXZlbCB8fCB0aGlzLnNlbGVjdGVkVmFsdWU7XHJcbiAgICAgIHRoaXMubGV2ZWxCdXR0b25zLmZvckVhY2goKGxldmVsQnV0dG9uKSA9PiBsZXZlbEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpKTtcclxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmV0dXJuTGV2ZWwgPSAoKSA9PiB7XHJcbiAgICB0aGlzLndyYXBwZXIucmVtb3ZlKCk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlIYW5kbGVyKTtcclxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5zZWxlY3RlZFZhbHVlKTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIGtleUhhbmRsZXIgPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgaWYgKGUua2V5ID09PSAnRW50ZXInKSB7XHJcbiAgICAgIHRoaXMucmV0dXJuTGV2ZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGV2ZWwgPSBOdW1iZXIoZS5rZXkpIC0gMTtcclxuICAgIGlmIChsZXZlbCA+PSAwICYmIGxldmVsIDwgTEVWRUxfQ09VTlQpIHtcclxuICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gU3RyaW5nKGxldmVsKTtcclxuICAgICAgdGhpcy5sZXZlbEJ1dHRvbnMuZm9yRWFjaCgobGV2ZWxCdXR0b24pID0+IGxldmVsQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpO1xyXG4gICAgICBjb25zdCBzZWxlY3RlZEJ1dHRvbiA9IHRoaXMubGV2ZWxCdXR0b25zXHJcbiAgICAgICAgLmZpbmQoKGJ1dHRvbikgPT4gYnV0dG9uLmRhdGFzZXQubGV2ZWwgPT09IHRoaXMuc2VsZWN0ZWRWYWx1ZSk7XHJcbiAgICAgIHNlbGVjdGVkQnV0dG9uPy5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlTGlzdGVuZXJzID0gKCkgPT4ge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5SGFuZGxlcik7XHJcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKGxpbmspID0+IGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnJlbW92ZUxpc3RlbmVycykpO1xyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4712\n")},8247:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResultPage = void 0;\r\nconst constants_1 = __webpack_require__(5004);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\n// eslint-disable-next-line import/no-cycle\r\nconst audioCall_1 = __webpack_require__(1787);\r\nclass ResultPage {\r\n    constructor(container, result, nextGameSettings) {\r\n        this.startNewGame = () => {\r\n            this.container.remove();\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            const game = new audioCall_1.AudioCall();\r\n            if (this.nextGameSettings) {\r\n                console.log('this.nextGameSettings');\r\n                game.start({\r\n                    group: Number(this.nextGameSettings.group), page: Number(this.nextGameSettings.page),\r\n                });\r\n                return;\r\n            }\r\n            game.start();\r\n        };\r\n        this.removeListeners = () => {\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            this.links.forEach((link) => link.removeEventListener('click', this.removeListeners));\r\n        };\r\n        this.keyHandler = (e) => {\r\n            if (e.key === 'Enter')\r\n                this.startNewGame();\r\n        };\r\n        this.container = container;\r\n        this.result = result;\r\n        this.nextGameSettings = nextGameSettings;\r\n        this.wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['game__result'] });\r\n        this.button = (0, createNode_1.default)({ tag: 'button', classes: ['result__button'], inner: 'сыграть еще раз' });\r\n        this.links = document.querySelectorAll('a');\r\n    }\r\n    start() {\r\n        this.render();\r\n    }\r\n    render() {\r\n        const title = (0, createNode_1.default)({ tag: 'h2', classes: ['result__score'], inner: this.getTitleText() });\r\n        const listsContainer = (0, createNode_1.default)({ tag: 'div', classes: ['game__lists'] });\r\n        const trueList = (0, createNode_1.default)({ tag: 'ul', classes: ['result__true'], inner: `Знаю: ${this.result.correct.length}` });\r\n        const falseList = (0, createNode_1.default)({ tag: 'ul', classes: ['result__false'], inner: `Не знаю: ${this.result.incorrect.length}` });\r\n        const trueLi = this.result.correct.map((word) => this.createResultLi(word));\r\n        const falseLi = this.result.incorrect.map((word) => this.createResultLi(word));\r\n        this.button.addEventListener('click', this.startNewGame);\r\n        document.addEventListener('keydown', this.keyHandler);\r\n        this.links.forEach((link) => link.addEventListener('click', () => {\r\n            if (!link.href.includes('/audiocall')) {\r\n                this.removeListeners();\r\n                this.container.remove();\r\n            }\r\n        }));\r\n        trueList.append(...trueLi);\r\n        falseList.append(...falseLi);\r\n        listsContainer.append(trueList, falseList);\r\n        this.wrapper.append(title, listsContainer, this.button);\r\n        this.container.append(this.wrapper);\r\n    }\r\n    createResultLi(word) {\r\n        const wordEn = (0, createNode_1.default)({ tag: 'span', classes: ['result__word-en'], inner: `${word.word}: ` });\r\n        const wordRu = (0, createNode_1.default)({ tag: 'span', classes: ['result__word-ru'], inner: `${word.wordTranslate}` });\r\n        const wordEnRu = (0, createNode_1.default)({ tag: 'li', classes: ['result__word'] });\r\n        const voice = (0, createNode_1.default)({ tag: 'div', classes: ['result__voice'] });\r\n        this.voiceHandler(voice, word);\r\n        wordEnRu.append(voice, wordEn, wordRu);\r\n        return wordEnRu;\r\n    }\r\n    getTitleText() {\r\n        const wordsCount = this.result.correct.length + this.result.incorrect.length;\r\n        const percentOfCorrectAnswers = (this.result.correct.length / wordsCount) * 100;\r\n        console.log(percentOfCorrectAnswers);\r\n        if (percentOfCorrectAnswers === 100)\r\n            return 'Блестяще!';\r\n        if (percentOfCorrectAnswers > 85)\r\n            return 'Отличный результат!';\r\n        if (percentOfCorrectAnswers > 65)\r\n            return 'Хороший результат!';\r\n        if (percentOfCorrectAnswers > 55)\r\n            return 'Неплохо!';\r\n        return 'В другой раз получится лучше!';\r\n    }\r\n    voiceHandler(element, word) {\r\n        element.addEventListener('click', () => {\r\n            const audio = new Audio(`${constants_1.BASE_LINK}/${word.audio}`);\r\n            audio.play();\r\n        });\r\n    }\r\n}\r\nexports.ResultPage = ResultPage;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQzdFLE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ2hGLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUNyQyxJQUFJLHVCQUF1QixLQUFLLEdBQUc7WUFBRSxPQUFPLFdBQVcsQ0FBQztRQUN4RCxJQUFJLHVCQUF1QixHQUFHLEVBQUU7WUFBRSxPQUFPLHFCQUFxQixDQUFDO1FBQy9ELElBQUksdUJBQXVCLEdBQUcsRUFBRTtZQUFFLE9BQU8sb0JBQW9CLENBQUM7UUFDOUQsSUFBSSx1QkFBdUIsR0FBRyxFQUFFO1lBQUUsT0FBTyxVQUFVLENBQUM7UUFDcEQsT0FBTywrQkFBK0IsQ0FBQztJQUN6QyxDQUFDO0lBRU8sWUFBWSxDQUFDLE9BQW9CLEVBQUUsSUFBVTtRQUNuRCxPQUFPLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtZQUNyQyxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxHQUFHLHFCQUFTLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDdEQsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2YsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBd0JGO0FBeEdELGdDQXdHQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy9hdWRpb2NhbGwvcmVzdWx0UGFnZS50cz8zYjgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdhbWVSZXN1bHQsIFdvcmQgfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgQkFTRV9MSU5LIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbnRzJztcclxuaW1wb3J0IGNyZWF0ZU5vZGUgZnJvbSAnLi4vdXRpbHMvY3JlYXRlTm9kZSc7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcclxuaW1wb3J0IHsgQXVkaW9DYWxsIH0gZnJvbSAnLi9hdWRpb0NhbGwnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJlc3VsdFBhZ2Uge1xyXG4gIHByaXZhdGUgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcHJpdmF0ZSByZXN1bHQ6IEdhbWVSZXN1bHQ7XHJcblxyXG4gIHByaXZhdGUgd3JhcHBlcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgYnV0dG9uOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcHJpdmF0ZSBsaW5rczogTm9kZUxpc3RPZjxIVE1MQW5jaG9yRWxlbWVudD47XHJcblxyXG4gIHByaXZhdGUgbmV4dEdhbWVTZXR0aW5nczogeyBncm91cDogc3RyaW5nOyBwYWdlOiBzdHJpbmc7IH0gfCB1bmRlZmluZWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcclxuICAgIHJlc3VsdDogR2FtZVJlc3VsdCxcclxuICAgIG5leHRHYW1lU2V0dGluZ3M/OiB7IGdyb3VwOiBzdHJpbmc7IHBhZ2U6IHN0cmluZyB9LFxyXG4gICkge1xyXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcclxuICAgIHRoaXMubmV4dEdhbWVTZXR0aW5ncyA9IG5leHRHYW1lU2V0dGluZ3M7XHJcbiAgICB0aGlzLndyYXBwZXIgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydnYW1lX19yZXN1bHQnXSB9KTtcclxuICAgIHRoaXMuYnV0dG9uID0gY3JlYXRlTm9kZSh7IHRhZzogJ2J1dHRvbicsIGNsYXNzZXM6IFsncmVzdWx0X19idXR0b24nXSwgaW5uZXI6ICfRgdGL0LPRgNCw0YLRjCDQtdGJ0LUg0YDQsNC3JyB9KTtcclxuICAgIHRoaXMubGlua3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhcnQoKSB7XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB0aXRsZSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdoMicsIGNsYXNzZXM6IFsncmVzdWx0X19zY29yZSddLCBpbm5lcjogdGhpcy5nZXRUaXRsZVRleHQoKSB9KTtcclxuICAgIGNvbnN0IGxpc3RzQ29udGFpbmVyID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnZ2FtZV9fbGlzdHMnXSB9KTtcclxuICAgIGNvbnN0IHRydWVMaXN0ID0gY3JlYXRlTm9kZSh7IHRhZzogJ3VsJywgY2xhc3NlczogWydyZXN1bHRfX3RydWUnXSwgaW5uZXI6IGDQl9C90LDRjjogJHt0aGlzLnJlc3VsdC5jb3JyZWN0Lmxlbmd0aH1gIH0pO1xyXG4gICAgY29uc3QgZmFsc2VMaXN0ID0gY3JlYXRlTm9kZSh7IHRhZzogJ3VsJywgY2xhc3NlczogWydyZXN1bHRfX2ZhbHNlJ10sIGlubmVyOiBg0J3QtSDQt9C90LDRjjogJHt0aGlzLnJlc3VsdC5pbmNvcnJlY3QubGVuZ3RofWAgfSk7XHJcbiAgICBjb25zdCB0cnVlTGkgPSB0aGlzLnJlc3VsdC5jb3JyZWN0Lm1hcCgod29yZCkgPT4gdGhpcy5jcmVhdGVSZXN1bHRMaSh3b3JkKSk7XHJcbiAgICBjb25zdCBmYWxzZUxpID0gdGhpcy5yZXN1bHQuaW5jb3JyZWN0Lm1hcCgod29yZCkgPT4gdGhpcy5jcmVhdGVSZXN1bHRMaSh3b3JkKSk7XHJcbiAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc3RhcnROZXdHYW1lKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xyXG5cclxuICAgIHRoaXMubGlua3MuZm9yRWFjaCgobGluaykgPT4gbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgaWYgKCFsaW5rLmhyZWYuaW5jbHVkZXMoJy9hdWRpb2NhbGwnKSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICB0cnVlTGlzdC5hcHBlbmQoLi4udHJ1ZUxpKTtcclxuICAgIGZhbHNlTGlzdC5hcHBlbmQoLi4uZmFsc2VMaSk7XHJcbiAgICBsaXN0c0NvbnRhaW5lci5hcHBlbmQodHJ1ZUxpc3QsIGZhbHNlTGlzdCk7XHJcbiAgICB0aGlzLndyYXBwZXIuYXBwZW5kKHRpdGxlLCBsaXN0c0NvbnRhaW5lciwgdGhpcy5idXR0b24pO1xyXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHRoaXMud3JhcHBlcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZVJlc3VsdExpKHdvcmQ6IFdvcmQpIHtcclxuICAgIGNvbnN0IHdvcmRFbiA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdzcGFuJywgY2xhc3NlczogWydyZXN1bHRfX3dvcmQtZW4nXSwgaW5uZXI6IGAke3dvcmQud29yZH06IGAgfSk7XHJcbiAgICBjb25zdCB3b3JkUnUgPSBjcmVhdGVOb2RlKHsgdGFnOiAnc3BhbicsIGNsYXNzZXM6IFsncmVzdWx0X193b3JkLXJ1J10sIGlubmVyOiBgJHt3b3JkLndvcmRUcmFuc2xhdGV9YCB9KTtcclxuICAgIGNvbnN0IHdvcmRFblJ1ID0gY3JlYXRlTm9kZSh7IHRhZzogJ2xpJywgY2xhc3NlczogWydyZXN1bHRfX3dvcmQnXSB9KTtcclxuICAgIGNvbnN0IHZvaWNlID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsncmVzdWx0X192b2ljZSddIH0pO1xyXG4gICAgdGhpcy52b2ljZUhhbmRsZXIodm9pY2UsIHdvcmQpO1xyXG4gICAgd29yZEVuUnUuYXBwZW5kKHZvaWNlLCB3b3JkRW4sIHdvcmRSdSk7XHJcbiAgICByZXR1cm4gd29yZEVuUnU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldFRpdGxlVGV4dCgpIHtcclxuICAgIGNvbnN0IHdvcmRzQ291bnQgPSB0aGlzLnJlc3VsdC5jb3JyZWN0Lmxlbmd0aCArIHRoaXMucmVzdWx0LmluY29ycmVjdC5sZW5ndGg7XHJcbiAgICBjb25zdCBwZXJjZW50T2ZDb3JyZWN0QW5zd2VycyA9ICh0aGlzLnJlc3VsdC5jb3JyZWN0Lmxlbmd0aCAvIHdvcmRzQ291bnQpICogMTAwO1xyXG4gICAgY29uc29sZS5sb2cocGVyY2VudE9mQ29ycmVjdEFuc3dlcnMpO1xyXG4gICAgaWYgKHBlcmNlbnRPZkNvcnJlY3RBbnN3ZXJzID09PSAxMDApIHJldHVybiAn0JHQu9C10YHRgtGP0YnQtSEnO1xyXG4gICAgaWYgKHBlcmNlbnRPZkNvcnJlY3RBbnN3ZXJzID4gODUpIHJldHVybiAn0J7RgtC70LjRh9C90YvQuSDRgNC10LfRg9C70YzRgtCw0YIhJztcclxuICAgIGlmIChwZXJjZW50T2ZDb3JyZWN0QW5zd2VycyA+IDY1KSByZXR1cm4gJ9Cl0L7RgNC+0YjQuNC5INGA0LXQt9GD0LvRjNGC0LDRgiEnO1xyXG4gICAgaWYgKHBlcmNlbnRPZkNvcnJlY3RBbnN3ZXJzID4gNTUpIHJldHVybiAn0J3QtdC/0LvQvtGF0L4hJztcclxuICAgIHJldHVybiAn0JIg0LTRgNGD0LPQvtC5INGA0LDQtyDQv9C+0LvRg9GH0LjRgtGB0Y8g0LvRg9GH0YjQtSEnO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB2b2ljZUhhbmRsZXIoZWxlbWVudDogSFRNTEVsZW1lbnQsIHdvcmQ6IFdvcmQpIHtcclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGF1ZGlvID0gbmV3IEF1ZGlvKGAke0JBU0VfTElOS30vJHt3b3JkLmF1ZGlvfWApO1xyXG4gICAgICBhdWRpby5wbGF5KCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhcnROZXdHYW1lID0gKCkgPT4ge1xyXG4gICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlIYW5kbGVyKTtcclxuICAgIGNvbnN0IGdhbWUgPSBuZXcgQXVkaW9DYWxsKCk7XHJcbiAgICBpZiAodGhpcy5uZXh0R2FtZVNldHRpbmdzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCd0aGlzLm5leHRHYW1lU2V0dGluZ3MnKTtcclxuICAgICAgZ2FtZS5zdGFydCh7XHJcbiAgICAgICAgZ3JvdXA6IE51bWJlcih0aGlzLm5leHRHYW1lU2V0dGluZ3MuZ3JvdXApLCBwYWdlOiBOdW1iZXIodGhpcy5uZXh0R2FtZVNldHRpbmdzLnBhZ2UpLFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZ2FtZS5zdGFydCgpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlTGlzdGVuZXJzID0gKCkgPT4ge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5SGFuZGxlcik7XHJcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKGxpbmspID0+IGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnJlbW92ZUxpc3RlbmVycykpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUga2V5SGFuZGxlciA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHRoaXMuc3RhcnROZXdHYW1lKCk7XHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8247\n")},9318:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.SPEAKER = void 0;\r\nexports.SPEAKER = `\r\n<svg width="200" height="200" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\r\n   viewBox="0 0 422.686 422.686" xml:space="preserve">\r\n<g>\r\n  <g>\r\n    <path style="fill:#52455f;" d="M211.343,422.686C94.812,422.686,0,327.882,0,211.343C0,94.812,94.812,0,211.343,0\r\n      c116.539,0,211.343,94.812,211.343,211.343C422.686,327.882,327.882,422.686,211.343,422.686z M211.343,16.257\r\n      c-107.565,0-195.086,87.52-195.086,195.086s87.52,195.086,195.086,195.086s195.086-87.52,195.086-195.086\r\n      S318.908,16.257,211.343,16.257z"/>\r\n  </g>\r\n  <path style="fill:#52455f;" d="M264.65,127.952c-3.479-1.821-7.389-2.78-11.323-2.78c-4.975,0-9.771,1.496-13.859,4.316\r\n    l-37.091,25.621h-33.035c-13.445,0-24.386,10.941-24.386,24.386v58.509c0,13.445,10.941,24.386,24.386,24.386h34.904l32.969,29.035\r\n    c4.463,3.918,10.193,6.08,16.127,6.08c3.39,0,6.828-0.732,9.941-2.122c8.811-3.967,14.444-12.697,14.444-22.256V149.558\r\n    C277.729,140.454,272.722,132.187,264.65,127.952z M261.472,273.145c0,3.203-1.87,6.088-4.796,7.405\r\n    c-1.073,0.48-2.211,0.715-3.333,0.715c-1.951,0-3.869-0.691-5.381-2.024l-37.578-33.091h-41.049c-4.495,0-8.129-3.633-8.129-8.129\r\n    v-58.51c0-4.487,3.633-8.129,8.129-8.129h38.107l41.277-28.515c1.374-0.951,2.983-1.431,4.601-1.431\r\n    c1.292,0,2.593,0.309,3.78,0.927c2.682,1.406,4.365,4.178,4.365,7.202v123.579H261.472z"/>\r\n</g>\r\n</svg>\r\n`;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMxOC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYSxlQUFPLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQnRCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvYXVkaW9jYWxsL3NwZWFrZXJTVkcudHM/OGIxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgU1BFQUtFUiA9IGBcclxuPHN2ZyB3aWR0aD1cIjIwMFwiIGhlaWdodD1cIjIwMFwiIHZlcnNpb249XCIxLjFcIiBpZD1cIkNhcGFfMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiXHJcbiAgIHZpZXdCb3g9XCIwIDAgNDIyLjY4NiA0MjIuNjg2XCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cclxuPGc+XHJcbiAgPGc+XHJcbiAgICA8cGF0aCBzdHlsZT1cImZpbGw6IzUyNDU1ZjtcIiBkPVwiTTIxMS4zNDMsNDIyLjY4NkM5NC44MTIsNDIyLjY4NiwwLDMyNy44ODIsMCwyMTEuMzQzQzAsOTQuODEyLDk0LjgxMiwwLDIxMS4zNDMsMFxyXG4gICAgICBjMTE2LjUzOSwwLDIxMS4zNDMsOTQuODEyLDIxMS4zNDMsMjExLjM0M0M0MjIuNjg2LDMyNy44ODIsMzI3Ljg4Miw0MjIuNjg2LDIxMS4zNDMsNDIyLjY4NnogTTIxMS4zNDMsMTYuMjU3XHJcbiAgICAgIGMtMTA3LjU2NSwwLTE5NS4wODYsODcuNTItMTk1LjA4NiwxOTUuMDg2czg3LjUyLDE5NS4wODYsMTk1LjA4NiwxOTUuMDg2czE5NS4wODYtODcuNTIsMTk1LjA4Ni0xOTUuMDg2XHJcbiAgICAgIFMzMTguOTA4LDE2LjI1NywyMTEuMzQzLDE2LjI1N3pcIi8+XHJcbiAgPC9nPlxyXG4gIDxwYXRoIHN0eWxlPVwiZmlsbDojNTI0NTVmO1wiIGQ9XCJNMjY0LjY1LDEyNy45NTJjLTMuNDc5LTEuODIxLTcuMzg5LTIuNzgtMTEuMzIzLTIuNzhjLTQuOTc1LDAtOS43NzEsMS40OTYtMTMuODU5LDQuMzE2XHJcbiAgICBsLTM3LjA5MSwyNS42MjFoLTMzLjAzNWMtMTMuNDQ1LDAtMjQuMzg2LDEwLjk0MS0yNC4zODYsMjQuMzg2djU4LjUwOWMwLDEzLjQ0NSwxMC45NDEsMjQuMzg2LDI0LjM4NiwyNC4zODZoMzQuOTA0bDMyLjk2OSwyOS4wMzVcclxuICAgIGM0LjQ2MywzLjkxOCwxMC4xOTMsNi4wOCwxNi4xMjcsNi4wOGMzLjM5LDAsNi44MjgtMC43MzIsOS45NDEtMi4xMjJjOC44MTEtMy45NjcsMTQuNDQ0LTEyLjY5NywxNC40NDQtMjIuMjU2VjE0OS41NThcclxuICAgIEMyNzcuNzI5LDE0MC40NTQsMjcyLjcyMiwxMzIuMTg3LDI2NC42NSwxMjcuOTUyeiBNMjYxLjQ3MiwyNzMuMTQ1YzAsMy4yMDMtMS44Nyw2LjA4OC00Ljc5Niw3LjQwNVxyXG4gICAgYy0xLjA3MywwLjQ4LTIuMjExLDAuNzE1LTMuMzMzLDAuNzE1Yy0xLjk1MSwwLTMuODY5LTAuNjkxLTUuMzgxLTIuMDI0bC0zNy41NzgtMzMuMDkxaC00MS4wNDljLTQuNDk1LDAtOC4xMjktMy42MzMtOC4xMjktOC4xMjlcclxuICAgIHYtNTguNTFjMC00LjQ4NywzLjYzMy04LjEyOSw4LjEyOS04LjEyOWgzOC4xMDdsNDEuMjc3LTI4LjUxNWMxLjM3NC0wLjk1MSwyLjk4My0xLjQzMSw0LjYwMS0xLjQzMVxyXG4gICAgYzEuMjkyLDAsMi41OTMsMC4zMDksMy43OCwwLjkyN2MyLjY4MiwxLjQwNiw0LjM2NSw0LjE3OCw0LjM2NSw3LjIwMnYxMjMuNTc5SDI2MS40NzJ6XCIvPlxyXG48L2c+XHJcbjwvc3ZnPlxyXG5gO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9318\n')},9990:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Stage = void 0;\r\nconst constants_1 = __webpack_require__(5004);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst getRandomWords_1 = __webpack_require__(9721);\r\nconst shuffleArray_1 = __webpack_require__(4879);\r\nconst answer_1 = __webpack_require__(9775);\r\nconst speakerSVG_1 = __webpack_require__(9318);\r\nconst ANSWERS_COUNT = 5;\r\nclass Stage {\r\n    constructor(container, word, callback, playAnswerSound) {\r\n        this.answers = [];\r\n        this.result = false;\r\n        this.hasAnswer = false;\r\n        this.loadNextStage = () => {\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            this.wrapper.remove();\r\n            this.callback(this.word, this.result);\r\n        };\r\n        this.sayWord = () => {\r\n            const audio = new Audio(`${constants_1.BASE_LINK}/${this.word.audio}`);\r\n            audio.addEventListener('canplaythrough', audio.play);\r\n        };\r\n        this.keyHandler = (e) => {\r\n            if (e.code === 'Space') {\r\n                this.sayWord();\r\n                return;\r\n            }\r\n            if (e.key === 'Enter') {\r\n                if (!this.hasAnswer)\r\n                    this.answerHandler();\r\n                else\r\n                    this.loadNextStage();\r\n                return;\r\n            }\r\n            if (this.hasAnswer)\r\n                return;\r\n            const answerNumber = Number(e.key);\r\n            if (answerNumber > 0 && answerNumber <= this.answers.length) {\r\n                const currentAnswer = this.answers.find((answer) => answer.number === answerNumber);\r\n                if (currentAnswer) {\r\n                    this.answerHandler(currentAnswer);\r\n                    this.answers.forEach((answer) => answer.addEndStageStyleByKeyboard(currentAnswer));\r\n                }\r\n            }\r\n        };\r\n        this.removeListeners = () => {\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            this.links.forEach((link) => link.removeEventListener('click', this.removeListeners));\r\n        };\r\n        this.container = container;\r\n        this.word = word;\r\n        this.callback = callback;\r\n        this.playAnswerSound = playAnswerSound;\r\n        this.wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['stage'] });\r\n        this.wordText = (0, createNode_1.default)({ tag: 'span', classes: ['word__text'] });\r\n        this.skipButton = (0, createNode_1.default)({ tag: 'button', classes: ['button', 'button-skip'], inner: 'не знаю' });\r\n        this.nextStageButton = (0, createNode_1.default)({ tag: 'button', classes: ['button', 'button-next'], inner: '⟶' });\r\n        this.soundButton = (0, createNode_1.default)({ tag: 'button', classes: ['speaker-button'], inner: speakerSVG_1.SPEAKER });\r\n        this.links = document.querySelectorAll('a');\r\n    }\r\n    async start() {\r\n        await this.setAnswers();\r\n        this.sayWord();\r\n        this.render();\r\n        document.addEventListener('keydown', this.keyHandler);\r\n        this.links.forEach((link) => link.addEventListener('click', () => {\r\n            if (link.href.includes('/audiocall')) {\r\n                this.removeListeners();\r\n                this.container.remove();\r\n            }\r\n        }));\r\n    }\r\n    async setAnswers() {\r\n        const wrongAnswers = [];\r\n        for (let i = 0; wrongAnswers.length < ANSWERS_COUNT - 1; i += 1) {\r\n            wrongAnswers.push((0, getRandomWords_1.getRandomWordByGroup)(String(this.word.group)));\r\n        }\r\n        const wordAnswers = [this.word, ...(await Promise.all(wrongAnswers))];\r\n        const shuffledAnswers = (0, shuffleArray_1.shuffleArray)(wordAnswers);\r\n        this.answers = shuffledAnswers.map((word, index) => {\r\n            if (word === this.word) {\r\n                return new answer_1.Answer(word, index + 1, true, this.answerHandler.bind(this));\r\n            }\r\n            return new answer_1.Answer(word, index + 1, false, this.answerHandler.bind(this));\r\n        });\r\n    }\r\n    answerHandler(answer) {\r\n        this.hasAnswer = true;\r\n        if (answer?.isCorrect)\r\n            this.result = true;\r\n        this.showCorrectAnswer();\r\n        console.log('result of stage', this.result);\r\n    }\r\n    render() {\r\n        const wordBlock = this.createWordBlock();\r\n        const answersWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['answers'] });\r\n        const answerButtons = this.answers.map((answer) => answer.div);\r\n        answersWrapper.append(...answerButtons);\r\n        this.skipButton = (0, createNode_1.default)({ tag: 'button', classes: ['skip-button'], inner: 'не знаю' });\r\n        this.bindSkipButtonEvent(this.skipButton);\r\n        this.wrapper.append(wordBlock, answersWrapper, this.skipButton);\r\n        this.container.append(this.wrapper);\r\n    }\r\n    createWordBlock() {\r\n        const wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['word'] });\r\n        this.bindSoundButtonEvent(this.soundButton);\r\n        wrapper.append(this.soundButton, this.wordText);\r\n        return wrapper;\r\n    }\r\n    bindSoundButtonEvent(button) {\r\n        button.addEventListener('click', this.sayWord);\r\n    }\r\n    bindSkipButtonEvent(button) {\r\n        button.addEventListener('click', () => {\r\n            console.log('skip pressed');\r\n            this.skipQuestion();\r\n        });\r\n    }\r\n    bindNextStageButtonEvent(button) {\r\n        button.addEventListener('click', this.loadNextStage);\r\n    }\r\n    skipQuestion() {\r\n        this.showCorrectAnswer();\r\n    }\r\n    showCorrectAnswer() {\r\n        const wordImage = (0, createNode_1.default)({\r\n            tag: 'img',\r\n            classes: ['stage__img'],\r\n            atributesAdnValues: [['src', `${constants_1.BASE_LINK}/${this.word.image}`], ['alt', this.word.word]],\r\n        });\r\n        this.soundButton.classList.add('speaker-button_min');\r\n        this.wrapper.prepend(wordImage);\r\n        this.wordText.innerHTML = this.word.word;\r\n        this.answers.forEach((answer) => answer.removeListener());\r\n        this.bindNextStageButtonEvent(this.nextStageButton);\r\n        this.skipButton.replaceWith(this.nextStageButton);\r\n        this.playAnswerSound(this.result);\r\n    }\r\n}\r\nexports.Stage = Stage;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxLQUFLLEVBQUUsR0FBRyxxQkFBUyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzFGLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwQyxDQUFDO0NBMkJGO0FBeEtELHNCQXdLQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy9hdWRpb2NhbGwvc3RhZ2UudHM/YTczZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXb3JkIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IEJBU0VfTElOSyB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XHJcbmltcG9ydCBjcmVhdGVOb2RlIGZyb20gJy4uL3V0aWxzL2NyZWF0ZU5vZGUnO1xyXG5pbXBvcnQgeyBnZXRSYW5kb21Xb3JkQnlHcm91cCB9IGZyb20gJy4uL3V0aWxzL2dldFJhbmRvbVdvcmRzJztcclxuaW1wb3J0IHsgc2h1ZmZsZUFycmF5IH0gZnJvbSAnLi4vdXRpbHMvc2h1ZmZsZUFycmF5JztcclxuaW1wb3J0IHsgQW5zd2VyIH0gZnJvbSAnLi9hbnN3ZXInO1xyXG5pbXBvcnQgeyBTUEVBS0VSIH0gZnJvbSAnLi9zcGVha2VyU1ZHJztcclxuXHJcbmNvbnN0IEFOU1dFUlNfQ09VTlQgPSA1O1xyXG5cclxuZXhwb3J0IGNsYXNzIFN0YWdlIHtcclxuICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgd29yZDogV29yZDtcclxuXHJcbiAgcHJpdmF0ZSBjYWxsYmFjazogKHdvcmQ6IFdvcmQsIHJlc3VsdDogYm9vbGVhbikgPT4gdm9pZDtcclxuXHJcbiAgcHJpdmF0ZSB3cmFwcGVyOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcHJpdmF0ZSB3b3JkVGV4dDogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgYW5zd2VyczogQW5zd2VyW10gPSBbXTtcclxuXHJcbiAgcHJpdmF0ZSBza2lwQnV0dG9uOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcHJpdmF0ZSBuZXh0U3RhZ2VCdXR0b246IEhUTUxFbGVtZW50O1xyXG5cclxuICBwcml2YXRlIHJlc3VsdDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIHNvdW5kQnV0dG9uOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcHJpdmF0ZSBoYXNBbnN3ZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgcHJpdmF0ZSBwbGF5QW5zd2VyU291bmQ6IChpc0NvcnJlY3Q6IGJvb2xlYW4pID0+IHZvaWQ7XHJcblxyXG4gIHByaXZhdGUgbGlua3M6IE5vZGVMaXN0T2Y8SFRNTEFuY2hvckVsZW1lbnQ+O1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXHJcbiAgICB3b3JkOiBXb3JkLFxyXG4gICAgY2FsbGJhY2s6ICh3b3JkOiBXb3JkLCByZXN1bHQ6IGJvb2xlYW4pID0+IHZvaWQsXHJcbiAgICBwbGF5QW5zd2VyU291bmQ6IChpc0NvcnJlY3Q6IGJvb2xlYW4pID0+IHZvaWQsXHJcbiAgKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMud29yZCA9IHdvcmQ7XHJcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB0aGlzLnBsYXlBbnN3ZXJTb3VuZCA9IHBsYXlBbnN3ZXJTb3VuZDtcclxuICAgIHRoaXMud3JhcHBlciA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ3N0YWdlJ10gfSk7XHJcbiAgICB0aGlzLndvcmRUZXh0ID0gY3JlYXRlTm9kZSh7IHRhZzogJ3NwYW4nLCBjbGFzc2VzOiBbJ3dvcmRfX3RleHQnXSB9KTtcclxuICAgIHRoaXMuc2tpcEJ1dHRvbiA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdidXR0b24nLCBjbGFzc2VzOiBbJ2J1dHRvbicsICdidXR0b24tc2tpcCddLCBpbm5lcjogJ9C90LUg0LfQvdCw0Y4nIH0pO1xyXG4gICAgdGhpcy5uZXh0U3RhZ2VCdXR0b24gPSBjcmVhdGVOb2RlKHsgdGFnOiAnYnV0dG9uJywgY2xhc3NlczogWydidXR0b24nLCAnYnV0dG9uLW5leHQnXSwgaW5uZXI6ICfin7YnIH0pO1xyXG4gICAgdGhpcy5zb3VuZEJ1dHRvbiA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdidXR0b24nLCBjbGFzc2VzOiBbJ3NwZWFrZXItYnV0dG9uJ10sIGlubmVyOiBTUEVBS0VSIH0pO1xyXG4gICAgdGhpcy5saW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBzdGFydCgpIHtcclxuICAgIGF3YWl0IHRoaXMuc2V0QW5zd2VycygpO1xyXG4gICAgdGhpcy5zYXlXb3JkKCk7XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5SGFuZGxlcik7XHJcbiAgICB0aGlzLmxpbmtzLmZvckVhY2goKGxpbmspID0+IGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGlmIChsaW5rLmhyZWYuaW5jbHVkZXMoJy9hdWRpb2NhbGwnKSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc2V0QW5zd2VycygpIHtcclxuICAgIGNvbnN0IHdyb25nQW5zd2VyczogUHJvbWlzZTxXb3JkPltdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgd3JvbmdBbnN3ZXJzLmxlbmd0aCA8IEFOU1dFUlNfQ09VTlQgLSAxOyBpICs9IDEpIHtcclxuICAgICAgd3JvbmdBbnN3ZXJzLnB1c2goZ2V0UmFuZG9tV29yZEJ5R3JvdXAoU3RyaW5nKHRoaXMud29yZC5ncm91cCkpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdvcmRBbnN3ZXJzID0gW3RoaXMud29yZCwgLi4uKGF3YWl0IFByb21pc2UuYWxsKHdyb25nQW5zd2VycykpXTtcclxuICAgIGNvbnN0IHNodWZmbGVkQW5zd2VycyA9IHNodWZmbGVBcnJheSh3b3JkQW5zd2Vycyk7XHJcbiAgICB0aGlzLmFuc3dlcnMgPSBzaHVmZmxlZEFuc3dlcnMubWFwKCh3b3JkLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAod29yZCA9PT0gdGhpcy53b3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbnN3ZXIod29yZCwgaW5kZXggKyAxLCB0cnVlLCB0aGlzLmFuc3dlckhhbmRsZXIuYmluZCh0aGlzKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBBbnN3ZXIod29yZCwgaW5kZXggKyAxLCBmYWxzZSwgdGhpcy5hbnN3ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFuc3dlckhhbmRsZXIoYW5zd2VyPzogQW5zd2VyKSB7XHJcbiAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XHJcbiAgICBpZiAoYW5zd2VyPy5pc0NvcnJlY3QpIHRoaXMucmVzdWx0ID0gdHJ1ZTtcclxuICAgIHRoaXMuc2hvd0NvcnJlY3RBbnN3ZXIoKTtcclxuICAgIGNvbnNvbGUubG9nKCdyZXN1bHQgb2Ygc3RhZ2UnLCB0aGlzLnJlc3VsdCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbmRlcigpIHtcclxuICAgIGNvbnN0IHdvcmRCbG9jayA9IHRoaXMuY3JlYXRlV29yZEJsb2NrKCk7XHJcbiAgICBjb25zdCBhbnN3ZXJzV3JhcHBlciA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ2Fuc3dlcnMnXSB9KTtcclxuICAgIGNvbnN0IGFuc3dlckJ1dHRvbnMgPSB0aGlzLmFuc3dlcnMubWFwKChhbnN3ZXIpID0+IGFuc3dlci5kaXYpO1xyXG4gICAgYW5zd2Vyc1dyYXBwZXIuYXBwZW5kKC4uLmFuc3dlckJ1dHRvbnMpO1xyXG4gICAgdGhpcy5za2lwQnV0dG9uID0gY3JlYXRlTm9kZSh7IHRhZzogJ2J1dHRvbicsIGNsYXNzZXM6IFsnc2tpcC1idXR0b24nXSwgaW5uZXI6ICfQvdC1INC30L3QsNGOJyB9KTtcclxuICAgIHRoaXMuYmluZFNraXBCdXR0b25FdmVudCh0aGlzLnNraXBCdXR0b24pO1xyXG4gICAgdGhpcy53cmFwcGVyLmFwcGVuZCh3b3JkQmxvY2ssIGFuc3dlcnNXcmFwcGVyLCB0aGlzLnNraXBCdXR0b24pO1xyXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHRoaXMud3JhcHBlcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZVdvcmRCbG9jaygpIHtcclxuICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWyd3b3JkJ10gfSk7XHJcbiAgICB0aGlzLmJpbmRTb3VuZEJ1dHRvbkV2ZW50KHRoaXMuc291bmRCdXR0b24pO1xyXG4gICAgd3JhcHBlci5hcHBlbmQodGhpcy5zb3VuZEJ1dHRvbiwgdGhpcy53b3JkVGV4dCk7XHJcbiAgICByZXR1cm4gd3JhcHBlcjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYmluZFNvdW5kQnV0dG9uRXZlbnQoYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zYXlXb3JkKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYmluZFNraXBCdXR0b25FdmVudChidXR0b246IEhUTUxFbGVtZW50KSB7XHJcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdza2lwIHByZXNzZWQnKTtcclxuICAgICAgdGhpcy5za2lwUXVlc3Rpb24oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBiaW5kTmV4dFN0YWdlQnV0dG9uRXZlbnQoYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5sb2FkTmV4dFN0YWdlKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbG9hZE5leHRTdGFnZSA9ICgpID0+IHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xyXG4gICAgdGhpcy53cmFwcGVyLnJlbW92ZSgpO1xyXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLndvcmQsIHRoaXMucmVzdWx0KTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIHNheVdvcmQgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbyhgJHtCQVNFX0xJTkt9LyR7dGhpcy53b3JkLmF1ZGlvfWApO1xyXG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBhdWRpby5wbGF5KTtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIHNraXBRdWVzdGlvbigpIHtcclxuICAgIHRoaXMuc2hvd0NvcnJlY3RBbnN3ZXIoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2hvd0NvcnJlY3RBbnN3ZXIoKSB7XHJcbiAgICBjb25zdCB3b3JkSW1hZ2UgPSBjcmVhdGVOb2RlKHtcclxuICAgICAgdGFnOiAnaW1nJyxcclxuICAgICAgY2xhc3NlczogWydzdGFnZV9faW1nJ10sXHJcbiAgICAgIGF0cmlidXRlc0FkblZhbHVlczogW1snc3JjJywgYCR7QkFTRV9MSU5LfS8ke3RoaXMud29yZC5pbWFnZX1gXSwgWydhbHQnLCB0aGlzLndvcmQud29yZF1dLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNvdW5kQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3NwZWFrZXItYnV0dG9uX21pbicpO1xyXG4gICAgdGhpcy53cmFwcGVyLnByZXBlbmQod29yZEltYWdlKTtcclxuICAgIHRoaXMud29yZFRleHQuaW5uZXJIVE1MID0gdGhpcy53b3JkLndvcmQ7XHJcbiAgICB0aGlzLmFuc3dlcnMuZm9yRWFjaCgoYW5zd2VyKSA9PiBhbnN3ZXIucmVtb3ZlTGlzdGVuZXIoKSk7XHJcbiAgICB0aGlzLmJpbmROZXh0U3RhZ2VCdXR0b25FdmVudCh0aGlzLm5leHRTdGFnZUJ1dHRvbik7XHJcbiAgICB0aGlzLnNraXBCdXR0b24ucmVwbGFjZVdpdGgodGhpcy5uZXh0U3RhZ2VCdXR0b24pO1xyXG4gICAgdGhpcy5wbGF5QW5zd2VyU291bmQodGhpcy5yZXN1bHQpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBrZXlIYW5kbGVyID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgIGlmIChlLmNvZGUgPT09ICdTcGFjZScpIHtcclxuICAgICAgdGhpcy5zYXlXb3JkKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xyXG4gICAgICBpZiAoIXRoaXMuaGFzQW5zd2VyKSB0aGlzLmFuc3dlckhhbmRsZXIoKTtcclxuICAgICAgZWxzZSB0aGlzLmxvYWROZXh0U3RhZ2UoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuaGFzQW5zd2VyKSByZXR1cm47XHJcbiAgICBjb25zdCBhbnN3ZXJOdW1iZXIgPSBOdW1iZXIoZS5rZXkpO1xyXG4gICAgaWYgKGFuc3dlck51bWJlciA+IDAgJiYgYW5zd2VyTnVtYmVyIDw9IHRoaXMuYW5zd2Vycy5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgY3VycmVudEFuc3dlciA9IHRoaXMuYW5zd2Vycy5maW5kKChhbnN3ZXIpID0+IGFuc3dlci5udW1iZXIgPT09IGFuc3dlck51bWJlcik7XHJcbiAgICAgIGlmIChjdXJyZW50QW5zd2VyKSB7XHJcbiAgICAgICAgdGhpcy5hbnN3ZXJIYW5kbGVyKGN1cnJlbnRBbnN3ZXIpO1xyXG4gICAgICAgIHRoaXMuYW5zd2Vycy5mb3JFYWNoKChhbnN3ZXIpID0+IGFuc3dlci5hZGRFbmRTdGFnZVN0eWxlQnlLZXlib2FyZChjdXJyZW50QW5zd2VyKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBwcml2YXRlIHJlbW92ZUxpc3RlbmVycyA9ICgpID0+IHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xyXG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKChsaW5rKSA9PiBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5yZW1vdmVMaXN0ZW5lcnMpKTtcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9990\n")},9392:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StartPage = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst AUDIO_CALL_DESCRIPTION = 'Тренировка улучшает восприятие речи на слух.';\r\nconst GAME_NAME = 'Аудиовызов';\r\nclass StartPage {\r\n    constructor(container, callback) {\r\n        this.startGame = () => {\r\n            this.wrapper.remove();\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            this.callback();\r\n        };\r\n        this.keyHandler = (e) => {\r\n            if (e.key === 'Enter')\r\n                this.startGame();\r\n        };\r\n        this.removeListeners = () => {\r\n            document.removeEventListener('keydown', this.keyHandler);\r\n            this.links.forEach((link) => link.removeEventListener('click', this.removeListeners));\r\n        };\r\n        this.container = container;\r\n        this.callback = callback;\r\n        this.wrapper = (0, createNode_1.default)({ tag: 'div', classes: ['level-select'] });\r\n        this.links = document.querySelectorAll('a');\r\n    }\r\n    render() {\r\n        const title = (0, createNode_1.default)({ tag: 'h2', classes: ['game__title'], inner: GAME_NAME });\r\n        const description = (0, createNode_1.default)({ tag: 'p', classes: ['game__descpiption'], inner: AUDIO_CALL_DESCRIPTION });\r\n        const button = (0, createNode_1.default)({ tag: 'button', atributesAdnValues: [['type', 'button']], inner: 'начать' });\r\n        button.addEventListener('click', this.startGame);\r\n        document.addEventListener('keydown', this.keyHandler);\r\n        this.links.forEach((link) => link.addEventListener('click', () => {\r\n            if (!link.href.includes('/audiocall')) {\r\n                this.removeListeners();\r\n                this.container.remove();\r\n            }\r\n        }));\r\n        this.wrapper.append(title, description, button);\r\n        this.container.append(this.wrapper);\r\n    }\r\n}\r\nexports.StartPage = StartPage;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3RDLENBQUM7Q0FnQkY7QUEvQ0QsOEJBK0NDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL2F1ZGlvY2FsbC9zdGFydFBhZ2UudHM/MWNjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTm9kZSBmcm9tICcuLi91dGlscy9jcmVhdGVOb2RlJztcclxuXHJcbmNvbnN0IEFVRElPX0NBTExfREVTQ1JJUFRJT04gPSAn0KLRgNC10L3QuNGA0L7QstC60LAg0YPQu9GD0YfRiNCw0LXRgiDQstC+0YHQv9GA0LjRj9GC0LjQtSDRgNC10YfQuCDQvdCwINGB0LvRg9GFLic7XHJcbmNvbnN0IEdBTUVfTkFNRSA9ICfQkNGD0LTQuNC+0LLRi9C30L7Qsic7XHJcblxyXG5leHBvcnQgY2xhc3MgU3RhcnRQYWdlIHtcclxuICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XHJcblxyXG4gIHByaXZhdGUgd3JhcHBlcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIHByaXZhdGUgbGlua3M6IE5vZGVMaXN0T2Y8SFRNTEFuY2hvckVsZW1lbnQ+O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCBjYWxsYmFjazogKCk9PiB2b2lkKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIHRoaXMud3JhcHBlciA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ2xldmVsLXNlbGVjdCddIH0pO1xyXG4gICAgdGhpcy5saW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB0aXRsZSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdoMicsIGNsYXNzZXM6IFsnZ2FtZV9fdGl0bGUnXSwgaW5uZXI6IEdBTUVfTkFNRSB9KTtcclxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ2dhbWVfX2Rlc2NwaXB0aW9uJ10sIGlubmVyOiBBVURJT19DQUxMX0RFU0NSSVBUSU9OIH0pO1xyXG4gICAgY29uc3QgYnV0dG9uID0gY3JlYXRlTm9kZSh7IHRhZzogJ2J1dHRvbicsIGF0cmlidXRlc0FkblZhbHVlczogW1sndHlwZScsICdidXR0b24nXV0sIGlubmVyOiAn0L3QsNGH0LDRgtGMJyB9KTtcclxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc3RhcnRHYW1lKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xyXG4gICAgdGhpcy5saW5rcy5mb3JFYWNoKChsaW5rKSA9PiBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICBpZiAoIWxpbmsuaHJlZi5pbmNsdWRlcygnL2F1ZGlvY2FsbCcpKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICAgIHRoaXMud3JhcHBlci5hcHBlbmQodGl0bGUsIGRlc2NyaXB0aW9uLCBidXR0b24pO1xyXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHRoaXMud3JhcHBlcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXJ0R2FtZSA9ICgpID0+IHtcclxuICAgIHRoaXMud3JhcHBlci5yZW1vdmUoKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleUhhbmRsZXIpO1xyXG4gICAgdGhpcy5jYWxsYmFjaygpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUga2V5SGFuZGxlciA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHRoaXMuc3RhcnRHYW1lKCk7XHJcbiAgfTtcclxuXHJcbiAgcHJpdmF0ZSByZW1vdmVMaXN0ZW5lcnMgPSAoKSA9PiB7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlIYW5kbGVyKTtcclxuICAgIHRoaXMubGlua3MuZm9yRWFjaCgobGluaykgPT4gbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucmVtb3ZlTGlzdGVuZXJzKSk7XHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9392\n")},2962:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Controller = void 0;\r\nconst navigo_1 = __importDefault(__webpack_require__(8123));\r\nconst TextBook_1 = __webpack_require__(8305);\r\nconst api_1 = __webpack_require__(1341);\r\nconst Modal_1 = __webpack_require__(9843);\r\nconst LoginForm_1 = __webpack_require__(5674);\r\nconst RegisterForm_1 = __webpack_require__(9441);\r\nconst constants_1 = __webpack_require__(5004);\r\nconst UserUI_1 = __webpack_require__(3761);\r\nconst Sprint_1 = __webpack_require__(2956);\r\nconst audioCall_1 = __webpack_require__(1787);\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst MainPage_1 = __webpack_require__(8096);\r\nconst BurgerMenu_1 = __webpack_require__(7618);\r\nconst WordController_1 = __webpack_require__(3584);\r\nclass Controller {\r\n    constructor() {\r\n        this.router = new navigo_1.default('/', { hash: true });\r\n        this.api = new api_1.Api();\r\n        this.textBook = new TextBook_1.TextBook(constants_1.LEVELS_OF_TEXTBOOK);\r\n        this.modal = new Modal_1.Modal();\r\n        this.loginForm = new LoginForm_1.LoginForm('login', 'Login');\r\n        this.registerForm = new RegisterForm_1.RegisterForm('register', 'Register');\r\n        this.userUI = new UserUI_1.UserUI();\r\n        this.storage = new Storage_1.Storage();\r\n        this.mainPage = new MainPage_1.MainPage();\r\n        this.menu = new BurgerMenu_1.BurgerMenu();\r\n        this.wordController = new WordController_1.WordController();\r\n    }\r\n    initRouter() {\r\n        this.router\r\n            .on(() => {\r\n            this.mainPage.renderMain();\r\n            this.router.updatePageLinks();\r\n        })\r\n            .on('/book', async () => {\r\n            this.menu.closeMenu();\r\n            await this.handleTextBook();\r\n            this.router.updatePageLinks();\r\n        })\r\n            .on('/sprint', () => {\r\n            this.menu.closeMenu();\r\n            this.initSprintFromMenu();\r\n        })\r\n            .on('/book/sprint', () => {\r\n            this.initSprintFromBook();\r\n        })\r\n            .on('/audiocall', () => {\r\n            this.initAudioCallfromMenu();\r\n            this.menu.closeMenu();\r\n        })\r\n            .on('/book/audiocall', () => {\r\n            this.initAudioCallfromBook();\r\n        })\r\n            .on('/user', () => {\r\n            this.menu.closeMenu();\r\n            this.userUI.renderUserPage();\r\n            this.router.updatePageLinks();\r\n        })\r\n            .resolve();\r\n    }\r\n    async initApp() {\r\n        this.menu.initBurgerMenu();\r\n        this.textBook.listenLevels(this.handleTextBoookPageUpdate.bind(this));\r\n        this.textBook.listenPagination(this.handleTextBoookPageUpdate.bind(this));\r\n        this.startUserForms();\r\n        this.loginForm.listenForm(this.handleLoginBtn.bind(this));\r\n        this.registerForm.listenForm(this.handleRegistartion.bind(this));\r\n        this.userUI.unAuthorize(this.handleUnLogin.bind(this));\r\n        this.handleUser();\r\n        this.router.updatePageLinks();\r\n    }\r\n    async handleTextBook() {\r\n        const stored = this.storage.getData('textBook');\r\n        const logined = this.storage.getData('UserId');\r\n        if (stored && logined) {\r\n            if (stored.group === 6) {\r\n                const newData = await this.wordController.getUserBookWords();\r\n                this.textBook.updateTextbook(newData, true, 6, 0);\r\n                console.log('Есть локал бук и залогинен, level hard');\r\n            }\r\n            else {\r\n                const newData = await this.api.getAggregatedUserWords(logined, { group: stored.group, page: stored.page, wordsPerPage: String(constants_1.WORDS_PER_PAGE) });\r\n                console.log('Есть локал бук и залогинен');\r\n                this.textBook.updateTextbook(newData, true, stored.group, stored.page);\r\n            }\r\n        }\r\n        else if (stored && !logined) {\r\n            console.log('Есть локал бук и НЕ залогинен');\r\n            const data = await this.api.getWords(stored);\r\n            this.textBook.updateTextbook(data, false, stored.group, stored.page);\r\n        }\r\n        else if (!stored && logined) {\r\n            const newData = await this.api.getAggregatedUserWords(logined, { group: '0', page: '0', wordsPerPage: String(constants_1.WORDS_PER_PAGE) });\r\n            console.log('Не ходит по учебнику и залогинен');\r\n            this.textBook.updateTextbook(newData, true, 0, 0);\r\n        }\r\n        else {\r\n            console.log('Не ходит по учебнику и не залогинен');\r\n            const data = await this.api.getWords({ group: '0', page: '0' });\r\n            this.textBook.updateTextbook(data, false, 0, 0);\r\n        }\r\n        this.textBook.addLinksHandler();\r\n    }\r\n    async handleTextBoookPageUpdate(groupStr, pageStr) {\r\n        this.storage.setData('textBook', `{\"group\": ${groupStr}, \"page\": ${pageStr}}`);\r\n        this.handleTextBook();\r\n    }\r\n    startUserForms() {\r\n        const loginFormHTML = this.loginForm.renderForm();\r\n        const regFormHTML = this.registerForm.renderForm();\r\n        constants_1.REGISTER_BTN.addEventListener('click', () => this.modal.renderModal(regFormHTML));\r\n        constants_1.LOGIN_BTN.addEventListener('click', () => this.modal.renderModal(loginFormHTML));\r\n    }\r\n    async handleLoginBtn(email, password) {\r\n        const object = { email, password };\r\n        const res = await this.api.authorize(object);\r\n        if (typeof res === 'object') {\r\n            this.modal.exitModal();\r\n            this.storage.setData('UserId', res);\r\n            this.userUI.authorise(res);\r\n            this.router.updatePageLinks();\r\n            if (window.location.href.match(/\\/book$/)) {\r\n                await this.handleTextBook();\r\n            }\r\n        }\r\n        else {\r\n            this.modal.showLoginMessage();\r\n        }\r\n    }\r\n    handleUser() {\r\n        console.log('handleUser');\r\n        const stored = this.storage.getData('UserId');\r\n        if (stored) {\r\n            const refreshTokenExpires = stored.tokenExpires\r\n                + (constants_1.REFRESHTOKEN_LIFETIME_IN_HOURS - constants_1.TOKEN_LIFETIME_IN_HOURS) * 60 * 60 * 1000;\r\n            if (refreshTokenExpires > Date.now())\r\n                this.userUI.authorise(stored);\r\n            else {\r\n                this.handleUnLogin();\r\n            }\r\n        }\r\n    }\r\n    async handleRegistartion(name, email, password, errorMessage) {\r\n        const object = { name, email, password };\r\n        const regResponse = await this.api.createUser(object);\r\n        if (typeof regResponse === 'object') {\r\n            this.modal.showMessage(`Успешная регистрация! Добро пожаловать, ${name}`);\r\n            const obj = { email, password };\r\n            setTimeout(() => this.makeNewUser(obj), 3000);\r\n        }\r\n        else {\r\n            // eslint-disable-next-line no-param-reassign\r\n            errorMessage.innerHTML = 'Пользователь с таким e-mail уже существует';\r\n        }\r\n    }\r\n    async makeNewUser(obj) {\r\n        const res = await this.api.authorize(obj);\r\n        if (typeof res === 'object') {\r\n            this.modal.exitModal();\r\n            this.storage.setData('UserId', res);\r\n            this.userUI.authorise(res);\r\n            if (window.location.href.match(/\\/book$/)) {\r\n                await this.handleTextBook();\r\n            }\r\n        }\r\n    }\r\n    handleUnLogin() {\r\n        this.storage.clear();\r\n        this.router.navigate('/');\r\n        this.router.updatePageLinks();\r\n    }\r\n    initSprintFromBook() {\r\n        this.sprint = new Sprint_1.Sprint('book');\r\n        this.sprint.setBookPageAndLevel(this.textBook.currentLevel, this.textBook.currentPage);\r\n        this.sprint.renderGame();\r\n    }\r\n    initSprintFromMenu() {\r\n        this.sprint = new Sprint_1.Sprint('menu');\r\n        this.sprint.renderGame();\r\n    }\r\n    closeSprint() {\r\n        this.sprint?.closeGame();\r\n    }\r\n    initAudioCallfromMenu() {\r\n        const game = new audioCall_1.AudioCall();\r\n        game.start();\r\n    }\r\n    initAudioCallfromBook() {\r\n        const game = new audioCall_1.AudioCall();\r\n        game.start({ group: this.textBook.currentLevel, page: this.textBook.currentPage });\r\n    }\r\n}\r\nexports.Controller = Controller;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SyxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDckYsQ0FBQztDQUNGO0FBMU5ELGdDQTBOQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy9jb250cm9sbGVyL0NvbnRyb2xsZXIudHM/ZTUwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTmF2aWdvIGZyb20gJ25hdmlnbyc7XHJcbmltcG9ydCB7IFRleHRCb29rIH0gZnJvbSAnLi4vdGV4dEJvb2svVGV4dEJvb2snO1xyXG5pbXBvcnQgeyBBcGkgfSBmcm9tICcuLi9Nb2RlbC9hcGknO1xyXG5pbXBvcnQgeyBNb2RhbCB9IGZyb20gJy4uL3V0aWxzL01vZGFsJztcclxuaW1wb3J0IHsgTG9naW5Gb3JtIH0gZnJvbSAnLi4vZm9ybXMvTG9naW5Gb3JtJztcclxuaW1wb3J0IHsgUmVnaXN0ZXJGb3JtIH0gZnJvbSAnLi4vZm9ybXMvUmVnaXN0ZXJGb3JtJztcclxuaW1wb3J0IHtcclxuICBSRUdJU1RFUl9CVE4sIExPR0lOX0JUTiwgTEVWRUxTX09GX1RFWFRCT09LLCBXT1JEU19QRVJfUEFHRSxcclxuICBSRUZSRVNIVE9LRU5fTElGRVRJTUVfSU5fSE9VUlMsIFRPS0VOX0xJRkVUSU1FX0lOX0hPVVJTLFxyXG59IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IFVzZXJVSSB9IGZyb20gJy4uL3VzZXIvVXNlclVJJztcclxuaW1wb3J0IHsgU3ByaW50IH0gZnJvbSAnLi4vc3ByaW50L1NwcmludCc7XHJcbmltcG9ydCB7IEF1ZGlvQ2FsbCB9IGZyb20gJy4uL2F1ZGlvY2FsbC9hdWRpb0NhbGwnO1xyXG5pbXBvcnQgeyBTdG9yYWdlIH0gZnJvbSAnLi4vU3RvcmFnZS9TdG9yYWdlJztcclxuaW1wb3J0IHsgQXV0aG9yaXphdGlvbkRhdGEsIFVzZXJBZ2dyZWdhdGVkV29yZCwgVXNlckNyZWF0aW9uRGF0YSB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBNYWluUGFnZSB9IGZyb20gJy4uL01haW5QYWdlL01haW5QYWdlJztcclxuaW1wb3J0IHsgQnVyZ2VyTWVudSB9IGZyb20gJy4uL3V0aWxzL0J1cmdlck1lbnUnO1xyXG5pbXBvcnQgeyBXb3JkQ29udHJvbGxlciB9IGZyb20gJy4uL1dvcmRDb250cm9sbGVyL1dvcmRDb250cm9sbGVyJztcclxuXHJcbmV4cG9ydCBjbGFzcyBDb250cm9sbGVyIHtcclxuICByb3V0ZXI6IE5hdmlnbztcclxuXHJcbiAgYXBpOiBBcGk7XHJcblxyXG4gIHRleHRCb29rOiBUZXh0Qm9vaztcclxuXHJcbiAgc3ByaW50OiBTcHJpbnQgfCB1bmRlZmluZWQ7XHJcblxyXG4gIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgbG9naW5Gb3JtOiBMb2dpbkZvcm07XHJcblxyXG4gIHJlZ2lzdGVyRm9ybTogUmVnaXN0ZXJGb3JtO1xyXG5cclxuICB1c2VyVUk6IFVzZXJVSTtcclxuXHJcbiAgc3RvcmFnZTogU3RvcmFnZTtcclxuXHJcbiAgbWFpblBhZ2U6IE1haW5QYWdlO1xyXG5cclxuICBtZW51OiBCdXJnZXJNZW51O1xyXG5cclxuICB3b3JkQ29udHJvbGxlcjogV29yZENvbnRyb2xsZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5yb3V0ZXIgPSBuZXcgTmF2aWdvKCcvJywgeyBoYXNoOiB0cnVlIH0pO1xyXG4gICAgdGhpcy5hcGkgPSBuZXcgQXBpKCk7XHJcbiAgICB0aGlzLnRleHRCb29rID0gbmV3IFRleHRCb29rKExFVkVMU19PRl9URVhUQk9PSyk7XHJcbiAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICB0aGlzLmxvZ2luRm9ybSA9IG5ldyBMb2dpbkZvcm0oJ2xvZ2luJywgJ0xvZ2luJyk7XHJcbiAgICB0aGlzLnJlZ2lzdGVyRm9ybSA9IG5ldyBSZWdpc3RlckZvcm0oJ3JlZ2lzdGVyJywgJ1JlZ2lzdGVyJyk7XHJcbiAgICB0aGlzLnVzZXJVSSA9IG5ldyBVc2VyVUkoKTtcclxuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCk7XHJcbiAgICB0aGlzLm1haW5QYWdlID0gbmV3IE1haW5QYWdlKCk7XHJcbiAgICB0aGlzLm1lbnUgPSBuZXcgQnVyZ2VyTWVudSgpO1xyXG4gICAgdGhpcy53b3JkQ29udHJvbGxlciA9IG5ldyBXb3JkQ29udHJvbGxlcigpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGluaXRSb3V0ZXIoKTogdm9pZCB7XHJcbiAgICB0aGlzLnJvdXRlclxyXG4gICAgICAub24oKCkgPT4ge1xyXG4gICAgICAgIHRoaXMubWFpblBhZ2UucmVuZGVyTWFpbigpO1xyXG4gICAgICAgIHRoaXMucm91dGVyLnVwZGF0ZVBhZ2VMaW5rcygpO1xyXG4gICAgICB9KVxyXG4gICAgICAub24oJy9ib29rJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMubWVudS5jbG9zZU1lbnUoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVRleHRCb29rKCk7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIudXBkYXRlUGFnZUxpbmtzKCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbignL3NwcmludCcsICgpID0+IHtcclxuICAgICAgICB0aGlzLm1lbnUuY2xvc2VNZW51KCk7XHJcbiAgICAgICAgdGhpcy5pbml0U3ByaW50RnJvbU1lbnUoKTtcclxuICAgICAgfSlcclxuICAgICAgLm9uKCcvYm9vay9zcHJpbnQnLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5pbml0U3ByaW50RnJvbUJvb2soKTtcclxuICAgICAgfSlcclxuICAgICAgLm9uKCcvYXVkaW9jYWxsJywgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuaW5pdEF1ZGlvQ2FsbGZyb21NZW51KCk7XHJcbiAgICAgICAgdGhpcy5tZW51LmNsb3NlTWVudSgpO1xyXG4gICAgICB9KVxyXG4gICAgICAub24oJy9ib29rL2F1ZGlvY2FsbCcsICgpID0+IHtcclxuICAgICAgICB0aGlzLmluaXRBdWRpb0NhbGxmcm9tQm9vaygpO1xyXG4gICAgICB9KVxyXG4gICAgICAub24oJy91c2VyJywgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMubWVudS5jbG9zZU1lbnUoKTtcclxuICAgICAgICB0aGlzLnVzZXJVSS5yZW5kZXJVc2VyUGFnZSgpO1xyXG4gICAgICAgIHRoaXMucm91dGVyLnVwZGF0ZVBhZ2VMaW5rcygpO1xyXG4gICAgICB9KVxyXG4gICAgICAucmVzb2x2ZSgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGluaXRBcHAoKSB7XHJcbiAgICB0aGlzLm1lbnUuaW5pdEJ1cmdlck1lbnUoKTtcclxuICAgIHRoaXMudGV4dEJvb2subGlzdGVuTGV2ZWxzKHRoaXMuaGFuZGxlVGV4dEJvb29rUGFnZVVwZGF0ZS5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMudGV4dEJvb2subGlzdGVuUGFnaW5hdGlvbih0aGlzLmhhbmRsZVRleHRCb29va1BhZ2VVcGRhdGUuYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLnN0YXJ0VXNlckZvcm1zKCk7XHJcbiAgICB0aGlzLmxvZ2luRm9ybS5saXN0ZW5Gb3JtKHRoaXMuaGFuZGxlTG9naW5CdG4uYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLnJlZ2lzdGVyRm9ybS5saXN0ZW5Gb3JtKHRoaXMuaGFuZGxlUmVnaXN0YXJ0aW9uLmJpbmQodGhpcykpO1xyXG4gICAgdGhpcy51c2VyVUkudW5BdXRob3JpemUodGhpcy5oYW5kbGVVbkxvZ2luLmJpbmQodGhpcykpO1xyXG4gICAgdGhpcy5oYW5kbGVVc2VyKCk7XHJcbiAgICB0aGlzLnJvdXRlci51cGRhdGVQYWdlTGlua3MoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVUZXh0Qm9vaygpIHtcclxuICAgIGNvbnN0IHN0b3JlZCA9IHRoaXMuc3RvcmFnZS5nZXREYXRhKCd0ZXh0Qm9vaycpO1xyXG4gICAgY29uc3QgbG9naW5lZCA9IHRoaXMuc3RvcmFnZS5nZXREYXRhKCdVc2VySWQnKTtcclxuICAgIGlmIChzdG9yZWQgJiYgbG9naW5lZCkge1xyXG4gICAgICBpZiAoc3RvcmVkLmdyb3VwID09PSA2KSB7XHJcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IGF3YWl0IHRoaXMud29yZENvbnRyb2xsZXIuZ2V0VXNlckJvb2tXb3JkcygpO1xyXG4gICAgICAgIHRoaXMudGV4dEJvb2sudXBkYXRlVGV4dGJvb2sobmV3RGF0YSwgdHJ1ZSwgNiwgMCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ9CV0YHRgtGMINC70L7QutCw0Lsg0LHRg9C6INC4INC30LDQu9C+0LPQuNC90LXQvSwgbGV2ZWwgaGFyZCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBhd2FpdCB0aGlzLmFwaS5nZXRBZ2dyZWdhdGVkVXNlcldvcmRzKFxyXG4gICAgICAgICAgbG9naW5lZCxcclxuICAgICAgICAgIHsgZ3JvdXA6IHN0b3JlZC5ncm91cCwgcGFnZTogc3RvcmVkLnBhZ2UsIHdvcmRzUGVyUGFnZTogU3RyaW5nKFdPUkRTX1BFUl9QQUdFKSB9LFxyXG4gICAgICAgICkgYXMgVXNlckFnZ3JlZ2F0ZWRXb3JkW107XHJcbiAgICAgICAgY29uc29sZS5sb2coJ9CV0YHRgtGMINC70L7QutCw0Lsg0LHRg9C6INC4INC30LDQu9C+0LPQuNC90LXQvScpO1xyXG4gICAgICAgIHRoaXMudGV4dEJvb2sudXBkYXRlVGV4dGJvb2sobmV3RGF0YSwgdHJ1ZSwgc3RvcmVkLmdyb3VwLCBzdG9yZWQucGFnZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoc3RvcmVkICYmICFsb2dpbmVkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfQldGB0YLRjCDQu9C+0LrQsNC7INCx0YPQuiDQuCDQndCVINC30LDQu9C+0LPQuNC90LXQvScpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5hcGkuZ2V0V29yZHMoc3RvcmVkKTtcclxuICAgICAgdGhpcy50ZXh0Qm9vay51cGRhdGVUZXh0Ym9vayhkYXRhLCBmYWxzZSwgc3RvcmVkLmdyb3VwLCBzdG9yZWQucGFnZSk7XHJcbiAgICB9IGVsc2UgaWYgKCFzdG9yZWQgJiYgbG9naW5lZCkge1xyXG4gICAgICBjb25zdCBuZXdEYXRhID0gYXdhaXQgdGhpcy5hcGkuZ2V0QWdncmVnYXRlZFVzZXJXb3JkcyhcclxuICAgICAgICBsb2dpbmVkLFxyXG4gICAgICAgIHsgZ3JvdXA6ICcwJywgcGFnZTogJzAnLCB3b3Jkc1BlclBhZ2U6IFN0cmluZyhXT1JEU19QRVJfUEFHRSkgfSxcclxuICAgICAgKSBhcyBVc2VyQWdncmVnYXRlZFdvcmRbXTtcclxuICAgICAgY29uc29sZS5sb2coJ9Cd0LUg0YXQvtC00LjRgiDQv9C+INGD0YfQtdCx0L3QuNC60YMg0Lgg0LfQsNC70L7Qs9C40L3QtdC9Jyk7XHJcbiAgICAgIHRoaXMudGV4dEJvb2sudXBkYXRlVGV4dGJvb2sobmV3RGF0YSwgdHJ1ZSwgMCwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZygn0J3QtSDRhdC+0LTQuNGCINC/0L4g0YPRh9C10LHQvdC40LrRgyDQuCDQvdC1INC30LDQu9C+0LPQuNC90LXQvScpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5hcGkuZ2V0V29yZHMoeyBncm91cDogJzAnLCBwYWdlOiAnMCcgfSk7XHJcbiAgICAgIHRoaXMudGV4dEJvb2sudXBkYXRlVGV4dGJvb2soZGF0YSwgZmFsc2UsIDAsIDApO1xyXG4gICAgfVxyXG4gICAgdGhpcy50ZXh0Qm9vay5hZGRMaW5rc0hhbmRsZXIoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVUZXh0Qm9vb2tQYWdlVXBkYXRlKGdyb3VwU3RyOiBzdHJpbmcsIHBhZ2VTdHI6IHN0cmluZykge1xyXG4gICAgdGhpcy5zdG9yYWdlLnNldERhdGEoJ3RleHRCb29rJywgYHtcImdyb3VwXCI6ICR7Z3JvdXBTdHJ9LCBcInBhZ2VcIjogJHtwYWdlU3RyfX1gKTtcclxuICAgIHRoaXMuaGFuZGxlVGV4dEJvb2soKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhcnRVc2VyRm9ybXMoKSB7XHJcbiAgICBjb25zdCBsb2dpbkZvcm1IVE1MID0gdGhpcy5sb2dpbkZvcm0ucmVuZGVyRm9ybSgpO1xyXG4gICAgY29uc3QgcmVnRm9ybUhUTUwgPSB0aGlzLnJlZ2lzdGVyRm9ybS5yZW5kZXJGb3JtKCk7XHJcbiAgICBSRUdJU1RFUl9CVE4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm1vZGFsLnJlbmRlck1vZGFsKHJlZ0Zvcm1IVE1MKSk7XHJcbiAgICBMT0dJTl9CVE4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm1vZGFsLnJlbmRlck1vZGFsKGxvZ2luRm9ybUhUTUwpKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVMb2dpbkJ0bihlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBvYmplY3Q6IFBpY2s8VXNlckNyZWF0aW9uRGF0YSwgJ2VtYWlsJyB8ICdwYXNzd29yZCc+ID0geyBlbWFpbCwgcGFzc3dvcmQgfTtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuYXBpLmF1dGhvcml6ZShvYmplY3QpO1xyXG4gICAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHRoaXMubW9kYWwuZXhpdE1vZGFsKCk7XHJcbiAgICAgIHRoaXMuc3RvcmFnZS5zZXREYXRhKCdVc2VySWQnLCByZXMpO1xyXG4gICAgICB0aGlzLnVzZXJVSS5hdXRob3Jpc2UocmVzKTtcclxuICAgICAgdGhpcy5yb3V0ZXIudXBkYXRlUGFnZUxpbmtzKCk7XHJcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5tYXRjaCgvXFwvYm9vayQvKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlVGV4dEJvb2soKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tb2RhbC5zaG93TG9naW5NZXNzYWdlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgaGFuZGxlVXNlcigpIHtcclxuICAgIGNvbnNvbGUubG9nKCdoYW5kbGVVc2VyJyk7XHJcbiAgICBjb25zdCBzdG9yZWQgPSB0aGlzLnN0b3JhZ2UuZ2V0RGF0YSgnVXNlcklkJykgYXMgQXV0aG9yaXphdGlvbkRhdGEgfCBudWxsO1xyXG4gICAgaWYgKHN0b3JlZCkge1xyXG4gICAgICBjb25zdCByZWZyZXNoVG9rZW5FeHBpcmVzID0gc3RvcmVkLnRva2VuRXhwaXJlc1xyXG4gICAgICArIChSRUZSRVNIVE9LRU5fTElGRVRJTUVfSU5fSE9VUlMgLSBUT0tFTl9MSUZFVElNRV9JTl9IT1VSUykgKiA2MCAqIDYwICogMTAwMDtcclxuICAgICAgaWYgKHJlZnJlc2hUb2tlbkV4cGlyZXMgPiBEYXRlLm5vdygpKSB0aGlzLnVzZXJVSS5hdXRob3Jpc2Uoc3RvcmVkKTtcclxuICAgICAgZWxzZSB7IHRoaXMuaGFuZGxlVW5Mb2dpbigpOyB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgaGFuZGxlUmVnaXN0YXJ0aW9uKFxyXG4gICAgbmFtZTogc3RyaW5nLFxyXG4gICAgZW1haWw6IHN0cmluZyxcclxuICAgIHBhc3N3b3JkOiBzdHJpbmcsXHJcbiAgICBlcnJvck1lc3NhZ2U6IEhUTUxFbGVtZW50LFxyXG4gICkge1xyXG4gICAgY29uc3Qgb2JqZWN0OiBVc2VyQ3JlYXRpb25EYXRhID0geyBuYW1lLCBlbWFpbCwgcGFzc3dvcmQgfTtcclxuICAgIGNvbnN0IHJlZ1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGkuY3JlYXRlVXNlcihvYmplY3QpO1xyXG4gICAgaWYgKHR5cGVvZiByZWdSZXNwb25zZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhpcy5tb2RhbC5zaG93TWVzc2FnZShg0KPRgdC/0LXRiNC90LDRjyDRgNC10LPQuNGB0YLRgNCw0YbQuNGPISDQlNC+0LHRgNC+INC/0L7QttCw0LvQvtCy0LDRgtGMLCAke25hbWV9YCk7XHJcbiAgICAgIGNvbnN0IG9iajogUGljazxVc2VyQ3JlYXRpb25EYXRhLCAnZW1haWwnIHwgJ3Bhc3N3b3JkJz4gPSB7IGVtYWlsLCBwYXNzd29yZCB9O1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubWFrZU5ld1VzZXIob2JqKSwgMzAwMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgZXJyb3JNZXNzYWdlLmlubmVySFRNTCA9ICfQn9C+0LvRjNC30L7QstCw0YLQtdC70Ywg0YEg0YLQsNC60LjQvCBlLW1haWwg0YPQttC1INGB0YPRidC10YHRgtCy0YPQtdGCJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbWFrZU5ld1VzZXIob2JqOiBQaWNrPFVzZXJDcmVhdGlvbkRhdGEsICdlbWFpbCcgfCAncGFzc3dvcmQnPikge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5hcGkuYXV0aG9yaXplKG9iaik7XHJcbiAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhpcy5tb2RhbC5leGl0TW9kYWwoKTtcclxuICAgICAgdGhpcy5zdG9yYWdlLnNldERhdGEoJ1VzZXJJZCcsIHJlcyk7XHJcbiAgICAgIHRoaXMudXNlclVJLmF1dGhvcmlzZShyZXMpO1xyXG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goL1xcL2Jvb2skLykpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVRleHRCb29rKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlVW5Mb2dpbigpIHtcclxuICAgIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xyXG4gICAgdGhpcy5yb3V0ZXIubmF2aWdhdGUoJy8nKTtcclxuICAgIHRoaXMucm91dGVyLnVwZGF0ZVBhZ2VMaW5rcygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0U3ByaW50RnJvbUJvb2soKSB7XHJcbiAgICB0aGlzLnNwcmludCA9IG5ldyBTcHJpbnQoJ2Jvb2snKTtcclxuICAgIHRoaXMuc3ByaW50LnNldEJvb2tQYWdlQW5kTGV2ZWwodGhpcy50ZXh0Qm9vay5jdXJyZW50TGV2ZWwsIHRoaXMudGV4dEJvb2suY3VycmVudFBhZ2UpO1xyXG4gICAgdGhpcy5zcHJpbnQucmVuZGVyR2FtZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0U3ByaW50RnJvbU1lbnUoKSB7XHJcbiAgICB0aGlzLnNwcmludCA9IG5ldyBTcHJpbnQoJ21lbnUnKTtcclxuICAgIHRoaXMuc3ByaW50LnJlbmRlckdhbWUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2xvc2VTcHJpbnQoKSB7XHJcbiAgICB0aGlzLnNwcmludD8uY2xvc2VHYW1lKCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgaW5pdEF1ZGlvQ2FsbGZyb21NZW51KCkge1xyXG4gICAgY29uc3QgZ2FtZSA9IG5ldyBBdWRpb0NhbGwoKTtcclxuICAgIGdhbWUuc3RhcnQoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBpbml0QXVkaW9DYWxsZnJvbUJvb2soKSB7XHJcbiAgICBjb25zdCBnYW1lID0gbmV3IEF1ZGlvQ2FsbCgpO1xyXG4gICAgZ2FtZS5zdGFydCh7IGdyb3VwOiB0aGlzLnRleHRCb29rLmN1cnJlbnRMZXZlbCwgcGFnZTogdGhpcy50ZXh0Qm9vay5jdXJyZW50UGFnZSB9KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2962\n")},6205:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Form = void 0;\r\nconst constants_1 = __webpack_require__(5004);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nclass Form {\r\n    constructor(formName, btnName) {\r\n        this.form = (0, createNode_1.default)({ tag: 'form', classes: ['form'], atributesAdnValues: [['id', `${formName}-form`]] });\r\n        this.errorMessage = (0, createNode_1.default)({ tag: 'p', classes: ['error-message'] });\r\n        this.submitBtn = (0, createNode_1.default)({\r\n            tag: 'button', classes: ['btn', 'btn-submit'], inner: `${btnName}`, atributesAdnValues: [['type', 'button']],\r\n        });\r\n    }\r\n    renderForm() {\r\n        const formWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['form-wrapper'] });\r\n        this.form.append(this.errorMessage, this.submitBtn);\r\n        formWrapper.append(this.form);\r\n        return formWrapper;\r\n    }\r\n    createInput(input) {\r\n        const inputName = input.getAttribute('data-name');\r\n        const inputWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['input-wrapper'] });\r\n        const error = (0, createNode_1.default)({ tag: 'div', classes: ['error-in-form'], inner: `Пожалуйста введите ${inputName}` });\r\n        error.style.display = 'none';\r\n        inputWrapper.append(input, error);\r\n        return inputWrapper;\r\n    }\r\n    checkInputValue(inputWrapper) {\r\n        const input = inputWrapper.querySelector('input');\r\n        const error = inputWrapper.querySelector('.error-in-form');\r\n        const value = input.value.trim();\r\n        if (!value) {\r\n            error.style.display = 'block';\r\n            error.innerHTML = 'Заполните поле';\r\n            return false;\r\n        }\r\n        if (input.type === 'password') {\r\n            if (value.length < 9) {\r\n                error.style.display = 'block';\r\n                error.innerHTML = 'Длина пароля должна быть не менее 8 знаков';\r\n                return false;\r\n            }\r\n        }\r\n        if (input.type === 'email') {\r\n            if (!value.match(constants_1.EMAIL_REGEX)) {\r\n                error.style.display = 'block';\r\n                error.innerHTML = 'Введите правильный email';\r\n                return false;\r\n            }\r\n        }\r\n        error.style.display = 'none';\r\n        return true;\r\n    }\r\n    validateForm(form) {\r\n        console.log('Validation started');\r\n        const inputs = [...form.querySelectorAll('.input-wrapper')];\r\n        const validated = inputs.every((input) => this.checkInputValue(input));\r\n        if (validated)\r\n            return true;\r\n        return false;\r\n    }\r\n}\r\nexports.Form = Form;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxLQUFLLENBQUM7YUFDZDtTQUNGO1FBQ0QsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTtZQUMxQixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyx1QkFBVyxDQUFDLEVBQUU7Z0JBQzdCLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztnQkFDOUIsS0FBSyxDQUFDLFNBQVMsR0FBRywwQkFBMEIsQ0FBQztnQkFDN0MsT0FBTyxLQUFLLENBQUM7YUFDZDtTQUNGO1FBQ0QsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQzdCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVNLFlBQVksQ0FBQyxJQUFxQjtRQUN2QyxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDbEMsTUFBTSxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBYyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7UUFDekUsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksU0FBUztZQUFFLE9BQU8sSUFBSSxDQUFDO1FBQzNCLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztDQUNGO0FBakVELG9CQWlFQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy9mb3Jtcy9Gb3JtLnRzP2IyM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1BSUxfUkVHRVggfSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xyXG5pbXBvcnQgY3JlYXRlTm9kZSBmcm9tICcuLi91dGlscy9jcmVhdGVOb2RlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBGb3JtIHtcclxuICBmb3JtOiBIVE1MRm9ybUVsZW1lbnQ7XHJcblxyXG4gIHN1Ym1pdEJ0bjogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcblxyXG4gIGVycm9yTWVzc2FnZTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGZvcm1OYW1lOiBzdHJpbmcsIGJ0bk5hbWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5mb3JtID0gY3JlYXRlTm9kZSh7IHRhZzogJ2Zvcm0nLCBjbGFzc2VzOiBbJ2Zvcm0nXSwgYXRyaWJ1dGVzQWRuVmFsdWVzOiBbWydpZCcsIGAke2Zvcm1OYW1lfS1mb3JtYF1dIH0pIGFzIEhUTUxGb3JtRWxlbWVudDtcclxuICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ2Vycm9yLW1lc3NhZ2UnXSB9KTtcclxuICAgIHRoaXMuc3VibWl0QnRuID0gY3JlYXRlTm9kZSh7XHJcbiAgICAgIHRhZzogJ2J1dHRvbicsIGNsYXNzZXM6IFsnYnRuJywgJ2J0bi1zdWJtaXQnXSwgaW5uZXI6IGAke2J0bk5hbWV9YCwgYXRyaWJ1dGVzQWRuVmFsdWVzOiBbWyd0eXBlJywgJ2J1dHRvbiddXSxcclxuICAgIH0pIGFzIEhUTUxCdXR0b25FbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbmRlckZvcm0oKTogSFRNTERpdkVsZW1lbnQge1xyXG4gICAgY29uc3QgZm9ybVdyYXBwZXIgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydmb3JtLXdyYXBwZXInXSB9KSBhcyBIVE1MRGl2RWxlbWVudDtcclxuICAgIHRoaXMuZm9ybS5hcHBlbmQodGhpcy5lcnJvck1lc3NhZ2UsIHRoaXMuc3VibWl0QnRuKTtcclxuICAgIGZvcm1XcmFwcGVyLmFwcGVuZCh0aGlzLmZvcm0pO1xyXG4gICAgcmV0dXJuIGZvcm1XcmFwcGVyO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGNyZWF0ZUlucHV0KGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSB7XHJcbiAgICBjb25zdCBpbnB1dE5hbWUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScpO1xyXG4gICAgY29uc3QgaW5wdXRXcmFwcGVyID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnaW5wdXQtd3JhcHBlciddIH0pO1xyXG4gICAgY29uc3QgZXJyb3IgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydlcnJvci1pbi1mb3JtJ10sIGlubmVyOiBg0J/QvtC20LDQu9GD0LnRgdGC0LAg0LLQstC10LTQuNGC0LUgJHtpbnB1dE5hbWV9YCB9KTtcclxuICAgIGVycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBpbnB1dFdyYXBwZXIuYXBwZW5kKGlucHV0LCBlcnJvcik7XHJcbiAgICByZXR1cm4gaW5wdXRXcmFwcGVyO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGNoZWNrSW5wdXRWYWx1ZShpbnB1dFdyYXBwZXI6IEhUTUxFbGVtZW50KSB7XHJcbiAgICBjb25zdCBpbnB1dDogSFRNTElucHV0RWxlbWVudCA9IGlucHV0V3JhcHBlci5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBjb25zdCBlcnJvcjogSFRNTEVsZW1lbnQgPSBpbnB1dFdyYXBwZXIucXVlcnlTZWxlY3RvcignLmVycm9yLWluLWZvcm0nKSBhcyBIVE1MRWxlbWVudDtcclxuICAgIGNvbnN0IHZhbHVlID0gaW5wdXQudmFsdWUudHJpbSgpO1xyXG4gICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICBlcnJvci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgZXJyb3IuaW5uZXJIVE1MID0gJ9CX0LDQv9C+0LvQvdC40YLQtSDQv9C+0LvQtSc7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dC50eXBlID09PSAncGFzc3dvcmQnKSB7XHJcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCA5KSB7XHJcbiAgICAgICAgZXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgZXJyb3IuaW5uZXJIVE1MID0gJ9CU0LvQuNC90LAg0L/QsNGA0L7Qu9GPINC00L7Qu9C20L3QsCDQsdGL0YLRjCDQvdC1INC80LXQvdC10LUgOCDQt9C90LDQutC+0LInO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0LnR5cGUgPT09ICdlbWFpbCcpIHtcclxuICAgICAgaWYgKCF2YWx1ZS5tYXRjaChFTUFJTF9SRUdFWCkpIHtcclxuICAgICAgICBlcnJvci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICBlcnJvci5pbm5lckhUTUwgPSAn0JLQstC10LTQuNGC0LUg0L/RgNCw0LLQuNC70YzQvdGL0LkgZW1haWwnO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHZhbGlkYXRlRm9ybShmb3JtOiBIVE1MRm9ybUVsZW1lbnQpIHtcclxuICAgIGNvbnNvbGUubG9nKCdWYWxpZGF0aW9uIHN0YXJ0ZWQnKTtcclxuICAgIGNvbnN0IGlucHV0cyA9IFsuLi5mb3JtLnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEVsZW1lbnQ+KCcuaW5wdXQtd3JhcHBlcicpXTtcclxuICAgIGNvbnN0IHZhbGlkYXRlZCA9IGlucHV0cy5ldmVyeSgoaW5wdXQpID0+IHRoaXMuY2hlY2tJbnB1dFZhbHVlKGlucHV0KSk7XHJcbiAgICBpZiAodmFsaWRhdGVkKSByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6205\n")},5674:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LoginForm = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst Form_1 = __webpack_require__(6205);\r\nclass LoginForm extends Form_1.Form {\r\n    constructor(formName, btnName) {\r\n        super(formName, btnName);\r\n        this.formName = formName;\r\n        this.btnName = btnName;\r\n        this.email = (0, createNode_1.default)({ tag: 'input', classes: ['email-input'], atributesAdnValues: [['type', 'email'], ['placeholder', 'Your e-mail'], ['data-name', 'e-mail']] });\r\n        this.password = (0, createNode_1.default)({ tag: 'input', classes: ['password-input'], atributesAdnValues: [['type', 'password'], ['placeholder', 'Password'], ['autocomplete', 'on'], ['data-name', 'пароль']] });\r\n        this.emailWrapper = super.createInput(this.email);\r\n        this.passWrapper = super.createInput(this.password);\r\n    }\r\n    renderForm() {\r\n        const formWrapper = super.renderForm();\r\n        this.form.prepend(this.emailWrapper, this.passWrapper);\r\n        return formWrapper;\r\n    }\r\n    listenForm(callback) {\r\n        this.submitBtn.addEventListener('click', () => {\r\n            const validate = super.validateForm(this.form);\r\n            if (validate) {\r\n                callback(this.email.value, this.password.value);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.LoginForm = LoginForm;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY3NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnRUFBNkM7QUFDN0MseUNBQThCO0FBRTlCLE1BQWEsU0FBVSxTQUFRLFdBQUk7SUFhakMsWUFBWSxRQUFnQixFQUFFLE9BQWU7UUFDM0MsS0FBSyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsS0FBSyxHQUFHLHdCQUFVLEVBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsYUFBYSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFxQixDQUFDO1FBQzFMLElBQUksQ0FBQyxRQUFRLEdBQUcsd0JBQVUsRUFBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxrQkFBa0IsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLFVBQVUsQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBcUIsQ0FBQztRQUN4TixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVNLFVBQVU7UUFDZixNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkQsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxRQUE4QztRQUM5RCxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7WUFDNUMsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDL0MsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDakQ7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQXJDRCw4QkFxQ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvZm9ybXMvTG9naW5Gb3JtLnRzP2E0ODEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZU5vZGUgZnJvbSAnLi4vdXRpbHMvY3JlYXRlTm9kZSc7XHJcbmltcG9ydCB7IEZvcm0gfSBmcm9tICcuL0Zvcm0nO1xyXG5cclxuZXhwb3J0IGNsYXNzIExvZ2luRm9ybSBleHRlbmRzIEZvcm0ge1xyXG4gIGVtYWlsOiBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICBwYXNzd29yZDogSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgZm9ybU5hbWU6IHN0cmluZztcclxuXHJcbiAgYnRuTmFtZTogc3RyaW5nO1xyXG5cclxuICBlbWFpbFdyYXBwZXI6IEhUTUxFbGVtZW50O1xyXG5cclxuICBwYXNzV3JhcHBlcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGZvcm1OYW1lOiBzdHJpbmcsIGJ0bk5hbWU6IHN0cmluZykge1xyXG4gICAgc3VwZXIoZm9ybU5hbWUsIGJ0bk5hbWUpO1xyXG4gICAgdGhpcy5mb3JtTmFtZSA9IGZvcm1OYW1lO1xyXG4gICAgdGhpcy5idG5OYW1lID0gYnRuTmFtZTtcclxuICAgIHRoaXMuZW1haWwgPSBjcmVhdGVOb2RlKHsgdGFnOiAnaW5wdXQnLCBjbGFzc2VzOiBbJ2VtYWlsLWlucHV0J10sIGF0cmlidXRlc0FkblZhbHVlczogW1sndHlwZScsICdlbWFpbCddLCBbJ3BsYWNlaG9sZGVyJywgJ1lvdXIgZS1tYWlsJ10sIFsnZGF0YS1uYW1lJywgJ2UtbWFpbCddXSB9KSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgdGhpcy5wYXNzd29yZCA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdpbnB1dCcsIGNsYXNzZXM6IFsncGFzc3dvcmQtaW5wdXQnXSwgYXRyaWJ1dGVzQWRuVmFsdWVzOiBbWyd0eXBlJywgJ3Bhc3N3b3JkJ10sIFsncGxhY2Vob2xkZXInLCAnUGFzc3dvcmQnXSwgWydhdXRvY29tcGxldGUnLCAnb24nXSwgWydkYXRhLW5hbWUnLCAn0L/QsNGA0L7Qu9GMJ11dIH0pIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICB0aGlzLmVtYWlsV3JhcHBlciA9IHN1cGVyLmNyZWF0ZUlucHV0KHRoaXMuZW1haWwpO1xyXG4gICAgdGhpcy5wYXNzV3JhcHBlciA9IHN1cGVyLmNyZWF0ZUlucHV0KHRoaXMucGFzc3dvcmQpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbmRlckZvcm0oKTogSFRNTERpdkVsZW1lbnQge1xyXG4gICAgY29uc3QgZm9ybVdyYXBwZXIgPSBzdXBlci5yZW5kZXJGb3JtKCk7XHJcbiAgICB0aGlzLmZvcm0ucHJlcGVuZCh0aGlzLmVtYWlsV3JhcHBlciwgdGhpcy5wYXNzV3JhcHBlcik7XHJcbiAgICByZXR1cm4gZm9ybVdyYXBwZXI7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbGlzdGVuRm9ybShjYWxsYmFjazogKG1haWw6IHN0cmluZywgcGFzczogc3RyaW5nKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLnN1Ym1pdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgY29uc3QgdmFsaWRhdGUgPSBzdXBlci52YWxpZGF0ZUZvcm0odGhpcy5mb3JtKTtcclxuICAgICAgaWYgKHZhbGlkYXRlKSB7XHJcbiAgICAgICAgY2FsbGJhY2sodGhpcy5lbWFpbC52YWx1ZSwgdGhpcy5wYXNzd29yZC52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5674\n")},9441:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RegisterForm = void 0;\r\nconst Form_1 = __webpack_require__(6205);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst functions_1 = __webpack_require__(9593);\r\nclass RegisterForm extends Form_1.Form {\r\n    constructor(formName, btnName) {\r\n        super(formName, btnName);\r\n        this.name = (0, createNode_1.default)({ tag: 'input', classes: ['name-input'], atributesAdnValues: [['type', 'text'], ['placeholder', 'Ваше имя'], ['data-name', 'Имя'], ['autocomplete', 'off']] });\r\n        this.email = (0, createNode_1.default)({ tag: 'input', classes: ['email-input'], atributesAdnValues: [['type', 'email'], ['placeholder', 'Ваш e-mail'], ['data-name', 'e-mail'], ['autocomplete', 'off']] });\r\n        this.password = (0, createNode_1.default)({ tag: 'input', classes: ['password-input'], atributesAdnValues: [['type', 'password'], ['placeholder', 'Придумайте пароль > 8 символов'], ['autocomplete', 'new-password'], ['data-name', 'Пароль']] });\r\n        this.submitBtn = (0, createNode_1.default)({ tag: 'button', classes: ['btn', 'btn-submit'], inner: 'Зарегистрироваться' });\r\n        this.emailWrapper = super.createInput(this.email);\r\n        this.passWrapper = super.createInput(this.password);\r\n        this.nameWrapper = super.createInput(this.name);\r\n    }\r\n    renderForm() {\r\n        const formWrapper = super.renderForm();\r\n        this.form.prepend(this.nameWrapper, this.emailWrapper, this.passWrapper);\r\n        return formWrapper;\r\n    }\r\n    listenForm(callback) {\r\n        this.submitBtn.addEventListener('click', (e) => {\r\n            e.preventDefault();\r\n            this.errorMessage.innerHTML = '';\r\n            const validated = this.validateForm();\r\n            if (validated) {\r\n                const userName = (0, functions_1.makeFirslLetterUpperCase)(this.name.value);\r\n                callback(userName, this.email.value, this.password.value, this.errorMessage);\r\n            }\r\n        });\r\n    }\r\n    validateForm() {\r\n        const validated = super.validateForm(this.form);\r\n        return validated;\r\n    }\r\n}\r\nexports.RegisterForm = RegisterForm;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQzlFO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU0sWUFBWTtRQUNqQixNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUEvQ0Qsb0NBK0NDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL2Zvcm1zL1JlZ2lzdGVyRm9ybS50cz8xMzY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcm0gfSBmcm9tICcuL0Zvcm0nO1xyXG5pbXBvcnQgY3JlYXRlTm9kZSBmcm9tICcuLi91dGlscy9jcmVhdGVOb2RlJztcclxuaW1wb3J0IHsgbWFrZUZpcnNsTGV0dGVyVXBwZXJDYXNlIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3Rpb25zJztcclxuXHJcbmV4cG9ydCBjbGFzcyBSZWdpc3RlckZvcm0gZXh0ZW5kcyBGb3JtIHtcclxuICBuYW1lOiBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICBuYW1lV3JhcHBlcjogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIGVtYWlsOiBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICBwYXNzd29yZDogSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgZW1haWxXcmFwcGVyOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgcGFzc1dyYXBwZXI6IEhUTUxFbGVtZW50O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihmb3JtTmFtZTogc3RyaW5nLCBidG5OYW1lOiBzdHJpbmcpIHtcclxuICAgIHN1cGVyKGZvcm1OYW1lLCBidG5OYW1lKTtcclxuICAgIHRoaXMubmFtZSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdpbnB1dCcsIGNsYXNzZXM6IFsnbmFtZS1pbnB1dCddLCBhdHJpYnV0ZXNBZG5WYWx1ZXM6IFtbJ3R5cGUnLCAndGV4dCddLCBbJ3BsYWNlaG9sZGVyJywgJ9CS0LDRiNC1INC40LzRjyddLCBbJ2RhdGEtbmFtZScsICfQmNC80Y8nXSwgWydhdXRvY29tcGxldGUnLCAnb2ZmJ11dIH0pIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICB0aGlzLmVtYWlsID0gY3JlYXRlTm9kZSh7IHRhZzogJ2lucHV0JywgY2xhc3NlczogWydlbWFpbC1pbnB1dCddLCBhdHJpYnV0ZXNBZG5WYWx1ZXM6IFtbJ3R5cGUnLCAnZW1haWwnXSwgWydwbGFjZWhvbGRlcicsICfQktCw0YggZS1tYWlsJ10sIFsnZGF0YS1uYW1lJywgJ2UtbWFpbCddLCBbJ2F1dG9jb21wbGV0ZScsICdvZmYnXV0gfSkgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgIHRoaXMucGFzc3dvcmQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnaW5wdXQnLCBjbGFzc2VzOiBbJ3Bhc3N3b3JkLWlucHV0J10sIGF0cmlidXRlc0FkblZhbHVlczogW1sndHlwZScsICdwYXNzd29yZCddLCBbJ3BsYWNlaG9sZGVyJywgJ9Cf0YDQuNC00YPQvNCw0LnRgtC1INC/0LDRgNC+0LvRjCA+IDgg0YHQuNC80LLQvtC70L7QsiddLCBbJ2F1dG9jb21wbGV0ZScsICduZXctcGFzc3dvcmQnXSwgWydkYXRhLW5hbWUnLCAn0J/QsNGA0L7Qu9GMJ11dIH0pIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICB0aGlzLnN1Ym1pdEJ0biA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdidXR0b24nLCBjbGFzc2VzOiBbJ2J0bicsICdidG4tc3VibWl0J10sIGlubmVyOiAn0JfQsNGA0LXQs9C40YHRgtGA0LjRgNC+0LLQsNGC0YzRgdGPJyB9KSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHRoaXMuZW1haWxXcmFwcGVyID0gc3VwZXIuY3JlYXRlSW5wdXQodGhpcy5lbWFpbCk7XHJcbiAgICB0aGlzLnBhc3NXcmFwcGVyID0gc3VwZXIuY3JlYXRlSW5wdXQodGhpcy5wYXNzd29yZCk7XHJcbiAgICB0aGlzLm5hbWVXcmFwcGVyID0gc3VwZXIuY3JlYXRlSW5wdXQodGhpcy5uYW1lKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZW5kZXJGb3JtKCkge1xyXG4gICAgY29uc3QgZm9ybVdyYXBwZXIgPSBzdXBlci5yZW5kZXJGb3JtKCk7XHJcbiAgICB0aGlzLmZvcm0ucHJlcGVuZCh0aGlzLm5hbWVXcmFwcGVyLCB0aGlzLmVtYWlsV3JhcHBlciwgdGhpcy5wYXNzV3JhcHBlcik7XHJcbiAgICByZXR1cm4gZm9ybVdyYXBwZXI7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbGlzdGVuRm9ybShjYWxsYmFjazpcclxuICAobmFtZTogc3RyaW5nLCBtYWlsOiBzdHJpbmcsIHBhc3M6IHN0cmluZywgZXJyb3JNZXNzYWdlOiBIVE1MRWxlbWVudCkgPT4gdm9pZCkge1xyXG4gICAgdGhpcy5zdWJtaXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZTogRXZlbnQpID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB0aGlzLmVycm9yTWVzc2FnZS5pbm5lckhUTUwgPSAnJztcclxuICAgICAgY29uc3QgdmFsaWRhdGVkID0gdGhpcy52YWxpZGF0ZUZvcm0oKTtcclxuICAgICAgaWYgKHZhbGlkYXRlZCkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJOYW1lID0gbWFrZUZpcnNsTGV0dGVyVXBwZXJDYXNlKHRoaXMubmFtZS52YWx1ZSk7XHJcbiAgICAgICAgY2FsbGJhY2sodXNlck5hbWUsIHRoaXMuZW1haWwudmFsdWUsIHRoaXMucGFzc3dvcmQudmFsdWUsIHRoaXMuZXJyb3JNZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdmFsaWRhdGVGb3JtKCkge1xyXG4gICAgY29uc3QgdmFsaWRhdGVkID0gc3VwZXIudmFsaWRhdGVGb3JtKHRoaXMuZm9ybSk7XHJcbiAgICByZXR1cm4gdmFsaWRhdGVkO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9441\n")},2956:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Sprint = void 0;\r\nconst api_1 = __webpack_require__(1341);\r\nconst functions_1 = __webpack_require__(9593);\r\nconst constants_1 = __webpack_require__(5004);\r\nconst WordController_1 = __webpack_require__(3584);\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst convertAggregatedWordToWord_1 = __webpack_require__(1682);\r\nconst enums_1 = __webpack_require__(8875);\r\nclass Sprint {\r\n    constructor(mode) {\r\n        this.mode = mode;\r\n        this.api = api_1.api;\r\n        this.wordController = new WordController_1.WordController();\r\n        this.storage = new Storage_1.Storage();\r\n        this.wordsInGame = [];\r\n        this.score = 0;\r\n        this.POINTS_FOR_WORD = 10;\r\n        this.multiplier = 1;\r\n        this.seriesOfCorrect = 0;\r\n        this.trueWords = [];\r\n        this.falseWords = [];\r\n        this.bookPage = 0;\r\n        this.bookLevel = 0;\r\n        this.trueAnswerSound = this.createAnswerSoud(true);\r\n        this.falseAnswerSound = this.createAnswerSoud(false);\r\n        this.mute = false;\r\n        this.keyListener = this.selectAnswerByKey.bind(this);\r\n        this.linksHandler = this.closeGameByLink.bind(this);\r\n    }\r\n    renderGame() {\r\n        const body = document.querySelector('.body');\r\n        const main = document.querySelector('.main');\r\n        const sprint = (0, functions_1.createHTMLElement)('section', ['sprint']);\r\n        body.classList.add('body--sprint');\r\n        main.innerHTML = '';\r\n        const btnClose = (0, functions_1.createHTMLElement)('a', ['sprint__close'], [['href', '/'], ['data-navigo', 'true']]);\r\n        if (this.mode === 'book') {\r\n            btnClose.href = '/book';\r\n            sprint.append(btnClose);\r\n            this.startGame();\r\n        }\r\n        else if (this.mode === 'menu') {\r\n            const select = this.renderSelectLevel();\r\n            sprint.append(select, btnClose);\r\n        }\r\n        main.append(sprint);\r\n        this.addLinksHandler();\r\n    }\r\n    renderSelectLevel() {\r\n        const select = (0, functions_1.createHTMLElement)('div', ['sprint__select']);\r\n        const selectTitle = (0, functions_1.createHTMLElement)('h2', ['sprint__select-title'], undefined, 'Спринт');\r\n        const selectDescription = (0, functions_1.createHTMLElement)('p', ['sprint__select-descr'], undefined, 'Учит быстро переводить на ваш родной язык');\r\n        const selectText = (0, functions_1.createHTMLElement)('p', ['sprint__select-text'], undefined, 'Выберите уровень:');\r\n        const levels = (0, functions_1.createHTMLElement)('div', ['sprint__levels']);\r\n        for (let i = 1; i <= 6; i += 1) {\r\n            const level = (0, functions_1.createHTMLElement)('div', ['sprint__level'], [['data-level', `${i - 1}`]], `${i}`);\r\n            level.addEventListener('click', (e) => {\r\n                const target = e.target;\r\n                const levelNumber = target.dataset.level;\r\n                this.currentLevel = levelNumber;\r\n                this.startGame();\r\n            });\r\n            levels.append(level);\r\n        }\r\n        select.append(selectTitle, selectDescription, selectText, levels);\r\n        return select;\r\n    }\r\n    async startGame() {\r\n        if (this.mode === 'menu') {\r\n            const select = document.querySelector('.sprint__select');\r\n            select.remove();\r\n            await this.getWordsInLevel(this.currentLevel);\r\n        }\r\n        else if (this.mode === 'book') {\r\n            if (this.bookLevel < 6) {\r\n                await this.getWordsOnPage(String(this.bookLevel), String(this.bookPage));\r\n            }\r\n            else {\r\n                this.wordsInGame = await this.getHardWords();\r\n            }\r\n        }\r\n        const sprint = document.querySelector('.sprint');\r\n        const ready = (0, functions_1.createHTMLElement)('div', ['sprint__ready']);\r\n        const timerTitle = (0, functions_1.createHTMLElement)('h2', ['timer__title'], undefined, 'Приготовьтесь');\r\n        sprint.append(ready);\r\n        this.renderTimer(ready, 'timer--ready');\r\n        ready.append(timerTitle);\r\n        const randomPair = this.getRandomPair();\r\n        this.startTimer('timer--ready', 3, this.renderGameContol.bind(this, randomPair.word, randomPair.wordTranslate));\r\n    }\r\n    renderTimer(container, className) {\r\n        const timer = (0, functions_1.createHTMLElement)('div', ['timer', className]);\r\n        timer.innerHTML = `\r\n    <span class=\"timer__time\"></span>\r\n    <svg class=\"timer__svg\" width=\"160\" height=\"160\" xmlns=\"http://www.w3.org/2000/svg\">\r\n      <circle id=\"circle\" class=\"circle_animation\" r=\"69.85699\" cy=\"81\" cx=\"81\" stroke-width=\"2\" stroke=\"rgb(40, 195, 138)\" fill=\"none\"/>\r\n    </svg>\r\n    `;\r\n        container.append(timer);\r\n    }\r\n    startTimer(className, time, cb) {\r\n        let i = 0;\r\n        const finalOffset = 440;\r\n        const step = finalOffset / time;\r\n        const timer = document.querySelector(`.${className}`);\r\n        const timeCaption = timer.querySelector('.timer__time');\r\n        const circle = document.querySelector('.circle_animation');\r\n        const circleStyle = circle.style;\r\n        circleStyle.strokeDashoffset = String(0);\r\n        timeCaption.innerText = String(time);\r\n        this.timerSound = this.createFinishSound();\r\n        this.timerInterval = setInterval(() => {\r\n            timeCaption.innerText = String(time - i);\r\n            if (time - i <= 10) {\r\n                this.timerSound?.play();\r\n            }\r\n            if (i === time) {\r\n                clearInterval(this.timerInterval);\r\n                this.timerSound?.pause();\r\n                cb();\r\n            }\r\n            else {\r\n                i += 1;\r\n                circleStyle.strokeDashoffset = String(step * i);\r\n            }\r\n        }, 1000);\r\n    }\r\n    renderGameContol(firstWordEn, firstWordRu) {\r\n        const sprint = document.querySelector('.sprint');\r\n        const ready = document.querySelector('.sprint__ready');\r\n        ready.remove();\r\n        this.renderTimer(sprint, 'timer--control');\r\n        this.startTimer('timer--control', 10, this.renderResult.bind(this));\r\n        const sprintControl = (0, functions_1.createHTMLElement)('div', ['sprint__control']);\r\n        const score = (0, functions_1.createHTMLElement)('h2', ['control__score'], undefined, '0');\r\n        const sound = (0, functions_1.createHTMLElement)('div', ['control__sound']);\r\n        sound.addEventListener('click', (e) => this.toggleMute(e));\r\n        const controlContainer = (0, functions_1.createHTMLElement)('div', ['control__container']);\r\n        const voice = (0, functions_1.createHTMLElement)('div', ['control__voice']);\r\n        voice.addEventListener('click', this.voiceWord.bind(this));\r\n        const controlSeriesList = (0, functions_1.createHTMLElement)('div', ['control__series-list']);\r\n        for (let i = 1; i <= 3; i += 1) {\r\n            const controlSeries = (0, functions_1.createHTMLElement)('div', ['control__series'], [['data-series', `${i}`]]);\r\n            controlSeriesList.append(controlSeries);\r\n        }\r\n        const multiply = (0, functions_1.createHTMLElement)('span', ['control__multiply'], undefined, '+10 очков за слово');\r\n        const parrots = (0, functions_1.createHTMLElement)('div', ['control__parrots']);\r\n        const blueParrot = (0, functions_1.createHTMLElement)('img', ['control__parrot'], [['src', './assets/sprint/bird-blue.svg'], ['alt', 'blue parrot']]);\r\n        const wordEn = (0, functions_1.createHTMLElement)('span', ['control__word-en'], undefined, firstWordEn);\r\n        const wordRu = (0, functions_1.createHTMLElement)('span', ['control__word-ru'], undefined, firstWordRu);\r\n        const buttons = (0, functions_1.createHTMLElement)('div', ['control__buttons']);\r\n        const buttonFalse = (0, functions_1.createHTMLElement)('button', ['control__button', 'control__button--false'], [['data-answer', 'false']], 'Неверно');\r\n        const buttonTrue = (0, functions_1.createHTMLElement)('button', ['control__button', 'control__button--true'], [['data-answer', 'true']], 'Верно');\r\n        buttons.append(buttonFalse, buttonTrue);\r\n        parrots.append(blueParrot);\r\n        controlContainer.append(controlSeriesList, multiply, voice, parrots, wordEn, wordRu, buttons);\r\n        sprintControl.append(score, sound, controlContainer);\r\n        sprint.append(sprintControl);\r\n        buttonFalse.addEventListener('click', (e) => this.selectAnswer(e));\r\n        buttonTrue.addEventListener('click', (e) => this.selectAnswer(e));\r\n        this.addKeyboardControl();\r\n    }\r\n    async getWordsInLevel(level) {\r\n        this.wordsInGame.length = 0;\r\n        const pages = [];\r\n        for (let i = 0; i <= 29; i += 1) {\r\n            const wordsOnPage = api_1.api.getWords({ group: level, page: String(i) });\r\n            pages.push(wordsOnPage);\r\n        }\r\n        await Promise.all(pages)\r\n            .then((data) => data.forEach(((page) => this.wordsInGame.push(...page))));\r\n    }\r\n    async getFilteredWords(level, page) {\r\n        const userData = this.storage.getUserIdData();\r\n        const userWordsAggr = await this.api.getAggregatedUserWords(userData, { group: level, page, wordsPerPage: '20' });\r\n        const userFilteredWords = userWordsAggr.filter((word) => !word?.userWord?.optional?.learned);\r\n        const userWords = userFilteredWords.map((word) => (0, convertAggregatedWordToWord_1.convertAggregatedWordToWord)(word));\r\n        return userWords;\r\n    }\r\n    async getWordsOnPage(level, page) {\r\n        const wordsOnPage = await api_1.api.getWords({ group: level, page });\r\n        if (!this.wordController.isAuthorized) {\r\n            this.wordsInGame = wordsOnPage;\r\n        }\r\n        else {\r\n            this.wordsInGame = await this.getFilteredWords(level, page);\r\n        }\r\n    }\r\n    getRandomWord() {\r\n        const maxIndex = this.wordsInGame.length - 1;\r\n        const randomWordIndex = (0, functions_1.getRandomIntInclusive)(0, maxIndex);\r\n        const randomWord = this.wordsInGame[randomWordIndex];\r\n        return randomWord;\r\n    }\r\n    getRandomPair() {\r\n        this.currentWord = this.getRandomWord();\r\n        const currentId = this.wordsInGame.indexOf(this.currentWord);\r\n        this.wordsInGame.splice(currentId, 1);\r\n        const randomPair = { word: this.currentWord.word, wordTranslate: '' };\r\n        const isTrue = Math.random() < 0.5;\r\n        if (this.wordsInGame.length > 0) {\r\n            if (isTrue) {\r\n                this.isPairTrue = true;\r\n                randomPair.wordTranslate = this.currentWord.wordTranslate;\r\n            }\r\n            else {\r\n                this.isPairTrue = false;\r\n                randomPair.wordTranslate = this.getRandomWord().wordTranslate;\r\n            }\r\n        }\r\n        else if (this.wordsInGame.length === 0) {\r\n            this.isPairTrue = true;\r\n            randomPair.wordTranslate = this.currentWord.wordTranslate;\r\n        }\r\n        return randomPair;\r\n    }\r\n    async addWordsInGame() {\r\n        const prevWords = [];\r\n        if (!this.wordController.isAuthorized) {\r\n            for (let i = this.bookPage; i > 0; i -= 1) {\r\n                prevWords.push(this.api.getWords({ group: String(this.bookLevel), page: String(i - 1) }));\r\n            }\r\n            await Promise.all(prevWords)\r\n                .then((data) => data.forEach(((words) => { this.wordsInGame.push(...words); })));\r\n            if (this.wordsInGame.length === 0) {\r\n                this.finishGame();\r\n            }\r\n        }\r\n        else if (this.wordController.isAuthorized) {\r\n            for (let i = this.bookPage; i > 0; i -= 1) {\r\n                prevWords.push(this.getFilteredWords(String(this.bookLevel), String(i - 1)));\r\n            }\r\n            await Promise.all(prevWords)\r\n                .then((data) => data.forEach(((words) => { this.wordsInGame.push(...words); })));\r\n            if (this.wordsInGame.length === 0) {\r\n                this.finishGame();\r\n            }\r\n        }\r\n        this.bookPage = 0;\r\n    }\r\n    async selectAnswer(e) {\r\n        const button = e.target;\r\n        const { answer } = button.dataset;\r\n        let isTrue;\r\n        if (answer === 'true') {\r\n            isTrue = true;\r\n        }\r\n        else {\r\n            isTrue = false;\r\n        }\r\n        if (isTrue === this.isPairTrue) {\r\n            this.completeTrueAnswer();\r\n        }\r\n        else {\r\n            this.completeFalseAnswer();\r\n        }\r\n        if (this.wordsInGame.length === 0 && this.mode === 'book' && this.bookLevel < 6) {\r\n            await this.addWordsInGame();\r\n        }\r\n        if (this.wordsInGame.length === 0 && this.mode === 'book' && this.bookLevel === 6) {\r\n            this.finishGame();\r\n        }\r\n        this.updateWord();\r\n    }\r\n    completeTrueAnswer() {\r\n        this.trueWords.push(this.currentWord);\r\n        this.updateScore();\r\n        this.trueAnswerSound.load();\r\n        this.trueAnswerSound.play();\r\n        this.seriesOfCorrect += 1;\r\n        this.checkSeriesOfCorrect();\r\n        this.changeStyleSeries(this.seriesOfCorrect);\r\n        this.wordController.sendWordOnServer(this.currentWord?.id, true, enums_1.GAME.SPRINT);\r\n    }\r\n    completeFalseAnswer() {\r\n        this.falseWords.push(this.currentWord);\r\n        this.falseAnswerSound.load();\r\n        this.falseAnswerSound.play();\r\n        this.seriesOfCorrect = 0;\r\n        this.multiplier = 1;\r\n        this.changeMultiplyDescr(1);\r\n        this.clearStyleSeries();\r\n        this.clearParrots();\r\n        this.wordController.sendWordOnServer(this.currentWord?.id, false, enums_1.GAME.SPRINT);\r\n    }\r\n    updateWord() {\r\n        const word = document.querySelector('.control__word-en');\r\n        const translate = document.querySelector('.control__word-ru');\r\n        if (this.wordsInGame.length !== 0) {\r\n            const randomPair = this.getRandomPair();\r\n            word.innerHTML = randomPair.word;\r\n            translate.innerHTML = randomPair.wordTranslate;\r\n        }\r\n    }\r\n    updateScore() {\r\n        const score = document.querySelector('.control__score');\r\n        this.score += this.POINTS_FOR_WORD * this.multiplier;\r\n        score.innerHTML = String(this.score);\r\n    }\r\n    checkSeriesOfCorrect() {\r\n        if (this.seriesOfCorrect === 4) {\r\n            this.changeMultiplyDescr(2);\r\n            this.clearStyleSeries();\r\n            this.addParrot();\r\n        }\r\n        else if (this.seriesOfCorrect === 5) {\r\n            this.multiplier *= 2;\r\n            this.seriesOfCorrect = 1;\r\n        }\r\n    }\r\n    changeMultiplyDescr(multiply) {\r\n        const multiplyDescr = document.querySelector('.control__multiply');\r\n        multiplyDescr.innerHTML = `+${this.POINTS_FOR_WORD * this.multiplier * multiply} очков за слово`;\r\n    }\r\n    changeStyleSeries(item) {\r\n        if (item > 0 && item < 4) {\r\n            const series = document.querySelector(`[data-series=\"${item}\"]`);\r\n            series.classList.add('control__series--active');\r\n        }\r\n    }\r\n    clearStyleSeries() {\r\n        const seriesAll = document.querySelectorAll('.control__series');\r\n        seriesAll.forEach((series) => series.classList.remove('control__series--active'));\r\n    }\r\n    addParrot() {\r\n        const parrotsContainer = document.querySelector('.control__parrots');\r\n        if (this.multiplier === 1) {\r\n            const redParrot = (0, functions_1.createHTMLElement)('img', ['control__parrot'], [['src', './assets/sprint/bird-red.svg'], ['alt', 'red parrot']]);\r\n            parrotsContainer.append(redParrot);\r\n        }\r\n        else if (this.multiplier === 2) {\r\n            const purpleParrot = (0, functions_1.createHTMLElement)('img', ['control__parrot'], [['src', './assets/sprint/bird-purple.svg'], ['alt', 'purple parrot']]);\r\n            parrotsContainer.append(purpleParrot);\r\n        }\r\n        else if (this.multiplier === 4) {\r\n            const yellowParrot = (0, functions_1.createHTMLElement)('img', ['control__parrot'], [['src', './assets/sprint/bird-yellow.svg'], ['alt', 'yellow parrot']]);\r\n            parrotsContainer.append(yellowParrot);\r\n        }\r\n    }\r\n    clearParrots() {\r\n        const parrots = document.querySelectorAll('.control__parrot');\r\n        const count = parrots.length;\r\n        for (let i = 1; i < count; i += 1) {\r\n            parrots[i].remove();\r\n        }\r\n    }\r\n    voiceWord() {\r\n        const url = `${constants_1.BASE_LINK}/${this.currentWord?.audio}`;\r\n        const audio = new Audio(url);\r\n        audio.play();\r\n    }\r\n    createAnswerSoud(value) {\r\n        const url = `./assets/sprint/sounds/${String(value)}.mp3`;\r\n        return new Audio(url);\r\n    }\r\n    createFinishSound() {\r\n        const url = './assets/sprint/sounds/finish_tick.mp3';\r\n        const audio = new Audio(url);\r\n        return audio;\r\n    }\r\n    renderResult() {\r\n        const sprint = document.querySelector('.sprint');\r\n        const control = document.querySelector('.sprint__control');\r\n        const timer = document.querySelector('.timer--control');\r\n        control.style.display = 'none';\r\n        timer.remove();\r\n        const resultContainer = (0, functions_1.createHTMLElement)('div', ['sprint__result']);\r\n        const score = (0, functions_1.createHTMLElement)('h2', ['result__score'], undefined, `Твой результат: ${this.score} очков`);\r\n        const listsContainer = (0, functions_1.createHTMLElement)('div', ['sprint__lists']);\r\n        const trueList = (0, functions_1.createHTMLElement)('ul', ['result__true'], undefined, `Знаю: ${this.trueWords.length}`);\r\n        const falseList = (0, functions_1.createHTMLElement)('ul', ['result__false'], undefined, `Ошибок: ${this.falseWords.length}`);\r\n        const btnRestart = (0, functions_1.createHTMLElement)('button', ['result__restart-btn'], undefined, 'Играть еще раз');\r\n        btnRestart.addEventListener('click', (e) => {\r\n            const btn = e.target;\r\n            if (!btn.disabled) {\r\n                this.restartGame();\r\n                btn.disabled = true;\r\n            }\r\n        });\r\n        this.trueWords.forEach((word) => this.addWordInResult(trueList, word));\r\n        this.falseWords.forEach((word) => this.addWordInResult(falseList, word));\r\n        listsContainer.append(falseList, trueList);\r\n        resultContainer.append(score, listsContainer, btnRestart);\r\n        sprint.append(resultContainer);\r\n    }\r\n    addWordInResult(list, word) {\r\n        const wordEn = (0, functions_1.createHTMLElement)('span', ['result__word-en'], undefined, `${word.word}: `);\r\n        const wordRu = (0, functions_1.createHTMLElement)('span', ['result__word-ru'], undefined, `${word.wordTranslate}`);\r\n        const wordEnRu = (0, functions_1.createHTMLElement)('li', ['result__word']);\r\n        const voice = (0, functions_1.createHTMLElement)('div', ['result__voice']);\r\n        voice.addEventListener('click', () => this.voiceWordInResult(word.audio));\r\n        wordEnRu.append(voice, wordEn, wordRu);\r\n        list.append(wordEnRu);\r\n    }\r\n    voiceWordInResult(url) {\r\n        const audio = new Audio(`${constants_1.BASE_LINK}/${url}`);\r\n        audio.play();\r\n    }\r\n    toggleMute(e) {\r\n        const btn = e.target;\r\n        btn.classList.toggle('control__sound--off');\r\n        if (this.mute === false) {\r\n            this.mute = true;\r\n            this.trueAnswerSound.volume = 0;\r\n            this.falseAnswerSound.volume = 0;\r\n        }\r\n        else if (this.mute === true) {\r\n            this.mute = false;\r\n            this.trueAnswerSound.volume = 1;\r\n            this.falseAnswerSound.volume = 1;\r\n        }\r\n    }\r\n    finishGame() {\r\n        clearInterval(this.timerInterval);\r\n        this.timerSound?.pause();\r\n        this.renderResult();\r\n        this.removeKeyboardControl();\r\n    }\r\n    setBookPageAndLevel(level, page) {\r\n        this.bookPage = page;\r\n        this.bookLevel = level;\r\n    }\r\n    async selectAnswerByCorrect(correct) {\r\n        if (correct === this.isPairTrue) {\r\n            this.completeTrueAnswer();\r\n        }\r\n        else {\r\n            this.completeFalseAnswer();\r\n        }\r\n        if (this.wordsInGame.length === 0 && this.mode === 'book' && this.bookLevel < 6) {\r\n            await this.addWordsInGame();\r\n        }\r\n        this.updateWord();\r\n    }\r\n    selectAnswerByKey(e) {\r\n        let isTrue = false;\r\n        if (e.key === 'ArrowRight') {\r\n            isTrue = true;\r\n            this.selectAnswerByCorrect(isTrue);\r\n        }\r\n        else if (e.key === 'ArrowLeft') {\r\n            isTrue = false;\r\n            this.selectAnswerByCorrect(isTrue);\r\n        }\r\n    }\r\n    addKeyboardControl() {\r\n        document.addEventListener('keydown', this.keyListener);\r\n    }\r\n    removeKeyboardControl() {\r\n        document.removeEventListener('keydown', this.keyListener);\r\n    }\r\n    closeGame() {\r\n        const body = document.querySelector('.body');\r\n        body?.classList.remove('body--sprint');\r\n        clearInterval(this.timerInterval);\r\n        this.timerSound?.pause();\r\n        this.removeKeyboardControl();\r\n    }\r\n    async getHardWords() {\r\n        const userHardWords = await this.wordController.getUserBookWords();\r\n        if (Array.isArray(userHardWords)) {\r\n            return userHardWords.map((word) => (0, convertAggregatedWordToWord_1.convertAggregatedWordToWord)(word));\r\n        }\r\n        return [];\r\n    }\r\n    async checkWordsAvailability() {\r\n        let words;\r\n        if (this.bookLevel < 6) {\r\n            words = await api_1.api.getWords({ group: String(this.bookLevel), page: String(this.bookPage) });\r\n        }\r\n        else {\r\n            words = await this.getHardWords();\r\n        }\r\n        if (words.length === 0 || !Array.isArray(words)) {\r\n            const result = document.querySelector('.sprint__result');\r\n            const message = (0, functions_1.createHTMLElement)('span', ['sprint__restart-message'], undefined, 'Недостаточно слов для запуска новой игры. Выберите другой уровень или страницу');\r\n            result.append(message);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    async restartGame() {\r\n        const isAvailable = await this.checkWordsAvailability();\r\n        if (isAvailable) {\r\n            this.closeGame();\r\n            this.wordsInGame.length = 0;\r\n            this.score = 0;\r\n            this.multiplier = 1;\r\n            this.seriesOfCorrect = 0;\r\n            this.trueWords.length = 0;\r\n            this.falseWords.length = 0;\r\n            this.renderGame();\r\n        }\r\n    }\r\n    closeGameByLink(e) {\r\n        const target = e.target;\r\n        if (target.href !== `${constants_1.BASE_LINK}/sprint`) {\r\n            this.removeLinksListeners();\r\n            this.closeGame();\r\n        }\r\n    }\r\n    removeLinksListeners() {\r\n        const links = document.querySelectorAll('a');\r\n        links.forEach((link) => link.removeEventListener('click', this.linksHandler));\r\n    }\r\n    addLinksHandler() {\r\n        const href = `${document.location.protocol}//${document.location.host}`;\r\n        const links = document.querySelectorAll('a');\r\n        links.forEach((link) => {\r\n            if (link.href !== `${href}/sprint`) {\r\n                link.addEventListener('click', this.linksHandler);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.Sprint = Sprint;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxFQUFFLEVBQUU7WUFDckIsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLEdBQUcsSUFBSSxTQUFTLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ25EO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUE3a0JELHdCQTZrQkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvc3ByaW50L1NwcmludC50cz9iNWY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwaSB9IGZyb20gJy4uL01vZGVsL2FwaSc7XHJcbmltcG9ydCB7IGNyZWF0ZUhUTUxFbGVtZW50LCBnZXRSYW5kb21JbnRJbmNsdXNpdmUgfSBmcm9tICcuLi91dGlscy9mdW5jdGlvbnMnO1xyXG5pbXBvcnQgeyBXb3JkLCBSYW5kb21QYWlySW5TcHJpbnQsIFVzZXJBZ2dyZWdhdGVkV29yZCB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBCQVNFX0xJTksgfSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBXb3JkQ29udHJvbGxlciB9IGZyb20gJy4uL1dvcmRDb250cm9sbGVyL1dvcmRDb250cm9sbGVyJztcclxuaW1wb3J0IHsgU3RvcmFnZSB9IGZyb20gJy4uL1N0b3JhZ2UvU3RvcmFnZSc7XHJcbmltcG9ydCB7IGNvbnZlcnRBZ2dyZWdhdGVkV29yZFRvV29yZCB9IGZyb20gJy4uL3V0aWxzL2NvbnZlcnRBZ2dyZWdhdGVkV29yZFRvV29yZCc7XHJcbmltcG9ydCB7IEdBTUUgfSBmcm9tICcuLi90eXBlcy9lbnVtcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgU3ByaW50IHtcclxuICBtb2RlOiAnbWVudScgfCAnYm9vayc7XHJcblxyXG4gIGFwaTogdHlwZW9mIGFwaTtcclxuXHJcbiAgd29yZENvbnRyb2xsZXI6IFdvcmRDb250cm9sbGVyO1xyXG5cclxuICBzdG9yYWdlOiBTdG9yYWdlO1xyXG5cclxuICBjdXJyZW50TGV2ZWw6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcbiAgd29yZHNJbkdhbWU6IFdvcmRbXTtcclxuXHJcbiAgY3VycmVudFdvcmQ6IFdvcmQgfCB1bmRlZmluZWQ7XHJcblxyXG4gIHRydWVXb3JkczogV29yZFtdO1xyXG5cclxuICBmYWxzZVdvcmRzOiBXb3JkW107XHJcblxyXG4gIGlzUGFpclRydWU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcblxyXG4gIHNjb3JlOiBudW1iZXI7XHJcblxyXG4gIFBPSU5UU19GT1JfV09SRDogbnVtYmVyO1xyXG5cclxuICBtdWx0aXBsaWVyOiBudW1iZXI7XHJcblxyXG4gIHNlcmllc09mQ29ycmVjdDogbnVtYmVyO1xyXG5cclxuICBib29rUGFnZTogbnVtYmVyO1xyXG5cclxuICBib29rTGV2ZWw6IG51bWJlcjtcclxuXHJcbiAgdGltZXJTb3VuZDogSFRNTEF1ZGlvRWxlbWVudCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgdHJ1ZUFuc3dlclNvdW5kOiBIVE1MQXVkaW9FbGVtZW50O1xyXG5cclxuICBmYWxzZUFuc3dlclNvdW5kOiBIVE1MQXVkaW9FbGVtZW50O1xyXG5cclxuICBtdXRlOiBib29sZWFuO1xyXG5cclxuICB0aW1lckludGVydmFsOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD4gfCB1bmRlZmluZWQ7XHJcblxyXG4gIGtleUxpc3RlbmVyOiAoZTogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcclxuXHJcbiAgbGlua3NIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG1vZGU6ICdtZW51JyB8ICdib29rJykge1xyXG4gICAgdGhpcy5tb2RlID0gbW9kZTtcclxuICAgIHRoaXMuYXBpID0gYXBpO1xyXG4gICAgdGhpcy53b3JkQ29udHJvbGxlciA9IG5ldyBXb3JkQ29udHJvbGxlcigpO1xyXG4gICAgdGhpcy5zdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcclxuICAgIHRoaXMud29yZHNJbkdhbWUgPSBbXTtcclxuICAgIHRoaXMuc2NvcmUgPSAwO1xyXG4gICAgdGhpcy5QT0lOVFNfRk9SX1dPUkQgPSAxMDtcclxuICAgIHRoaXMubXVsdGlwbGllciA9IDE7XHJcbiAgICB0aGlzLnNlcmllc09mQ29ycmVjdCA9IDA7XHJcbiAgICB0aGlzLnRydWVXb3JkcyA9IFtdO1xyXG4gICAgdGhpcy5mYWxzZVdvcmRzID0gW107XHJcbiAgICB0aGlzLmJvb2tQYWdlID0gMDtcclxuICAgIHRoaXMuYm9va0xldmVsID0gMDtcclxuICAgIHRoaXMudHJ1ZUFuc3dlclNvdW5kID0gdGhpcy5jcmVhdGVBbnN3ZXJTb3VkKHRydWUpO1xyXG4gICAgdGhpcy5mYWxzZUFuc3dlclNvdW5kID0gdGhpcy5jcmVhdGVBbnN3ZXJTb3VkKGZhbHNlKTtcclxuICAgIHRoaXMubXV0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5rZXlMaXN0ZW5lciA9IHRoaXMuc2VsZWN0QW5zd2VyQnlLZXkuYmluZCh0aGlzKTtcclxuICAgIHRoaXMubGlua3NIYW5kbGVyID0gdGhpcy5jbG9zZUdhbWVCeUxpbmsuYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZW5kZXJHYW1lKCk6IHZvaWQge1xyXG4gICAgY29uc3QgYm9keSA9IDxIVE1MRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYm9keScpO1xyXG4gICAgY29uc3QgbWFpbiA9IDxIVE1MRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbicpO1xyXG4gICAgY29uc3Qgc3ByaW50ID0gY3JlYXRlSFRNTEVsZW1lbnQoJ3NlY3Rpb24nLCBbJ3NwcmludCddKTtcclxuICAgIGJvZHkuY2xhc3NMaXN0LmFkZCgnYm9keS0tc3ByaW50Jyk7XHJcbiAgICBtYWluLmlubmVySFRNTCA9ICcnO1xyXG4gICAgY29uc3QgYnRuQ2xvc2UgPSBjcmVhdGVIVE1MRWxlbWVudCgnYScsIFsnc3ByaW50X19jbG9zZSddLCBbWydocmVmJywgJy8nXSwgWydkYXRhLW5hdmlnbycsICd0cnVlJ11dKSBhcyBIVE1MQW5jaG9yRWxlbWVudDtcclxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdib29rJykge1xyXG4gICAgICBidG5DbG9zZS5ocmVmID0gJy9ib29rJztcclxuICAgICAgc3ByaW50LmFwcGVuZChidG5DbG9zZSk7XHJcbiAgICAgIHRoaXMuc3RhcnRHYW1lKCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ21lbnUnKSB7XHJcbiAgICAgIGNvbnN0IHNlbGVjdCA9IHRoaXMucmVuZGVyU2VsZWN0TGV2ZWwoKTtcclxuICAgICAgc3ByaW50LmFwcGVuZChzZWxlY3QsIGJ0bkNsb3NlKTtcclxuICAgIH1cclxuICAgIG1haW4uYXBwZW5kKHNwcmludCk7XHJcbiAgICB0aGlzLmFkZExpbmtzSGFuZGxlcigpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZXJTZWxlY3RMZXZlbCgpOiBIVE1MRWxlbWVudCB7XHJcbiAgICBjb25zdCBzZWxlY3QgPSBjcmVhdGVIVE1MRWxlbWVudCgnZGl2JywgWydzcHJpbnRfX3NlbGVjdCddKTtcclxuICAgIGNvbnN0IHNlbGVjdFRpdGxlID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2gyJywgWydzcHJpbnRfX3NlbGVjdC10aXRsZSddLCB1bmRlZmluZWQsICfQodC/0YDQuNC90YInKTtcclxuICAgIGNvbnN0IHNlbGVjdERlc2NyaXB0aW9uID0gY3JlYXRlSFRNTEVsZW1lbnQoJ3AnLCBbJ3NwcmludF9fc2VsZWN0LWRlc2NyJ10sIHVuZGVmaW5lZCwgJ9Cj0YfQuNGCINCx0YvRgdGC0YDQviDQv9C10YDQtdCy0L7QtNC40YLRjCDQvdCwINCy0LDRiCDRgNC+0LTQvdC+0Lkg0Y/Qt9GL0LonKTtcclxuICAgIGNvbnN0IHNlbGVjdFRleHQgPSBjcmVhdGVIVE1MRWxlbWVudCgncCcsIFsnc3ByaW50X19zZWxlY3QtdGV4dCddLCB1bmRlZmluZWQsICfQktGL0LHQtdGA0LjRgtC1INGD0YDQvtCy0LXQvdGMOicpO1xyXG4gICAgY29uc3QgbGV2ZWxzID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsnc3ByaW50X19sZXZlbHMnXSk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA2OyBpICs9IDEpIHtcclxuICAgICAgY29uc3QgbGV2ZWwgPSBjcmVhdGVIVE1MRWxlbWVudCgnZGl2JywgWydzcHJpbnRfX2xldmVsJ10sIFtbJ2RhdGEtbGV2ZWwnLCBgJHtpIC0gMX1gXV0sIGAke2l9YCk7XHJcbiAgICAgIGxldmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGU6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gPEhUTUxFbGVtZW50PmUudGFyZ2V0O1xyXG4gICAgICAgIGNvbnN0IGxldmVsTnVtYmVyID0gdGFyZ2V0LmRhdGFzZXQubGV2ZWw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBsZXZlbE51bWJlcjtcclxuICAgICAgICB0aGlzLnN0YXJ0R2FtZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgbGV2ZWxzLmFwcGVuZChsZXZlbCk7XHJcbiAgICB9XHJcbiAgICBzZWxlY3QuYXBwZW5kKHNlbGVjdFRpdGxlLCBzZWxlY3REZXNjcmlwdGlvbiwgc2VsZWN0VGV4dCwgbGV2ZWxzKTtcclxuICAgIHJldHVybiBzZWxlY3Q7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHN0YXJ0R2FtZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdtZW51Jykge1xyXG4gICAgICBjb25zdCBzZWxlY3QgPSA8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNwcmludF9fc2VsZWN0Jyk7XHJcbiAgICAgIHNlbGVjdC5yZW1vdmUoKTtcclxuICAgICAgYXdhaXQgdGhpcy5nZXRXb3Jkc0luTGV2ZWwodGhpcy5jdXJyZW50TGV2ZWwhKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAnYm9vaycpIHtcclxuICAgICAgaWYgKHRoaXMuYm9va0xldmVsIDwgNikge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0V29yZHNPblBhZ2UoU3RyaW5nKHRoaXMuYm9va0xldmVsKSwgU3RyaW5nKHRoaXMuYm9va1BhZ2UpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLndvcmRzSW5HYW1lID0gYXdhaXQgdGhpcy5nZXRIYXJkV29yZHMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc3ByaW50ID0gPEhUTUxFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcHJpbnQnKTtcclxuICAgIGNvbnN0IHJlYWR5ID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsnc3ByaW50X19yZWFkeSddKTtcclxuICAgIGNvbnN0IHRpbWVyVGl0bGUgPSBjcmVhdGVIVE1MRWxlbWVudCgnaDInLCBbJ3RpbWVyX190aXRsZSddLCB1bmRlZmluZWQsICfQn9GA0LjQs9C+0YLQvtCy0YzRgtC10YHRjCcpO1xyXG4gICAgc3ByaW50LmFwcGVuZChyZWFkeSk7XHJcbiAgICB0aGlzLnJlbmRlclRpbWVyKHJlYWR5LCAndGltZXItLXJlYWR5Jyk7XHJcbiAgICByZWFkeS5hcHBlbmQodGltZXJUaXRsZSk7XHJcbiAgICBjb25zdCByYW5kb21QYWlyID0gdGhpcy5nZXRSYW5kb21QYWlyKCk7XHJcbiAgICB0aGlzLnN0YXJ0VGltZXIoJ3RpbWVyLS1yZWFkeScsIDMsIHRoaXMucmVuZGVyR2FtZUNvbnRvbC5iaW5kKHRoaXMsIHJhbmRvbVBhaXIud29yZCwgcmFuZG9tUGFpci53b3JkVHJhbnNsYXRlKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbmRlclRpbWVyKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGNsYXNzTmFtZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCB0aW1lciA9IGNyZWF0ZUhUTUxFbGVtZW50KCdkaXYnLCBbJ3RpbWVyJywgY2xhc3NOYW1lXSk7XHJcbiAgICB0aW1lci5pbm5lckhUTUwgPSBgXHJcbiAgICA8c3BhbiBjbGFzcz1cInRpbWVyX190aW1lXCI+PC9zcGFuPlxyXG4gICAgPHN2ZyBjbGFzcz1cInRpbWVyX19zdmdcIiB3aWR0aD1cIjE2MFwiIGhlaWdodD1cIjE2MFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cclxuICAgICAgPGNpcmNsZSBpZD1cImNpcmNsZVwiIGNsYXNzPVwiY2lyY2xlX2FuaW1hdGlvblwiIHI9XCI2OS44NTY5OVwiIGN5PVwiODFcIiBjeD1cIjgxXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZT1cInJnYig0MCwgMTk1LCAxMzgpXCIgZmlsbD1cIm5vbmVcIi8+XHJcbiAgICA8L3N2Zz5cclxuICAgIGA7XHJcbiAgICBjb250YWluZXIuYXBwZW5kKHRpbWVyKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdGFydFRpbWVyKGNsYXNzTmFtZTogc3RyaW5nLCB0aW1lOiBudW1iZXIsIGNiOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgY29uc3QgZmluYWxPZmZzZXQgPSA0NDA7XHJcbiAgICBjb25zdCBzdGVwID0gZmluYWxPZmZzZXQgLyB0aW1lO1xyXG4gICAgY29uc3QgdGltZXIgPSA8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLiR7Y2xhc3NOYW1lfWApO1xyXG4gICAgY29uc3QgdGltZUNhcHRpb24gPSA8SFRNTEVsZW1lbnQ+dGltZXIucXVlcnlTZWxlY3RvcignLnRpbWVyX190aW1lJyk7XHJcbiAgICBjb25zdCBjaXJjbGUgPSA8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNpcmNsZV9hbmltYXRpb24nKTtcclxuICAgIGNvbnN0IGNpcmNsZVN0eWxlID0gY2lyY2xlLnN0eWxlO1xyXG5cclxuICAgIGNpcmNsZVN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBTdHJpbmcoMCk7XHJcbiAgICB0aW1lQ2FwdGlvbi5pbm5lclRleHQgPSBTdHJpbmcodGltZSk7XHJcbiAgICB0aGlzLnRpbWVyU291bmQgPSB0aGlzLmNyZWF0ZUZpbmlzaFNvdW5kKCk7XHJcblxyXG4gICAgdGhpcy50aW1lckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICB0aW1lQ2FwdGlvbi5pbm5lclRleHQgPSBTdHJpbmcodGltZSAtIGkpO1xyXG4gICAgICBpZiAodGltZSAtIGkgPD0gMTApIHtcclxuICAgICAgICB0aGlzLnRpbWVyU291bmQ/LnBsYXkoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaSA9PT0gdGltZSkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lckludGVydmFsKTtcclxuICAgICAgICB0aGlzLnRpbWVyU291bmQ/LnBhdXNlKCk7XHJcbiAgICAgICAgY2IoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgY2lyY2xlU3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IFN0cmluZyhzdGVwICogaSk7XHJcbiAgICAgIH1cclxuICAgIH0sIDEwMDApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbmRlckdhbWVDb250b2woZmlyc3RXb3JkRW46IHN0cmluZywgZmlyc3RXb3JkUnU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgY29uc3Qgc3ByaW50ID0gPEhUTUxFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcHJpbnQnKTtcclxuICAgIGNvbnN0IHJlYWR5ID0gPEhUTUxFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcHJpbnRfX3JlYWR5Jyk7XHJcbiAgICByZWFkeS5yZW1vdmUoKTtcclxuICAgIHRoaXMucmVuZGVyVGltZXIoc3ByaW50LCAndGltZXItLWNvbnRyb2wnKTtcclxuICAgIHRoaXMuc3RhcnRUaW1lcigndGltZXItLWNvbnRyb2wnLCAxMCwgdGhpcy5yZW5kZXJSZXN1bHQuYmluZCh0aGlzKSk7XHJcbiAgICBjb25zdCBzcHJpbnRDb250cm9sID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsnc3ByaW50X19jb250cm9sJ10pO1xyXG4gICAgY29uc3Qgc2NvcmUgPSBjcmVhdGVIVE1MRWxlbWVudCgnaDInLCBbJ2NvbnRyb2xfX3Njb3JlJ10sIHVuZGVmaW5lZCwgJzAnKTtcclxuICAgIGNvbnN0IHNvdW5kID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsnY29udHJvbF9fc291bmQnXSk7XHJcbiAgICBzb3VuZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB0aGlzLnRvZ2dsZU11dGUoZSkpO1xyXG4gICAgY29uc3QgY29udHJvbENvbnRhaW5lciA9IGNyZWF0ZUhUTUxFbGVtZW50KCdkaXYnLCBbJ2NvbnRyb2xfX2NvbnRhaW5lciddKTtcclxuICAgIGNvbnN0IHZvaWNlID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsnY29udHJvbF9fdm9pY2UnXSk7XHJcbiAgICB2b2ljZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudm9pY2VXb3JkLmJpbmQodGhpcykpO1xyXG4gICAgY29uc3QgY29udHJvbFNlcmllc0xpc3QgPSBjcmVhdGVIVE1MRWxlbWVudCgnZGl2JywgWydjb250cm9sX19zZXJpZXMtbGlzdCddKTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDM7IGkgKz0gMSkge1xyXG4gICAgICBjb25zdCBjb250cm9sU2VyaWVzID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsnY29udHJvbF9fc2VyaWVzJ10sIFtbJ2RhdGEtc2VyaWVzJywgYCR7aX1gXV0pO1xyXG4gICAgICBjb250cm9sU2VyaWVzTGlzdC5hcHBlbmQoY29udHJvbFNlcmllcyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtdWx0aXBseSA9IGNyZWF0ZUhUTUxFbGVtZW50KCdzcGFuJywgWydjb250cm9sX19tdWx0aXBseSddLCB1bmRlZmluZWQsICcrMTAg0L7Rh9C60L7QsiDQt9CwINGB0LvQvtCy0L4nKTtcclxuICAgIGNvbnN0IHBhcnJvdHMgPSBjcmVhdGVIVE1MRWxlbWVudCgnZGl2JywgWydjb250cm9sX19wYXJyb3RzJ10pO1xyXG4gICAgY29uc3QgYmx1ZVBhcnJvdCA9IGNyZWF0ZUhUTUxFbGVtZW50KCdpbWcnLCBbJ2NvbnRyb2xfX3BhcnJvdCddLCBbWydzcmMnLCAnLi9hc3NldHMvc3ByaW50L2JpcmQtYmx1ZS5zdmcnXSwgWydhbHQnLCAnYmx1ZSBwYXJyb3QnXV0pO1xyXG4gICAgY29uc3Qgd29yZEVuID0gY3JlYXRlSFRNTEVsZW1lbnQoJ3NwYW4nLCBbJ2NvbnRyb2xfX3dvcmQtZW4nXSwgdW5kZWZpbmVkLCBmaXJzdFdvcmRFbik7XHJcbiAgICBjb25zdCB3b3JkUnUgPSBjcmVhdGVIVE1MRWxlbWVudCgnc3BhbicsIFsnY29udHJvbF9fd29yZC1ydSddLCB1bmRlZmluZWQsIGZpcnN0V29yZFJ1KTtcclxuICAgIGNvbnN0IGJ1dHRvbnMgPSBjcmVhdGVIVE1MRWxlbWVudCgnZGl2JywgWydjb250cm9sX19idXR0b25zJ10pO1xyXG4gICAgY29uc3QgYnV0dG9uRmFsc2UgPSBjcmVhdGVIVE1MRWxlbWVudCgnYnV0dG9uJywgWydjb250cm9sX19idXR0b24nLCAnY29udHJvbF9fYnV0dG9uLS1mYWxzZSddLCBbWydkYXRhLWFuc3dlcicsICdmYWxzZSddXSwgJ9Cd0LXQstC10YDQvdC+Jyk7XHJcbiAgICBjb25zdCBidXR0b25UcnVlID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2J1dHRvbicsIFsnY29udHJvbF9fYnV0dG9uJywgJ2NvbnRyb2xfX2J1dHRvbi0tdHJ1ZSddLCBbWydkYXRhLWFuc3dlcicsICd0cnVlJ11dLCAn0JLQtdGA0L3QvicpO1xyXG4gICAgYnV0dG9ucy5hcHBlbmQoYnV0dG9uRmFsc2UsIGJ1dHRvblRydWUpO1xyXG4gICAgcGFycm90cy5hcHBlbmQoYmx1ZVBhcnJvdCk7XHJcbiAgICBjb250cm9sQ29udGFpbmVyLmFwcGVuZChjb250cm9sU2VyaWVzTGlzdCwgbXVsdGlwbHksIHZvaWNlLCBwYXJyb3RzLCB3b3JkRW4sIHdvcmRSdSwgYnV0dG9ucyk7XHJcbiAgICBzcHJpbnRDb250cm9sLmFwcGVuZChzY29yZSwgc291bmQsIGNvbnRyb2xDb250YWluZXIpO1xyXG4gICAgc3ByaW50LmFwcGVuZChzcHJpbnRDb250cm9sKTtcclxuICAgIGJ1dHRvbkZhbHNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHRoaXMuc2VsZWN0QW5zd2VyKGUpKTtcclxuICAgIGJ1dHRvblRydWUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gdGhpcy5zZWxlY3RBbnN3ZXIoZSkpO1xyXG4gICAgdGhpcy5hZGRLZXlib2FyZENvbnRyb2woKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0V29yZHNJbkxldmVsKGxldmVsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRoaXMud29yZHNJbkdhbWUubGVuZ3RoID0gMDtcclxuICAgIGNvbnN0IHBhZ2VzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyOTsgaSArPSAxKSB7XHJcbiAgICAgIGNvbnN0IHdvcmRzT25QYWdlID0gYXBpLmdldFdvcmRzKHsgZ3JvdXA6IGxldmVsLCBwYWdlOiBTdHJpbmcoaSkgfSk7XHJcbiAgICAgIHBhZ2VzLnB1c2god29yZHNPblBhZ2UpO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocGFnZXMpXHJcbiAgICAgIC50aGVuKChkYXRhKSA9PiBkYXRhLmZvckVhY2goKChwYWdlKSA9PiB0aGlzLndvcmRzSW5HYW1lLnB1c2goLi4ucGFnZSkpKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldEZpbHRlcmVkV29yZHMobGV2ZWw6IHN0cmluZywgcGFnZTogc3RyaW5nKTogUHJvbWlzZTxXb3JkW10+IHtcclxuICAgIGNvbnN0IHVzZXJEYXRhID0gdGhpcy5zdG9yYWdlLmdldFVzZXJJZERhdGEoKTtcclxuICAgIGNvbnN0IHVzZXJXb3Jkc0FnZ3IgPSBhd2FpdCB0aGlzLmFwaS5nZXRBZ2dyZWdhdGVkVXNlcldvcmRzKFxyXG4gICAgICB1c2VyRGF0YSxcclxuICAgICAgeyBncm91cDogbGV2ZWwsIHBhZ2UsIHdvcmRzUGVyUGFnZTogJzIwJyB9LFxyXG4gICAgKSBhcyBVc2VyQWdncmVnYXRlZFdvcmRbXTtcclxuICAgIGNvbnN0IHVzZXJGaWx0ZXJlZFdvcmRzID0gdXNlcldvcmRzQWdnci5maWx0ZXIoKHdvcmQpID0+ICF3b3JkPy51c2VyV29yZD8ub3B0aW9uYWw/LmxlYXJuZWQpO1xyXG4gICAgY29uc3QgdXNlcldvcmRzID0gdXNlckZpbHRlcmVkV29yZHMubWFwKCh3b3JkKSA9PiBjb252ZXJ0QWdncmVnYXRlZFdvcmRUb1dvcmQod29yZCkpO1xyXG4gICAgcmV0dXJuIHVzZXJXb3JkcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0V29yZHNPblBhZ2UobGV2ZWw6IHN0cmluZywgcGFnZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB3b3Jkc09uUGFnZSA9IGF3YWl0IGFwaS5nZXRXb3Jkcyh7IGdyb3VwOiBsZXZlbCwgcGFnZSB9KTtcclxuICAgIGlmICghdGhpcy53b3JkQ29udHJvbGxlci5pc0F1dGhvcml6ZWQpIHtcclxuICAgICAgdGhpcy53b3Jkc0luR2FtZSA9IHdvcmRzT25QYWdlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy53b3Jkc0luR2FtZSA9IGF3YWl0IHRoaXMuZ2V0RmlsdGVyZWRXb3JkcyhsZXZlbCwgcGFnZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldFJhbmRvbVdvcmQoKTogV29yZCB7XHJcbiAgICBjb25zdCBtYXhJbmRleCA9IHRoaXMud29yZHNJbkdhbWUubGVuZ3RoIC0gMTtcclxuICAgIGNvbnN0IHJhbmRvbVdvcmRJbmRleCA9IGdldFJhbmRvbUludEluY2x1c2l2ZSgwLCBtYXhJbmRleCk7XHJcbiAgICBjb25zdCByYW5kb21Xb3JkID0gdGhpcy53b3Jkc0luR2FtZVtyYW5kb21Xb3JkSW5kZXhdO1xyXG4gICAgcmV0dXJuIHJhbmRvbVdvcmQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldFJhbmRvbVBhaXIoKTogUmFuZG9tUGFpckluU3ByaW50IHtcclxuICAgIHRoaXMuY3VycmVudFdvcmQgPSB0aGlzLmdldFJhbmRvbVdvcmQoKTtcclxuICAgIGNvbnN0IGN1cnJlbnRJZCA9IHRoaXMud29yZHNJbkdhbWUuaW5kZXhPZih0aGlzLmN1cnJlbnRXb3JkKTtcclxuICAgIHRoaXMud29yZHNJbkdhbWUuc3BsaWNlKGN1cnJlbnRJZCwgMSk7XHJcbiAgICBjb25zdCByYW5kb21QYWlyOiBSYW5kb21QYWlySW5TcHJpbnQgPSB7IHdvcmQ6IHRoaXMuY3VycmVudFdvcmQud29yZCwgd29yZFRyYW5zbGF0ZTogJycgfTtcclxuICAgIGNvbnN0IGlzVHJ1ZSA9IE1hdGgucmFuZG9tKCkgPCAwLjU7XHJcbiAgICBpZiAodGhpcy53b3Jkc0luR2FtZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGlmIChpc1RydWUpIHtcclxuICAgICAgICB0aGlzLmlzUGFpclRydWUgPSB0cnVlO1xyXG4gICAgICAgIHJhbmRvbVBhaXIud29yZFRyYW5zbGF0ZSA9IHRoaXMuY3VycmVudFdvcmQud29yZFRyYW5zbGF0ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmlzUGFpclRydWUgPSBmYWxzZTtcclxuICAgICAgICByYW5kb21QYWlyLndvcmRUcmFuc2xhdGUgPSB0aGlzLmdldFJhbmRvbVdvcmQoKS53b3JkVHJhbnNsYXRlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMud29yZHNJbkdhbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRoaXMuaXNQYWlyVHJ1ZSA9IHRydWU7XHJcbiAgICAgIHJhbmRvbVBhaXIud29yZFRyYW5zbGF0ZSA9IHRoaXMuY3VycmVudFdvcmQud29yZFRyYW5zbGF0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByYW5kb21QYWlyO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBhZGRXb3Jkc0luR2FtZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHByZXZXb3JkcyA9IFtdO1xyXG4gICAgaWYgKCF0aGlzLndvcmRDb250cm9sbGVyLmlzQXV0aG9yaXplZCkge1xyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5ib29rUGFnZTsgaSA+IDA7IGkgLT0gMSkge1xyXG4gICAgICAgIHByZXZXb3Jkcy5wdXNoKHRoaXMuYXBpLmdldFdvcmRzKHsgZ3JvdXA6IFN0cmluZyh0aGlzLmJvb2tMZXZlbCksIHBhZ2U6IFN0cmluZyhpIC0gMSkgfSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZXZXb3JkcylcclxuICAgICAgICAudGhlbigoZGF0YSkgPT4gZGF0YS5mb3JFYWNoKCgod29yZHMpID0+IHsgdGhpcy53b3Jkc0luR2FtZS5wdXNoKC4uLndvcmRzKTsgfSkpKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLndvcmRzSW5HYW1lLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuZmluaXNoR2FtZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMud29yZENvbnRyb2xsZXIuaXNBdXRob3JpemVkKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJvb2tQYWdlOyBpID4gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgcHJldldvcmRzLnB1c2godGhpcy5nZXRGaWx0ZXJlZFdvcmRzKFN0cmluZyh0aGlzLmJvb2tMZXZlbCksIFN0cmluZyhpIC0gMSkpKTtcclxuICAgICAgfVxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcmV2V29yZHMpXHJcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IGRhdGEuZm9yRWFjaCgoKHdvcmRzKSA9PiB7IHRoaXMud29yZHNJbkdhbWUucHVzaCguLi53b3Jkcyk7IH0pKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy53b3Jkc0luR2FtZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aGlzLmZpbmlzaEdhbWUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5ib29rUGFnZSA9IDA7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHNlbGVjdEFuc3dlcihlOiBFdmVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgYnV0dG9uID0gPEhUTUxFbGVtZW50PmUudGFyZ2V0O1xyXG4gICAgY29uc3QgeyBhbnN3ZXIgfSA9IGJ1dHRvbi5kYXRhc2V0O1xyXG4gICAgbGV0IGlzVHJ1ZTogYm9vbGVhbjtcclxuICAgIGlmIChhbnN3ZXIgPT09ICd0cnVlJykge1xyXG4gICAgICBpc1RydWUgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXNUcnVlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzVHJ1ZSA9PT0gdGhpcy5pc1BhaXJUcnVlKSB7XHJcbiAgICAgIHRoaXMuY29tcGxldGVUcnVlQW5zd2VyKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNvbXBsZXRlRmFsc2VBbnN3ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy53b3Jkc0luR2FtZS5sZW5ndGggPT09IDAgJiYgdGhpcy5tb2RlID09PSAnYm9vaycgJiYgdGhpcy5ib29rTGV2ZWwgPCA2KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuYWRkV29yZHNJbkdhbWUoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy53b3Jkc0luR2FtZS5sZW5ndGggPT09IDAgJiYgdGhpcy5tb2RlID09PSAnYm9vaycgJiYgdGhpcy5ib29rTGV2ZWwgPT09IDYpIHtcclxuICAgICAgdGhpcy5maW5pc2hHYW1lKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVdvcmQoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY29tcGxldGVUcnVlQW5zd2VyKCk6IHZvaWQge1xyXG4gICAgdGhpcy50cnVlV29yZHMucHVzaCh0aGlzLmN1cnJlbnRXb3JkISk7XHJcbiAgICB0aGlzLnVwZGF0ZVNjb3JlKCk7XHJcbiAgICB0aGlzLnRydWVBbnN3ZXJTb3VuZC5sb2FkKCk7XHJcbiAgICB0aGlzLnRydWVBbnN3ZXJTb3VuZC5wbGF5KCk7XHJcbiAgICB0aGlzLnNlcmllc09mQ29ycmVjdCArPSAxO1xyXG4gICAgdGhpcy5jaGVja1Nlcmllc09mQ29ycmVjdCgpO1xyXG4gICAgdGhpcy5jaGFuZ2VTdHlsZVNlcmllcyh0aGlzLnNlcmllc09mQ29ycmVjdCk7XHJcbiAgICB0aGlzLndvcmRDb250cm9sbGVyLnNlbmRXb3JkT25TZXJ2ZXIodGhpcy5jdXJyZW50V29yZD8uaWQhLCB0cnVlLCBHQU1FLlNQUklOVCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNvbXBsZXRlRmFsc2VBbnN3ZXIoKTogdm9pZCB7XHJcbiAgICB0aGlzLmZhbHNlV29yZHMucHVzaCh0aGlzLmN1cnJlbnRXb3JkISk7XHJcbiAgICB0aGlzLmZhbHNlQW5zd2VyU291bmQubG9hZCgpO1xyXG4gICAgdGhpcy5mYWxzZUFuc3dlclNvdW5kLnBsYXkoKTtcclxuICAgIHRoaXMuc2VyaWVzT2ZDb3JyZWN0ID0gMDtcclxuICAgIHRoaXMubXVsdGlwbGllciA9IDE7XHJcbiAgICB0aGlzLmNoYW5nZU11bHRpcGx5RGVzY3IoMSk7XHJcbiAgICB0aGlzLmNsZWFyU3R5bGVTZXJpZXMoKTtcclxuICAgIHRoaXMuY2xlYXJQYXJyb3RzKCk7XHJcbiAgICB0aGlzLndvcmRDb250cm9sbGVyLnNlbmRXb3JkT25TZXJ2ZXIodGhpcy5jdXJyZW50V29yZD8uaWQhLCBmYWxzZSwgR0FNRS5TUFJJTlQpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVXb3JkKCk6IHZvaWQge1xyXG4gICAgY29uc3Qgd29yZCA9IDxIVE1MRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbF9fd29yZC1lbicpO1xyXG4gICAgY29uc3QgdHJhbnNsYXRlID0gPEhUTUxFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sX193b3JkLXJ1Jyk7XHJcbiAgICBpZiAodGhpcy53b3Jkc0luR2FtZS5sZW5ndGggIT09IDApIHtcclxuICAgICAgY29uc3QgcmFuZG9tUGFpciA9IHRoaXMuZ2V0UmFuZG9tUGFpcigpO1xyXG4gICAgICB3b3JkLmlubmVySFRNTCA9IHJhbmRvbVBhaXIud29yZDtcclxuICAgICAgdHJhbnNsYXRlLmlubmVySFRNTCA9IHJhbmRvbVBhaXIud29yZFRyYW5zbGF0ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlU2NvcmUoKTogdm9pZCB7XHJcbiAgICBjb25zdCBzY29yZSA9IDxIVE1MRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbF9fc2NvcmUnKTtcclxuICAgIHRoaXMuc2NvcmUgKz0gdGhpcy5QT0lOVFNfRk9SX1dPUkQgKiB0aGlzLm11bHRpcGxpZXI7XHJcbiAgICBzY29yZS5pbm5lckhUTUwgPSBTdHJpbmcodGhpcy5zY29yZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNoZWNrU2VyaWVzT2ZDb3JyZWN0KCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuc2VyaWVzT2ZDb3JyZWN0ID09PSA0KSB7XHJcbiAgICAgIHRoaXMuY2hhbmdlTXVsdGlwbHlEZXNjcigyKTtcclxuICAgICAgdGhpcy5jbGVhclN0eWxlU2VyaWVzKCk7XHJcbiAgICAgIHRoaXMuYWRkUGFycm90KCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VyaWVzT2ZDb3JyZWN0ID09PSA1KSB7XHJcbiAgICAgIHRoaXMubXVsdGlwbGllciAqPSAyO1xyXG4gICAgICB0aGlzLnNlcmllc09mQ29ycmVjdCA9IDE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNoYW5nZU11bHRpcGx5RGVzY3IobXVsdGlwbHk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3QgbXVsdGlwbHlEZXNjciA9IDxIVE1MRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbF9fbXVsdGlwbHknKTtcclxuICAgIG11bHRpcGx5RGVzY3IuaW5uZXJIVE1MID0gYCske3RoaXMuUE9JTlRTX0ZPUl9XT1JEICogdGhpcy5tdWx0aXBsaWVyICogbXVsdGlwbHl9INC+0YfQutC+0LIg0LfQsCDRgdC70L7QstC+YDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2hhbmdlU3R5bGVTZXJpZXMoaXRlbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBpZiAoaXRlbSA+IDAgJiYgaXRlbSA8IDQpIHtcclxuICAgICAgY29uc3Qgc2VyaWVzID0gPEhUTUxFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXNlcmllcz1cIiR7aXRlbX1cIl1gKTtcclxuICAgICAgc2VyaWVzLmNsYXNzTGlzdC5hZGQoJ2NvbnRyb2xfX3Nlcmllcy0tYWN0aXZlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNsZWFyU3R5bGVTZXJpZXMoKTogdm9pZCB7XHJcbiAgICBjb25zdCBzZXJpZXNBbGwgPSA8Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD4+ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNvbnRyb2xfX3NlcmllcycpO1xyXG4gICAgc2VyaWVzQWxsLmZvckVhY2goKHNlcmllcykgPT4gc2VyaWVzLmNsYXNzTGlzdC5yZW1vdmUoJ2NvbnRyb2xfX3Nlcmllcy0tYWN0aXZlJykpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhZGRQYXJyb3QoKTogdm9pZCB7XHJcbiAgICBjb25zdCBwYXJyb3RzQ29udGFpbmVyID0gPEhUTUxFbGVtZW50PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sX19wYXJyb3RzJyk7XHJcbiAgICBpZiAodGhpcy5tdWx0aXBsaWVyID09PSAxKSB7XHJcbiAgICAgIGNvbnN0IHJlZFBhcnJvdCA9IGNyZWF0ZUhUTUxFbGVtZW50KCdpbWcnLCBbJ2NvbnRyb2xfX3BhcnJvdCddLCBbWydzcmMnLCAnLi9hc3NldHMvc3ByaW50L2JpcmQtcmVkLnN2ZyddLCBbJ2FsdCcsICdyZWQgcGFycm90J11dKTtcclxuICAgICAgcGFycm90c0NvbnRhaW5lci5hcHBlbmQocmVkUGFycm90KTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tdWx0aXBsaWVyID09PSAyKSB7XHJcbiAgICAgIGNvbnN0IHB1cnBsZVBhcnJvdCA9IGNyZWF0ZUhUTUxFbGVtZW50KCdpbWcnLCBbJ2NvbnRyb2xfX3BhcnJvdCddLCBbWydzcmMnLCAnLi9hc3NldHMvc3ByaW50L2JpcmQtcHVycGxlLnN2ZyddLCBbJ2FsdCcsICdwdXJwbGUgcGFycm90J11dKTtcclxuICAgICAgcGFycm90c0NvbnRhaW5lci5hcHBlbmQocHVycGxlUGFycm90KTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tdWx0aXBsaWVyID09PSA0KSB7XHJcbiAgICAgIGNvbnN0IHllbGxvd1BhcnJvdCA9IGNyZWF0ZUhUTUxFbGVtZW50KCdpbWcnLCBbJ2NvbnRyb2xfX3BhcnJvdCddLCBbWydzcmMnLCAnLi9hc3NldHMvc3ByaW50L2JpcmQteWVsbG93LnN2ZyddLCBbJ2FsdCcsICd5ZWxsb3cgcGFycm90J11dKTtcclxuICAgICAgcGFycm90c0NvbnRhaW5lci5hcHBlbmQoeWVsbG93UGFycm90KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2xlYXJQYXJyb3RzKCk6IHZvaWQge1xyXG4gICAgY29uc3QgcGFycm90cyA9IDxOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pj5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY29udHJvbF9fcGFycm90Jyk7XHJcbiAgICBjb25zdCBjb3VudCA9IHBhcnJvdHMubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb3VudDsgaSArPSAxKSB7XHJcbiAgICAgIHBhcnJvdHNbaV0ucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHZvaWNlV29yZCgpOiB2b2lkIHtcclxuICAgIGNvbnN0IHVybCA9IGAke0JBU0VfTElOS30vJHt0aGlzLmN1cnJlbnRXb3JkPy5hdWRpb31gO1xyXG4gICAgY29uc3QgYXVkaW8gPSBuZXcgQXVkaW8odXJsKTtcclxuICAgIGF1ZGlvLnBsYXkoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlQW5zd2VyU291ZCh2YWx1ZTogYm9vbGVhbik6IEhUTUxBdWRpb0VsZW1lbnQge1xyXG4gICAgY29uc3QgdXJsID0gYC4vYXNzZXRzL3NwcmludC9zb3VuZHMvJHtTdHJpbmcodmFsdWUpfS5tcDNgO1xyXG4gICAgcmV0dXJuIG5ldyBBdWRpbyh1cmwpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVGaW5pc2hTb3VuZCgpOiBIVE1MQXVkaW9FbGVtZW50IHtcclxuICAgIGNvbnN0IHVybCA9ICcuL2Fzc2V0cy9zcHJpbnQvc291bmRzL2ZpbmlzaF90aWNrLm1wMyc7XHJcbiAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbyh1cmwpO1xyXG4gICAgcmV0dXJuIGF1ZGlvO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZXJSZXN1bHQoKSB7XHJcbiAgICBjb25zdCBzcHJpbnQgPSA8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNwcmludCcpO1xyXG4gICAgY29uc3QgY29udHJvbCA9IDxIVE1MRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3ByaW50X19jb250cm9sJyk7XHJcbiAgICBjb25zdCB0aW1lciA9IDxIVE1MRWxlbWVudD5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGltZXItLWNvbnRyb2wnKTtcclxuICAgIGNvbnRyb2wuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIHRpbWVyLnJlbW92ZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0Q29udGFpbmVyID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsnc3ByaW50X19yZXN1bHQnXSk7XHJcbiAgICBjb25zdCBzY29yZSA9IGNyZWF0ZUhUTUxFbGVtZW50KCdoMicsIFsncmVzdWx0X19zY29yZSddLCB1bmRlZmluZWQsIGDQotCy0L7QuSDRgNC10LfRg9C70YzRgtCw0YI6ICR7dGhpcy5zY29yZX0g0L7Rh9C60L7QsmApO1xyXG4gICAgY29uc3QgbGlzdHNDb250YWluZXIgPSBjcmVhdGVIVE1MRWxlbWVudCgnZGl2JywgWydzcHJpbnRfX2xpc3RzJ10pO1xyXG4gICAgY29uc3QgdHJ1ZUxpc3QgPSBjcmVhdGVIVE1MRWxlbWVudCgndWwnLCBbJ3Jlc3VsdF9fdHJ1ZSddLCB1bmRlZmluZWQsIGDQl9C90LDRjjogJHt0aGlzLnRydWVXb3Jkcy5sZW5ndGh9YCk7XHJcbiAgICBjb25zdCBmYWxzZUxpc3QgPSBjcmVhdGVIVE1MRWxlbWVudCgndWwnLCBbJ3Jlc3VsdF9fZmFsc2UnXSwgdW5kZWZpbmVkLCBg0J7RiNC40LHQvtC6OiAke3RoaXMuZmFsc2VXb3Jkcy5sZW5ndGh9YCk7XHJcbiAgICBjb25zdCBidG5SZXN0YXJ0ID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2J1dHRvbicsIFsncmVzdWx0X19yZXN0YXJ0LWJ0biddLCB1bmRlZmluZWQsICfQmNCz0YDQsNGC0Ywg0LXRidC1INGA0LDQtycpO1xyXG4gICAgYnRuUmVzdGFydC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlOiBFdmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBidG4gPSA8SFRNTEJ1dHRvbkVsZW1lbnQ+ZS50YXJnZXQ7XHJcbiAgICAgIGlmICghYnRuLmRpc2FibGVkKSB7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0R2FtZSgpO1xyXG4gICAgICAgIGJ0bi5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy50cnVlV29yZHMuZm9yRWFjaCgod29yZCkgPT4gdGhpcy5hZGRXb3JkSW5SZXN1bHQodHJ1ZUxpc3QsIHdvcmQpKTtcclxuICAgIHRoaXMuZmFsc2VXb3Jkcy5mb3JFYWNoKCh3b3JkKSA9PiB0aGlzLmFkZFdvcmRJblJlc3VsdChmYWxzZUxpc3QsIHdvcmQpKTtcclxuICAgIGxpc3RzQ29udGFpbmVyLmFwcGVuZChmYWxzZUxpc3QsIHRydWVMaXN0KTtcclxuICAgIHJlc3VsdENvbnRhaW5lci5hcHBlbmQoc2NvcmUsIGxpc3RzQ29udGFpbmVyLCBidG5SZXN0YXJ0KTtcclxuICAgIHNwcmludC5hcHBlbmQocmVzdWx0Q29udGFpbmVyKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkV29yZEluUmVzdWx0KGxpc3Q6IEhUTUxFbGVtZW50LCB3b3JkOiBXb3JkKTogdm9pZCB7XHJcbiAgICBjb25zdCB3b3JkRW4gPSBjcmVhdGVIVE1MRWxlbWVudCgnc3BhbicsIFsncmVzdWx0X193b3JkLWVuJ10sIHVuZGVmaW5lZCwgYCR7d29yZC53b3JkfTogYCk7XHJcbiAgICBjb25zdCB3b3JkUnUgPSBjcmVhdGVIVE1MRWxlbWVudCgnc3BhbicsIFsncmVzdWx0X193b3JkLXJ1J10sIHVuZGVmaW5lZCwgYCR7d29yZC53b3JkVHJhbnNsYXRlfWApO1xyXG4gICAgY29uc3Qgd29yZEVuUnUgPSBjcmVhdGVIVE1MRWxlbWVudCgnbGknLCBbJ3Jlc3VsdF9fd29yZCddKTtcclxuICAgIGNvbnN0IHZvaWNlID0gY3JlYXRlSFRNTEVsZW1lbnQoJ2RpdicsIFsncmVzdWx0X192b2ljZSddKTtcclxuICAgIHZvaWNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy52b2ljZVdvcmRJblJlc3VsdCh3b3JkLmF1ZGlvKSk7XHJcbiAgICB3b3JkRW5SdS5hcHBlbmQodm9pY2UsIHdvcmRFbiwgd29yZFJ1KTtcclxuICAgIGxpc3QuYXBwZW5kKHdvcmRFblJ1KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdm9pY2VXb3JkSW5SZXN1bHQodXJsOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnN0IGF1ZGlvID0gbmV3IEF1ZGlvKGAke0JBU0VfTElOS30vJHt1cmx9YCk7XHJcbiAgICBhdWRpby5wbGF5KCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHRvZ2dsZU11dGUoZTogRXZlbnQpIHtcclxuICAgIGNvbnN0IGJ0biA9IDxIVE1MRWxlbWVudD5lLnRhcmdldDtcclxuICAgIGJ0bi5jbGFzc0xpc3QudG9nZ2xlKCdjb250cm9sX19zb3VuZC0tb2ZmJyk7XHJcbiAgICBpZiAodGhpcy5tdXRlID09PSBmYWxzZSkge1xyXG4gICAgICB0aGlzLm11dGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLnRydWVBbnN3ZXJTb3VuZC52b2x1bWUgPSAwO1xyXG4gICAgICB0aGlzLmZhbHNlQW5zd2VyU291bmQudm9sdW1lID0gMDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tdXRlID09PSB0cnVlKSB7XHJcbiAgICAgIHRoaXMubXV0ZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnRydWVBbnN3ZXJTb3VuZC52b2x1bWUgPSAxO1xyXG4gICAgICB0aGlzLmZhbHNlQW5zd2VyU291bmQudm9sdW1lID0gMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZmluaXNoR2FtZSgpIHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lckludGVydmFsKTtcclxuICAgIHRoaXMudGltZXJTb3VuZD8ucGF1c2UoKTtcclxuICAgIHRoaXMucmVuZGVyUmVzdWx0KCk7XHJcbiAgICB0aGlzLnJlbW92ZUtleWJvYXJkQ29udHJvbCgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHNldEJvb2tQYWdlQW5kTGV2ZWwobGV2ZWw6IG51bWJlciwgcGFnZTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmJvb2tQYWdlID0gcGFnZTtcclxuICAgIHRoaXMuYm9va0xldmVsID0gbGV2ZWw7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHNlbGVjdEFuc3dlckJ5Q29ycmVjdChjb3JyZWN0OiBib29sZWFuKSB7XHJcbiAgICBpZiAoY29ycmVjdCA9PT0gdGhpcy5pc1BhaXJUcnVlKSB7XHJcbiAgICAgIHRoaXMuY29tcGxldGVUcnVlQW5zd2VyKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNvbXBsZXRlRmFsc2VBbnN3ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy53b3Jkc0luR2FtZS5sZW5ndGggPT09IDAgJiYgdGhpcy5tb2RlID09PSAnYm9vaycgJiYgdGhpcy5ib29rTGV2ZWwgPCA2KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuYWRkV29yZHNJbkdhbWUoKTtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlV29yZCgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzZWxlY3RBbnN3ZXJCeUtleShlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICBsZXQgaXNUcnVlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBpZiAoZS5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xyXG4gICAgICBpc1RydWUgPSB0cnVlO1xyXG4gICAgICB0aGlzLnNlbGVjdEFuc3dlckJ5Q29ycmVjdChpc1RydWUpO1xyXG4gICAgfSBlbHNlIGlmIChlLmtleSA9PT0gJ0Fycm93TGVmdCcpIHtcclxuICAgICAgaXNUcnVlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuc2VsZWN0QW5zd2VyQnlDb3JyZWN0KGlzVHJ1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZEtleWJvYXJkQ29udHJvbCgpOiB2b2lkIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleUxpc3RlbmVyKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlS2V5Ym9hcmRDb250cm9sKCk6IHZvaWQge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5TGlzdGVuZXIpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGNsb3NlR2FtZSgpOiB2b2lkIHtcclxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYm9keScpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgYm9keT8uY2xhc3NMaXN0LnJlbW92ZSgnYm9keS0tc3ByaW50Jyk7XHJcbiAgICBjbGVhckludGVydmFsKHRoaXMudGltZXJJbnRlcnZhbCk7XHJcbiAgICB0aGlzLnRpbWVyU291bmQ/LnBhdXNlKCk7XHJcbiAgICB0aGlzLnJlbW92ZUtleWJvYXJkQ29udHJvbCgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRIYXJkV29yZHMoKTogUHJvbWlzZTxXb3JkW10+IHtcclxuICAgIGNvbnN0IHVzZXJIYXJkV29yZHMgPSBhd2FpdCB0aGlzLndvcmRDb250cm9sbGVyLmdldFVzZXJCb29rV29yZHMoKSBhcyBVc2VyQWdncmVnYXRlZFdvcmRbXTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHVzZXJIYXJkV29yZHMpKSB7XHJcbiAgICAgIHJldHVybiB1c2VySGFyZFdvcmRzLm1hcCgod29yZCkgPT4gY29udmVydEFnZ3JlZ2F0ZWRXb3JkVG9Xb3JkKHdvcmQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgY2hlY2tXb3Jkc0F2YWlsYWJpbGl0eSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIGxldCB3b3JkczogV29yZFtdO1xyXG4gICAgaWYgKHRoaXMuYm9va0xldmVsIDwgNikge1xyXG4gICAgICB3b3JkcyA9IGF3YWl0IGFwaS5nZXRXb3Jkcyh7IGdyb3VwOiBTdHJpbmcodGhpcy5ib29rTGV2ZWwpLCBwYWdlOiBTdHJpbmcodGhpcy5ib29rUGFnZSkgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3b3JkcyA9IGF3YWl0IHRoaXMuZ2V0SGFyZFdvcmRzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAwIHx8ICFBcnJheS5pc0FycmF5KHdvcmRzKSkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSA8SFRNTEVsZW1lbnQ+ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNwcmludF9fcmVzdWx0Jyk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVIVE1MRWxlbWVudCgnc3BhbicsIFsnc3ByaW50X19yZXN0YXJ0LW1lc3NhZ2UnXSwgdW5kZWZpbmVkLCAn0J3QtdC00L7RgdGC0LDRgtC+0YfQvdC+INGB0LvQvtCyINC00LvRjyDQt9Cw0L/Rg9GB0LrQsCDQvdC+0LLQvtC5INC40LPRgNGLLiDQktGL0LHQtdGA0LjRgtC1INC00YDRg9Cz0L7QuSDRg9GA0L7QstC10L3RjCDQuNC70Lgg0YHRgtGA0LDQvdC40YbRgycpO1xyXG4gICAgICByZXN1bHQuYXBwZW5kKG1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVzdGFydEdhbWUoKSB7XHJcbiAgICBjb25zdCBpc0F2YWlsYWJsZTogYm9vbGVhbiA9IGF3YWl0IHRoaXMuY2hlY2tXb3Jkc0F2YWlsYWJpbGl0eSgpO1xyXG4gICAgaWYgKGlzQXZhaWxhYmxlKSB7XHJcbiAgICAgIHRoaXMuY2xvc2VHYW1lKCk7XHJcbiAgICAgIHRoaXMud29yZHNJbkdhbWUubGVuZ3RoID0gMDtcclxuICAgICAgdGhpcy5zY29yZSA9IDA7XHJcbiAgICAgIHRoaXMubXVsdGlwbGllciA9IDE7XHJcbiAgICAgIHRoaXMuc2VyaWVzT2ZDb3JyZWN0ID0gMDtcclxuICAgICAgdGhpcy50cnVlV29yZHMubGVuZ3RoID0gMDtcclxuICAgICAgdGhpcy5mYWxzZVdvcmRzLmxlbmd0aCA9IDA7XHJcbiAgICAgIHRoaXMucmVuZGVyR2FtZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjbG9zZUdhbWVCeUxpbmsoZTogRXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IDxIVE1MQW5jaG9yRWxlbWVudD5lLnRhcmdldDtcclxuICAgIGlmICh0YXJnZXQuaHJlZiAhPT0gYCR7QkFTRV9MSU5LfS9zcHJpbnRgKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlTGlua3NMaXN0ZW5lcnMoKTtcclxuICAgICAgdGhpcy5jbG9zZUdhbWUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlTGlua3NMaXN0ZW5lcnMoKSB7XHJcbiAgICBjb25zdCBsaW5rcyA9IDxOb2RlTGlzdE9mPEhUTUxBbmNob3JFbGVtZW50Pj5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XHJcbiAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5saW5rc0hhbmRsZXIpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkTGlua3NIYW5kbGVyKCkge1xyXG4gICAgY29uc3QgaHJlZiA9IGAke2RvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sfS8vJHtkb2N1bWVudC5sb2NhdGlvbi5ob3N0fWA7XHJcbiAgICBjb25zdCBsaW5rcyA9IDxOb2RlTGlzdE9mPEhUTUxBbmNob3JFbGVtZW50Pj5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XHJcbiAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XHJcbiAgICAgIGlmIChsaW5rLmhyZWYgIT09IGAke2hyZWZ9L3NwcmludGApIHtcclxuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5saW5rc0hhbmRsZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2956\n")},8305:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.TextBook = void 0;\r\nconst Word_1 = __webpack_require__(6610);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst api_1 = __webpack_require__(1341);\r\nconst constants_1 = __webpack_require__(5004);\r\nconst checkEmptyUserBook_1 = __webpack_require__(6285);\r\nconst checkPageAllDone_1 = __webpack_require__(9103);\r\nclass TextBook {\r\n    constructor(numberOfLevels) {\r\n        this.api = new api_1.Api();\r\n        this.currentPage = 0;\r\n        this.currentLevel = 0;\r\n        this.textBook = (0, createNode_1.default)({ tag: 'section', classes: ['textbook'] });\r\n        this.cardsWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['cards-wrapper'] });\r\n        this.level1Btns = this.createLevelButtons(numberOfLevels);\r\n        this.page = (0, createNode_1.default)({ tag: 'div', classes: ['text-book-page'] });\r\n        this.audioCallBtn = (0, createNode_1.default)({\r\n            tag: 'a', classes: ['btn'], inner: 'Аудиовызов', atributesAdnValues: [['id', 'audiocall-btn'], ['href', '/book/audiocall'], ['data-navigo', 'true']],\r\n        });\r\n        this.sprintBtn = (0, createNode_1.default)({\r\n            tag: 'a', classes: ['btn'], inner: 'Спринт', atributesAdnValues: [['id', 'sprint-btn'], ['href', '/book/sprint'], ['data-navigo', 'true']],\r\n        });\r\n        this.prevPageBtn = (0, createNode_1.default)({ tag: 'button', classes: ['btn'], inner: 'Предыдущая' });\r\n        this.nextPageBtn = (0, createNode_1.default)({ tag: 'button', classes: ['btn'], inner: 'Следующая' });\r\n        this.pageInput = (0, createNode_1.default)({ tag: 'input', classes: ['page-input'], atributesAdnValues: [['type', 'number']] });\r\n        this.pageInput.value = String(this.currentPage + 1);\r\n        this.words = [];\r\n        this.linksHandler = this.stopSoundByLink.bind(this);\r\n    }\r\n    // Update textBook and cards separately\r\n    updateTextbook(data, flag, group, page) {\r\n        this.textBook.innerHTML = '';\r\n        this.cardsWrapper.style.border = 'none';\r\n        this.pageInput.style.backgroundColor = 'transparent';\r\n        this.level1Btns.map((btn) => btn.classList.remove('btn-active'));\r\n        this.level1Btns[group].classList.add('btn-active');\r\n        this.currentLevel = group;\r\n        this.renderTextBook(data);\r\n        this.currentPage = page ? this.currentPage = page : this.currentPage = 0;\r\n        this.pageInput.value = String(page + 1);\r\n        this.handlePageButtons();\r\n        if (flag === true) {\r\n            this.level1Btns[6].style.display = 'flex';\r\n            const learnBtns = document.querySelectorAll('.btn-learn');\r\n            const hardBtns = document.querySelectorAll('.btn-add');\r\n            // eslint-disable-next-line no-param-reassign, no-return-assign\r\n            learnBtns.forEach((btn) => btn.style.display = 'flex');\r\n            // eslint-disable-next-line no-param-reassign, no-return-assign\r\n            hardBtns.forEach((btn) => btn.style.display = 'flex');\r\n            // this.handlePageAllDone(data);\r\n            (0, checkPageAllDone_1.checkPageAllDone)();\r\n            (0, checkEmptyUserBook_1.checkEmptyUserBook)();\r\n        }\r\n        this.words.forEach((word) => word.wordAudio?.pause());\r\n    }\r\n    updateCards(data) {\r\n        this.cardsWrapper.innerHTML = '';\r\n        this.renderCards(data);\r\n    }\r\n    // Listen level buttons and pagination\r\n    listenLevels(handler) {\r\n        this.level1Btns.forEach((button) => {\r\n            button.addEventListener('click', (e) => {\r\n                this.level1Btns.map((btn) => btn.classList.remove('btn-active'));\r\n                button.classList.add('btn-active');\r\n                this.currentPage = 0;\r\n                this.pageInput.value = String(this.currentPage + 1);\r\n                const target = Number(e.target.innerHTML);\r\n                const level = target - 1;\r\n                this.currentLevel = level;\r\n                this.handlePageButtons();\r\n                handler(String(level), '0');\r\n            });\r\n        });\r\n    }\r\n    listenPagination(handler) {\r\n        this.prevPageBtn.addEventListener('click', () => {\r\n            const level = this.handleLevelButtons();\r\n            this.currentPage -= 1;\r\n            this.pageInput.value = String(this.currentPage + 1);\r\n            this.handleInput(this.pageInput);\r\n            this.handlePageButtons();\r\n            handler(String(level), String(this.currentPage));\r\n        });\r\n        this.nextPageBtn.addEventListener('click', () => {\r\n            const level = this.handleLevelButtons();\r\n            this.currentPage += 1;\r\n            this.pageInput.value = String(this.currentPage + 1);\r\n            this.handleInput(this.pageInput);\r\n            this.handlePageButtons();\r\n            handler(String(level), String(this.currentPage));\r\n        });\r\n        this.pageInput.addEventListener('change', (e) => {\r\n            const level = this.handleLevelButtons();\r\n            const newPageNumber = Number(e.target.value);\r\n            this.currentPage = newPageNumber - 1;\r\n            this.handleInput(this.pageInput);\r\n            this.handlePageButtons();\r\n            handler(String(level), String(this.currentPage));\r\n        });\r\n    }\r\n    // Handle changes when switching pages (buttons and input) and levels\r\n    handlePageButtons() {\r\n        if (this.currentPage > 0) {\r\n            this.prevPageBtn.disabled = false;\r\n        }\r\n        else if (this.currentPage <= 0) {\r\n            this.prevPageBtn.disabled = true;\r\n        }\r\n        else {\r\n            this.prevPageBtn.disabled = false;\r\n        }\r\n        if (this.currentPage === 29) {\r\n            this.nextPageBtn.disabled = true;\r\n        }\r\n        else {\r\n            this.nextPageBtn.disabled = false;\r\n        }\r\n    }\r\n    handleLevelButtons() {\r\n        const levelBtn = this.level1Btns.filter((btn) => btn.classList.contains('btn-active'));\r\n        const level = levelBtn.length === 0 ? '0' : Number(levelBtn[0].innerHTML) - 1;\r\n        this.currentLevel = Number(level);\r\n        console.log(levelBtn[0].style.backgroundColor);\r\n        return level;\r\n    }\r\n    handleInput(input) {\r\n        const currInput = input;\r\n        if (Number(input.value) > constants_1.MAX_PAGE_NUMBER) {\r\n            currInput.value = '30';\r\n            this.currentPage = 29;\r\n        }\r\n        else if (Number(input.value) <= 0) {\r\n            currInput.value = '1';\r\n            this.currentPage = 0;\r\n        }\r\n        else {\r\n            currInput.value = String(this.currentPage + 1);\r\n        }\r\n        return currInput;\r\n    }\r\n    // Render TextBook and components\r\n    renderTextBook(data) {\r\n        const container = document.querySelector('.main');\r\n        container.innerHTML = '';\r\n        this.page.innerHTML = '';\r\n        const pageHead = this.renderTBHeader();\r\n        const sidebar = this.rendeSidebar();\r\n        this.renderCards(data);\r\n        this.page.append(pageHead, this.cardsWrapper);\r\n        this.handleLevelButtons();\r\n        if (this.currentLevel !== 6) {\r\n            const paginationWrapper = this.renderPagination();\r\n            paginationWrapper.append(this.prevPageBtn, this.pageInput, this.nextPageBtn);\r\n            this.page.append(paginationWrapper);\r\n        }\r\n        this.textBook.append(sidebar, this.page);\r\n        container.append(this.textBook);\r\n        this.changPageBG();\r\n        return container;\r\n    }\r\n    renderTBHeader() {\r\n        const pageHead = (0, createNode_1.default)({ tag: 'div', classes: ['text-book-page-head'] });\r\n        const pageHeadText = (0, createNode_1.default)({ tag: 'p', classes: ['page-head-wrapper'], inner: 'Играть с текущим набором слов:' });\r\n        pageHead.append(pageHeadText, this.audioCallBtn, this.sprintBtn);\r\n        return pageHead;\r\n    }\r\n    renderCards(cardsData) {\r\n        this.cardsWrapper.innerHTML = '';\r\n        if (typeof cardsData === 'string') {\r\n            this.cardsWrapper.innerHTML = cardsData;\r\n            this.audioCallBtn.classList.add('btn__disabled');\r\n            this.sprintBtn.classList.add('btn__disabled');\r\n        }\r\n        else {\r\n            cardsData.forEach((card) => {\r\n                const cardItem = new Word_1.WordUI(card, this.words);\r\n                this.cardsWrapper.append(cardItem.drawCard());\r\n                this.words.push(cardItem);\r\n            });\r\n        }\r\n        return this.cardsWrapper;\r\n    }\r\n    rendeSidebar() {\r\n        const sideBar = (0, createNode_1.default)({ tag: 'aside', classes: ['aside'] });\r\n        const sideBarContent = (0, createNode_1.default)({ tag: 'div', classes: ['sidebar-content'] });\r\n        const sidebarText = (0, createNode_1.default)({ tag: 'p', classes: ['sidebar-text'], inner: 'Уровни' });\r\n        sideBarContent.append(sidebarText);\r\n        this.level1Btns.forEach((btn) => sideBarContent.append(btn));\r\n        sideBar.append(sideBarContent);\r\n        this.level1Btns[6].classList.add('user-words-btn');\r\n        this.level1Btns[6].style.display = 'none';\r\n        return sideBar;\r\n    }\r\n    createLevelButtons(levelsNumber) {\r\n        const arr = [];\r\n        let i = 1;\r\n        while (levelsNumber) {\r\n            const btn = (0, createNode_1.default)({ tag: 'button', classes: ['btn-level'], inner: `${i}` });\r\n            btn.classList.add(`btn-level-${i}`);\r\n            arr.push(btn);\r\n            i += 1;\r\n            // eslint-disable-next-line no-param-reassign\r\n            levelsNumber -= 1;\r\n        }\r\n        return arr;\r\n    }\r\n    renderPagination() {\r\n        const paginationWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['pagination'] });\r\n        this.prevPageBtn.disabled = true;\r\n        this.nextPageBtn.disabled = false;\r\n        paginationWrapper.append(this.prevPageBtn, this.pageInput, this.nextPageBtn);\r\n        return paginationWrapper;\r\n    }\r\n    stopSoundByLink() {\r\n        this.removeLinksListeners();\r\n        this.words.forEach((word) => word.wordAudio?.pause());\r\n    }\r\n    removeLinksListeners() {\r\n        const links = document.querySelectorAll('a');\r\n        links.forEach((link) => link.removeEventListener('click', this.linksHandler));\r\n    }\r\n    addLinksHandler() {\r\n        const href = `${document.location.protocol}//${document.location.host}`;\r\n        const links = document.querySelectorAll('a');\r\n        links.forEach((link) => {\r\n            if (link.href !== `${href}/book`) {\r\n                link.addEventListener('click', this.linksHandler);\r\n            }\r\n        });\r\n    }\r\n    changPageBG() {\r\n        const btnActive = this.level1Btns.filter((btn) => btn.classList.contains('btn-active'))[0];\r\n        const btnColor = window.getComputedStyle(btnActive, null).getPropertyValue('background-color');\r\n        this.page.style.backgroundColor = btnColor;\r\n    }\r\n}\r\nexports.TextBook = TextBook;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDaEYsQ0FBQztJQUVNLGVBQWU7UUFDcEIsTUFBTSxJQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3hFLE1BQU0sS0FBSyxHQUFrQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ3JCLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHLElBQUksT0FBTyxFQUFFO2dCQUNoQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUNuRDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLFdBQVc7UUFDakIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQy9GLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxRQUFRLENBQUM7SUFDN0MsQ0FBQztDQUNGO0FBL1FELDRCQStRQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy90ZXh0Qm9vay9UZXh0Qm9vay50cz84YTM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdvcmRVSSB9IGZyb20gJy4vV29yZCc7XHJcbmltcG9ydCBjcmVhdGVOb2RlIGZyb20gJy4uL3V0aWxzL2NyZWF0ZU5vZGUnO1xyXG5pbXBvcnQgeyBVc2VyQWdncmVnYXRlZFdvcmQsIFdvcmQgfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgQXBpIH0gZnJvbSAnLi4vTW9kZWwvYXBpJztcclxuaW1wb3J0IHsgTUFYX1BBR0VfTlVNQkVSIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbnRzJztcclxuaW1wb3J0IHsgY2hlY2tFbXB0eVVzZXJCb29rIH0gZnJvbSAnLi4vdXRpbHMvY2hlY2tFbXB0eVVzZXJCb29rJztcclxuaW1wb3J0IHsgY2hlY2tQYWdlQWxsRG9uZSB9IGZyb20gJy4uL3V0aWxzL2NoZWNrUGFnZUFsbERvbmUnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRleHRCb29rIHtcclxuICB0ZXh0Qm9vazogSFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gIGNhcmRzV3JhcHBlcjogSFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gIGxldmVsMUJ0bnM6IEhUTUxCdXR0b25FbGVtZW50W107XHJcblxyXG4gIGF1ZGlvQ2FsbEJ0bjogSFRNTEFuY2hvckVsZW1lbnQ7XHJcblxyXG4gIHNwcmludEJ0bjogSFRNTEFuY2hvckVsZW1lbnQ7XHJcblxyXG4gIGFwaTogQXBpID0gbmV3IEFwaSgpO1xyXG5cclxuICBjdXJyZW50UGFnZTogbnVtYmVyID0gMDtcclxuXHJcbiAgY3VycmVudExldmVsOiBudW1iZXIgPSAwO1xyXG5cclxuICBwcmV2UGFnZUJ0bjogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcblxyXG4gIG5leHRQYWdlQnRuOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuXHJcbiAgcGFnZUlucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICB3b3JkczogV29yZFVJW107XHJcblxyXG4gIHBhZ2U6IEhUTUxEaXZFbGVtZW50O1xyXG5cclxuICBsaW5rc0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZDtcclxuXHJcbiAgY29uc3RydWN0b3IobnVtYmVyT2ZMZXZlbHM6IG51bWJlcikge1xyXG4gICAgdGhpcy50ZXh0Qm9vayA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdzZWN0aW9uJywgY2xhc3NlczogWyd0ZXh0Ym9vayddIH0pIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgdGhpcy5jYXJkc1dyYXBwZXIgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydjYXJkcy13cmFwcGVyJ10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICB0aGlzLmxldmVsMUJ0bnMgPSB0aGlzLmNyZWF0ZUxldmVsQnV0dG9ucyhudW1iZXJPZkxldmVscyk7XHJcbiAgICB0aGlzLnBhZ2UgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWyd0ZXh0LWJvb2stcGFnZSddIH0pIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgdGhpcy5hdWRpb0NhbGxCdG4gPSBjcmVhdGVOb2RlKHtcclxuICAgICAgdGFnOiAnYScsIGNsYXNzZXM6IFsnYnRuJ10sIGlubmVyOiAn0JDRg9C00LjQvtCy0YvQt9C+0LInLCBhdHJpYnV0ZXNBZG5WYWx1ZXM6IFtbJ2lkJywgJ2F1ZGlvY2FsbC1idG4nXSwgWydocmVmJywgJy9ib29rL2F1ZGlvY2FsbCddLCBbJ2RhdGEtbmF2aWdvJywgJ3RydWUnXV0sXHJcbiAgICB9KSBhcyBIVE1MQW5jaG9yRWxlbWVudDtcclxuICAgIHRoaXMuc3ByaW50QnRuID0gY3JlYXRlTm9kZSh7XHJcbiAgICAgIHRhZzogJ2EnLCBjbGFzc2VzOiBbJ2J0biddLCBpbm5lcjogJ9Ch0L/RgNC40L3RgicsIGF0cmlidXRlc0FkblZhbHVlczogW1snaWQnLCAnc3ByaW50LWJ0biddLCBbJ2hyZWYnLCAnL2Jvb2svc3ByaW50J10sIFsnZGF0YS1uYXZpZ28nLCAndHJ1ZSddXSxcclxuICAgIH0pIGFzIEhUTUxBbmNob3JFbGVtZW50O1xyXG4gICAgdGhpcy5wcmV2UGFnZUJ0biA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdidXR0b24nLCBjbGFzc2VzOiBbJ2J0biddLCBpbm5lcjogJ9Cf0YDQtdC00YvQtNGD0YnQsNGPJyB9KSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHRoaXMubmV4dFBhZ2VCdG4gPSBjcmVhdGVOb2RlKHsgdGFnOiAnYnV0dG9uJywgY2xhc3NlczogWydidG4nXSwgaW5uZXI6ICfQodC70LXQtNGD0Y7RidCw0Y8nIH0pIGFzIEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgdGhpcy5wYWdlSW5wdXQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnaW5wdXQnLCBjbGFzc2VzOiBbJ3BhZ2UtaW5wdXQnXSwgYXRyaWJ1dGVzQWRuVmFsdWVzOiBbWyd0eXBlJywgJ251bWJlciddXSB9KSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgdGhpcy5wYWdlSW5wdXQudmFsdWUgPSBTdHJpbmcodGhpcy5jdXJyZW50UGFnZSArIDEpO1xyXG4gICAgdGhpcy53b3JkcyA9IFtdO1xyXG4gICAgdGhpcy5saW5rc0hhbmRsZXIgPSB0aGlzLnN0b3BTb3VuZEJ5TGluay5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRleHRCb29rIGFuZCBjYXJkcyBzZXBhcmF0ZWx5XHJcbiAgcHVibGljIHVwZGF0ZVRleHRib29rKFxyXG4gICAgZGF0YTogc3RyaW5nIHwgV29yZFtdIHwgVXNlckFnZ3JlZ2F0ZWRXb3JkW10sXHJcbiAgICBmbGFnOiBCb29sZWFuLFxyXG4gICAgZ3JvdXA6IG51bWJlcixcclxuICAgIHBhZ2U6IG51bWJlcixcclxuICApIHtcclxuICAgIHRoaXMudGV4dEJvb2suaW5uZXJIVE1MID0gJyc7XHJcbiAgICB0aGlzLmNhcmRzV3JhcHBlci5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XHJcbiAgICB0aGlzLnBhZ2VJbnB1dC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xyXG4gICAgdGhpcy5sZXZlbDFCdG5zLm1hcCgoYnRuKSA9PiBidG4uY2xhc3NMaXN0LnJlbW92ZSgnYnRuLWFjdGl2ZScpKTtcclxuICAgIHRoaXMubGV2ZWwxQnRuc1tncm91cF0uY2xhc3NMaXN0LmFkZCgnYnRuLWFjdGl2ZScpO1xyXG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBncm91cDtcclxuICAgIHRoaXMucmVuZGVyVGV4dEJvb2soZGF0YSk7XHJcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZSA/IHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlIDogdGhpcy5jdXJyZW50UGFnZSA9IDA7XHJcbiAgICB0aGlzLnBhZ2VJbnB1dC52YWx1ZSA9IFN0cmluZyhwYWdlICsgMSk7XHJcbiAgICB0aGlzLmhhbmRsZVBhZ2VCdXR0b25zKCk7XHJcbiAgICBpZiAoZmxhZyA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aGlzLmxldmVsMUJ0bnNbNl0uc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgY29uc3QgbGVhcm5CdG5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJ0bi1sZWFybicpIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+O1xyXG4gICAgICBjb25zdCBoYXJkQnRucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5idG4tYWRkJykgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD47XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tcmV0dXJuLWFzc2lnblxyXG4gICAgICBsZWFybkJ0bnMuZm9yRWFjaCgoYnRuKSA9PiBidG4uc3R5bGUuZGlzcGxheSA9ICdmbGV4Jyk7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tcmV0dXJuLWFzc2lnblxyXG4gICAgICBoYXJkQnRucy5mb3JFYWNoKChidG4pID0+IGJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnKTtcclxuICAgICAgLy8gdGhpcy5oYW5kbGVQYWdlQWxsRG9uZShkYXRhKTtcclxuICAgICAgY2hlY2tQYWdlQWxsRG9uZSgpO1xyXG4gICAgICBjaGVja0VtcHR5VXNlckJvb2soKTtcclxuICAgIH1cclxuICAgIHRoaXMud29yZHMuZm9yRWFjaCgod29yZCkgPT4gd29yZC53b3JkQXVkaW8/LnBhdXNlKCkpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHVwZGF0ZUNhcmRzKGRhdGE6IFdvcmRbXSB8IFVzZXJBZ2dyZWdhdGVkV29yZFtdKSB7XHJcbiAgICB0aGlzLmNhcmRzV3JhcHBlci5pbm5lckhUTUwgPSAnJztcclxuICAgIHRoaXMucmVuZGVyQ2FyZHMoZGF0YSk7XHJcbiAgfVxyXG5cclxuICAvLyBMaXN0ZW4gbGV2ZWwgYnV0dG9ucyBhbmQgcGFnaW5hdGlvblxyXG5cclxuICBsaXN0ZW5MZXZlbHMoaGFuZGxlcjogKGdyb3VwOiBzdHJpbmcsIHBhZ2U6IHN0cmluZykgPT4gdm9pZCkge1xyXG4gICAgdGhpcy5sZXZlbDFCdG5zLmZvckVhY2goKGJ1dHRvbikgPT4ge1xyXG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZTogRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmxldmVsMUJ0bnMubWFwKChidG4pID0+IGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdidG4tYWN0aXZlJykpO1xyXG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdidG4tYWN0aXZlJyk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5wYWdlSW5wdXQudmFsdWUgPSBTdHJpbmcodGhpcy5jdXJyZW50UGFnZSArIDEpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldDogbnVtYmVyID0gTnVtYmVyKChlLnRhcmdldCBhcyBIVE1MQnV0dG9uRWxlbWVudCkuaW5uZXJIVE1MKTtcclxuICAgICAgICBjb25zdCBsZXZlbCA9IHRhcmdldCAtIDE7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBsZXZlbDtcclxuICAgICAgICB0aGlzLmhhbmRsZVBhZ2VCdXR0b25zKCk7XHJcbiAgICAgICAgaGFuZGxlcihTdHJpbmcobGV2ZWwpLCAnMCcpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgbGlzdGVuUGFnaW5hdGlvbihoYW5kbGVyOiAoZ3JvdXA6IHN0cmluZywgcGFnZTogc3RyaW5nKSA9PiB2b2lkKSB7XHJcbiAgICB0aGlzLnByZXZQYWdlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGFuZGxlTGV2ZWxCdXR0b25zKCk7XHJcbiAgICAgIHRoaXMuY3VycmVudFBhZ2UgLT0gMTtcclxuICAgICAgdGhpcy5wYWdlSW5wdXQudmFsdWUgPSBTdHJpbmcodGhpcy5jdXJyZW50UGFnZSArIDEpO1xyXG4gICAgICB0aGlzLmhhbmRsZUlucHV0KHRoaXMucGFnZUlucHV0KTtcclxuICAgICAgdGhpcy5oYW5kbGVQYWdlQnV0dG9ucygpO1xyXG4gICAgICBoYW5kbGVyKFN0cmluZyhsZXZlbCksIFN0cmluZyh0aGlzLmN1cnJlbnRQYWdlKSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMubmV4dFBhZ2VCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5oYW5kbGVMZXZlbEJ1dHRvbnMoKTtcclxuICAgICAgdGhpcy5jdXJyZW50UGFnZSArPSAxO1xyXG4gICAgICB0aGlzLnBhZ2VJbnB1dC52YWx1ZSA9IFN0cmluZyh0aGlzLmN1cnJlbnRQYWdlICsgMSk7XHJcbiAgICAgIHRoaXMuaGFuZGxlSW5wdXQodGhpcy5wYWdlSW5wdXQpO1xyXG4gICAgICB0aGlzLmhhbmRsZVBhZ2VCdXR0b25zKCk7XHJcbiAgICAgIGhhbmRsZXIoU3RyaW5nKGxldmVsKSwgU3RyaW5nKHRoaXMuY3VycmVudFBhZ2UpKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wYWdlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGU6IEV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5oYW5kbGVMZXZlbEJ1dHRvbnMoKTtcclxuICAgICAgY29uc3QgbmV3UGFnZU51bWJlcjogbnVtYmVyID0gTnVtYmVyKChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSk7XHJcbiAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSBuZXdQYWdlTnVtYmVyIC0gMTtcclxuICAgICAgdGhpcy5oYW5kbGVJbnB1dCh0aGlzLnBhZ2VJbnB1dCk7XHJcbiAgICAgIHRoaXMuaGFuZGxlUGFnZUJ1dHRvbnMoKTtcclxuICAgICAgaGFuZGxlcihTdHJpbmcobGV2ZWwpLCBTdHJpbmcodGhpcy5jdXJyZW50UGFnZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBIYW5kbGUgY2hhbmdlcyB3aGVuIHN3aXRjaGluZyBwYWdlcyAoYnV0dG9ucyBhbmQgaW5wdXQpIGFuZCBsZXZlbHNcclxuICBwcml2YXRlIGhhbmRsZVBhZ2VCdXR0b25zKCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPiAwKSB7XHJcbiAgICAgIHRoaXMucHJldlBhZ2VCdG4uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50UGFnZSA8PSAwKSB7XHJcbiAgICAgIHRoaXMucHJldlBhZ2VCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wcmV2UGFnZUJ0bi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPT09IDI5KSB7XHJcbiAgICAgIHRoaXMubmV4dFBhZ2VCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5uZXh0UGFnZUJ0bi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVMZXZlbEJ1dHRvbnMoKSB7XHJcbiAgICBjb25zdCBsZXZlbEJ0biA9IHRoaXMubGV2ZWwxQnRucy5maWx0ZXIoKGJ0bikgPT4gYnRuLmNsYXNzTGlzdC5jb250YWlucygnYnRuLWFjdGl2ZScpKTtcclxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxCdG4ubGVuZ3RoID09PSAwID8gJzAnIDogTnVtYmVyKGxldmVsQnRuWzBdLmlubmVySFRNTCkgLSAxO1xyXG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBOdW1iZXIobGV2ZWwpO1xyXG4gICAgY29uc29sZS5sb2cobGV2ZWxCdG5bMF0uc3R5bGUuYmFja2dyb3VuZENvbG9yKTtcclxuICAgIHJldHVybiBsZXZlbDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaGFuZGxlSW5wdXQoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpIHtcclxuICAgIGNvbnN0IGN1cnJJbnB1dCA9IGlucHV0O1xyXG4gICAgaWYgKE51bWJlcihpbnB1dC52YWx1ZSkgPiBNQVhfUEFHRV9OVU1CRVIpIHtcclxuICAgICAgY3VycklucHV0LnZhbHVlID0gJzMwJztcclxuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IDI5O1xyXG4gICAgfSBlbHNlIGlmIChOdW1iZXIoaW5wdXQudmFsdWUpIDw9IDApIHtcclxuICAgICAgY3VycklucHV0LnZhbHVlID0gJzEnO1xyXG4gICAgICB0aGlzLmN1cnJlbnRQYWdlID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJJbnB1dC52YWx1ZSA9IFN0cmluZyh0aGlzLmN1cnJlbnRQYWdlICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycklucHV0O1xyXG4gIH1cclxuXHJcbiAgLy8gUmVuZGVyIFRleHRCb29rIGFuZCBjb21wb25lbnRzXHJcbiAgcHVibGljIHJlbmRlclRleHRCb29rKGRhdGE6IHN0cmluZyB8IFdvcmRbXSB8IFVzZXJBZ2dyZWdhdGVkV29yZFtdKTogSFRNTEVsZW1lbnQge1xyXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgICB0aGlzLnBhZ2UuaW5uZXJIVE1MID0gJyc7XHJcbiAgICBjb25zdCBwYWdlSGVhZDogSFRNTERpdkVsZW1lbnQgPSB0aGlzLnJlbmRlclRCSGVhZGVyKCk7XHJcbiAgICBjb25zdCBzaWRlYmFyID0gdGhpcy5yZW5kZVNpZGViYXIoKTtcclxuICAgIHRoaXMucmVuZGVyQ2FyZHMoZGF0YSk7XHJcbiAgICB0aGlzLnBhZ2UuYXBwZW5kKHBhZ2VIZWFkLCB0aGlzLmNhcmRzV3JhcHBlcik7XHJcbiAgICB0aGlzLmhhbmRsZUxldmVsQnV0dG9ucygpO1xyXG4gICAgaWYgKHRoaXMuY3VycmVudExldmVsICE9PSA2KSB7XHJcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25XcmFwcGVyOiBIVE1MRGl2RWxlbWVudCA9IHRoaXMucmVuZGVyUGFnaW5hdGlvbigpO1xyXG4gICAgICBwYWdpbmF0aW9uV3JhcHBlci5hcHBlbmQodGhpcy5wcmV2UGFnZUJ0biwgdGhpcy5wYWdlSW5wdXQsIHRoaXMubmV4dFBhZ2VCdG4pO1xyXG4gICAgICB0aGlzLnBhZ2UuYXBwZW5kKHBhZ2luYXRpb25XcmFwcGVyKTtcclxuICAgIH1cclxuICAgIHRoaXMudGV4dEJvb2suYXBwZW5kKHNpZGViYXIsIHRoaXMucGFnZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kKHRoaXMudGV4dEJvb2spO1xyXG4gICAgdGhpcy5jaGFuZ1BhZ2VCRygpO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVuZGVyVEJIZWFkZXIoKSB7XHJcbiAgICBjb25zdCBwYWdlSGVhZDogSFRNTERpdkVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWyd0ZXh0LWJvb2stcGFnZS1oZWFkJ10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBjb25zdCBwYWdlSGVhZFRleHQ6IEhUTUxQYXJhZ3JhcGhFbGVtZW50ID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ3BhZ2UtaGVhZC13cmFwcGVyJ10sIGlubmVyOiAn0JjQs9GA0LDRgtGMINGBINGC0LXQutGD0YnQuNC8INC90LDQsdC+0YDQvtC8INGB0LvQvtCyOicgfSkgYXMgSFRNTFBhcmFncmFwaEVsZW1lbnQ7XHJcbiAgICBwYWdlSGVhZC5hcHBlbmQocGFnZUhlYWRUZXh0LCB0aGlzLmF1ZGlvQ2FsbEJ0biwgdGhpcy5zcHJpbnRCdG4pO1xyXG4gICAgcmV0dXJuIHBhZ2VIZWFkO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZXJDYXJkcyhjYXJkc0RhdGE6IHN0cmluZyB8IFdvcmRbXSB8IFVzZXJBZ2dyZWdhdGVkV29yZFtdKSB7XHJcbiAgICB0aGlzLmNhcmRzV3JhcHBlci5pbm5lckhUTUwgPSAnJztcclxuICAgIGlmICh0eXBlb2YgY2FyZHNEYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICB0aGlzLmNhcmRzV3JhcHBlci5pbm5lckhUTUwgPSBjYXJkc0RhdGE7XHJcbiAgICAgIHRoaXMuYXVkaW9DYWxsQnRuLmNsYXNzTGlzdC5hZGQoJ2J0bl9fZGlzYWJsZWQnKTtcclxuICAgICAgdGhpcy5zcHJpbnRCdG4uY2xhc3NMaXN0LmFkZCgnYnRuX19kaXNhYmxlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2FyZHNEYXRhLmZvckVhY2goKGNhcmQpID0+IHtcclxuICAgICAgICBjb25zdCBjYXJkSXRlbSA9IG5ldyBXb3JkVUkoY2FyZCwgdGhpcy53b3Jkcyk7XHJcbiAgICAgICAgdGhpcy5jYXJkc1dyYXBwZXIuYXBwZW5kKGNhcmRJdGVtLmRyYXdDYXJkKCkpO1xyXG4gICAgICAgIHRoaXMud29yZHMucHVzaChjYXJkSXRlbSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuY2FyZHNXcmFwcGVyO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZVNpZGViYXIoKTogSFRNTEVsZW1lbnQge1xyXG4gICAgY29uc3Qgc2lkZUJhcjogSFRNTEVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnYXNpZGUnLCBjbGFzc2VzOiBbJ2FzaWRlJ10gfSk7XHJcbiAgICBjb25zdCBzaWRlQmFyQ29udGVudDogSFRNTEVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydzaWRlYmFyLWNvbnRlbnQnXSB9KTtcclxuICAgIGNvbnN0IHNpZGViYXJUZXh0OiBIVE1MUGFyYWdyYXBoRWxlbWVudCA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdwJywgY2xhc3NlczogWydzaWRlYmFyLXRleHQnXSwgaW5uZXI6ICfQo9GA0L7QstC90LgnIH0pIGFzIEhUTUxQYXJhZ3JhcGhFbGVtZW50O1xyXG4gICAgc2lkZUJhckNvbnRlbnQuYXBwZW5kKHNpZGViYXJUZXh0KTtcclxuICAgIHRoaXMubGV2ZWwxQnRucy5mb3JFYWNoKChidG4pID0+IHNpZGVCYXJDb250ZW50LmFwcGVuZChidG4pKTtcclxuICAgIHNpZGVCYXIuYXBwZW5kKHNpZGVCYXJDb250ZW50KTtcclxuICAgIHRoaXMubGV2ZWwxQnRuc1s2XS5jbGFzc0xpc3QuYWRkKCd1c2VyLXdvcmRzLWJ0bicpO1xyXG4gICAgdGhpcy5sZXZlbDFCdG5zWzZdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICByZXR1cm4gc2lkZUJhcjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlTGV2ZWxCdXR0b25zKGxldmVsc051bWJlcjogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBhcnI6IEhUTUxCdXR0b25FbGVtZW50W10gPSBbXTtcclxuICAgIGxldCBpOiBudW1iZXIgPSAxO1xyXG4gICAgd2hpbGUgKGxldmVsc051bWJlcikge1xyXG4gICAgICBjb25zdCBidG4gPSBjcmVhdGVOb2RlKHsgdGFnOiAnYnV0dG9uJywgY2xhc3NlczogWydidG4tbGV2ZWwnXSwgaW5uZXI6IGAke2l9YCB9KSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgICAgYnRuLmNsYXNzTGlzdC5hZGQoYGJ0bi1sZXZlbC0ke2l9YCk7XHJcbiAgICAgIGFyci5wdXNoKGJ0bik7XHJcbiAgICAgIGkgKz0gMTtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICAgIGxldmVsc051bWJlciAtPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVuZGVyUGFnaW5hdGlvbigpOiBIVE1MRGl2RWxlbWVudCB7XHJcbiAgICBjb25zdCBwYWdpbmF0aW9uV3JhcHBlcjogSFRNTERpdkVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydwYWdpbmF0aW9uJ10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICB0aGlzLnByZXZQYWdlQnRuLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgIHRoaXMubmV4dFBhZ2VCdG4uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIHBhZ2luYXRpb25XcmFwcGVyLmFwcGVuZCh0aGlzLnByZXZQYWdlQnRuLCB0aGlzLnBhZ2VJbnB1dCwgdGhpcy5uZXh0UGFnZUJ0bik7XHJcbiAgICByZXR1cm4gcGFnaW5hdGlvbldyYXBwZXI7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0b3BTb3VuZEJ5TGluaygpIHtcclxuICAgIHRoaXMucmVtb3ZlTGlua3NMaXN0ZW5lcnMoKTtcclxuICAgIHRoaXMud29yZHMuZm9yRWFjaCgod29yZCkgPT4gd29yZC53b3JkQXVkaW8/LnBhdXNlKCkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW1vdmVMaW5rc0xpc3RlbmVycygpIHtcclxuICAgIGNvbnN0IGxpbmtzID0gPE5vZGVMaXN0T2Y8SFRNTEFuY2hvckVsZW1lbnQ+PmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcclxuICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmxpbmtzSGFuZGxlcikpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFkZExpbmtzSGFuZGxlcigpIHtcclxuICAgIGNvbnN0IGhyZWYgPSBgJHtkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbH0vLyR7ZG9jdW1lbnQubG9jYXRpb24uaG9zdH1gO1xyXG4gICAgY29uc3QgbGlua3MgPSA8Tm9kZUxpc3RPZjxIVE1MQW5jaG9yRWxlbWVudD4+ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYScpO1xyXG4gICAgbGlua3MuZm9yRWFjaCgobGluaykgPT4ge1xyXG4gICAgICBpZiAobGluay5ocmVmICE9PSBgJHtocmVmfS9ib29rYCkge1xyXG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmxpbmtzSGFuZGxlcik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjaGFuZ1BhZ2VCRygpIHtcclxuICAgIGNvbnN0IGJ0bkFjdGl2ZSA9IHRoaXMubGV2ZWwxQnRucy5maWx0ZXIoKGJ0bikgPT4gYnRuLmNsYXNzTGlzdC5jb250YWlucygnYnRuLWFjdGl2ZScpKVswXTtcclxuICAgIGNvbnN0IGJ0bkNvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoYnRuQWN0aXZlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XHJcbiAgICB0aGlzLnBhZ2Uuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYnRuQ29sb3I7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8305\n")},6610:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.WordUI = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst constants_1 = __webpack_require__(5004);\r\nconst soundSVG_1 = __webpack_require__(5327);\r\nconst WordController_1 = __webpack_require__(3584);\r\nconst Storage_1 = __webpack_require__(7114);\r\nconst checkPageAllDone_1 = __webpack_require__(9103);\r\nconst checkEmptyUserBook_1 = __webpack_require__(6285);\r\nclass WordUI {\r\n    constructor(obj, TBWords) {\r\n        this.wordController = new WordController_1.WordController();\r\n        this.obj = obj;\r\n        if (obj?.id) {\r\n            this.id = obj.id;\r\n        }\r\n        else {\r\n            // eslint-disable-next-line no-underscore-dangle\r\n            this.id = obj._id;\r\n        }\r\n        this.card = (0, createNode_1.default)({ tag: 'div', classes: ['card'] });\r\n        this.img = (0, createNode_1.default)({ tag: 'div', classes: ['card-img'] });\r\n        this.playBtn = (0, createNode_1.default)({ tag: 'button', classes: ['btn', 'btn-play'] });\r\n        this.word = (0, createNode_1.default)({\r\n            tag: 'p', classes: ['word'], inner: `${this.obj.word}`,\r\n        });\r\n        this.addToUserWordsBtn = (0, createNode_1.default)({\r\n            tag: 'button', classes: ['btn-add', 'btn-secondary'], atributesAdnValues: [['style', 'display: none']], inner: '<span class=\"material-icons-outlined btn-icon\">menu_book</span>',\r\n        });\r\n        this.learnWordBtn = (0, createNode_1.default)({\r\n            tag: 'button', classes: ['btn-learn', 'btn-secondary'], atributesAdnValues: [['style', 'display: none']], inner: '<span class=\"material-icons-outlined btn-icon\">spellcheck</span>',\r\n        });\r\n        this.correct = (0, createNode_1.default)({ tag: 'span', classes: ['correct-answers'], inner: '0' });\r\n        this.incorrect = (0, createNode_1.default)({ tag: 'span', classes: ['incorrect-answers'], inner: '0' });\r\n        this.transcription = (0, createNode_1.default)({ tag: 'p', classes: ['word-transcription'], inner: `${this.obj.transcription}` });\r\n        this.translate = (0, createNode_1.default)({ tag: 'p', classes: ['word-translate'], inner: `${this.obj.wordTranslate}` });\r\n        this.transcription = (0, createNode_1.default)({ tag: 'p', classes: ['word-transcription'], inner: `${this.obj.transcription}` });\r\n        this.playWord();\r\n        this.listenHardWordBtn();\r\n        this.listenLearnBtn();\r\n        this.storage = Storage_1.storage;\r\n        this.audioPointer = 0;\r\n        this.words = TBWords;\r\n    }\r\n    drawCard() {\r\n        const cardMainInfoWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['card-main-info-wrapper'] });\r\n        const cardWordInfo = (0, createNode_1.default)({ tag: 'div', classes: ['card-word-info'] });\r\n        const userBtns = (0, createNode_1.default)({ tag: 'div', classes: ['user-btns'] });\r\n        const wordExamplesWrapper = (0, createNode_1.default)({ tag: 'div', classes: ['card-examples-wrapper'] });\r\n        const wordMeaning = (0, createNode_1.default)({ tag: 'p', classes: ['word-mean'], inner: `${this.obj.textMeaning}` });\r\n        const wordMeaningTranslate = (0, createNode_1.default)({ tag: 'p', classes: ['word-mean-translate'], inner: `${this.obj.textMeaningTranslate}` });\r\n        const wordExample = (0, createNode_1.default)({ tag: 'p', classes: ['word-ex'], inner: `${this.obj.textExample}` });\r\n        const wordExampleTranslate = (0, createNode_1.default)({ tag: 'p', classes: ['word-ex-translate'], inner: `${this.obj.textExampleTranslate}` });\r\n        this.playBtn.innerHTML = soundSVG_1.soundIcon;\r\n        this.img.style.background = `center / cover no-repeat url(${constants_1.BASE_LINK}/${this.obj.image})`;\r\n        wordExamplesWrapper.append(wordMeaning, wordMeaningTranslate, wordExample, wordExampleTranslate);\r\n        cardWordInfo.append(this.word, this.transcription, this.translate);\r\n        cardMainInfoWrapper.append(this.img, this.playBtn, cardWordInfo);\r\n        userBtns.append(this.addToUserWordsBtn, this.learnWordBtn);\r\n        if (this.obj.userWord) {\r\n            const answers = (0, createNode_1.default)({ tag: 'div', classes: ['answers'] });\r\n            answers.append(this.correct, '/', this.incorrect);\r\n            userBtns.append(this.addToUserWordsBtn, this.learnWordBtn, answers);\r\n            this.checkUserWordUpdate(this.obj.userWord.difficulty, this.obj.userWord.optional.learned);\r\n            this.correct.innerHTML = String(this.obj.userWord.optional.correctAnswers);\r\n            this.incorrect.innerHTML = String(this.obj.userWord.optional.incorrectAnswers);\r\n        }\r\n        cardMainInfoWrapper.append(userBtns);\r\n        this.card.append(cardMainInfoWrapper, wordExamplesWrapper);\r\n        return this.card;\r\n    }\r\n    listenHardWordBtn() {\r\n        this.addToUserWordsBtn.addEventListener('click', () => {\r\n            const { group } = this.storage.getData('textBook');\r\n            let difficulty;\r\n            if (this.addToUserWordsBtn.classList.contains('hard-word-btn')) {\r\n                this.addToUserWordsBtn.classList.remove('hard-word-btn');\r\n                difficulty = 'easy';\r\n                this.wordController.updateHardWord(difficulty, this.id);\r\n            }\r\n            else {\r\n                this.addToUserWordsBtn.classList.add('hard-word-btn');\r\n                difficulty = 'hard';\r\n                this.wordController.updateHardWord(difficulty, this.id);\r\n            }\r\n            if (group === 6) {\r\n                this.card.style.display = 'none';\r\n                (0, checkEmptyUserBook_1.checkEmptyUserBook)();\r\n            }\r\n            else {\r\n                (0, checkPageAllDone_1.checkPageAllDone)();\r\n            }\r\n        });\r\n    }\r\n    listenLearnBtn() {\r\n        this.learnWordBtn.addEventListener('click', () => {\r\n            const { group } = this.storage.getData('textBook');\r\n            let isLearned;\r\n            if (this.learnWordBtn.classList.contains('learn-word-btn')) {\r\n                this.learnWordBtn.classList.remove('learn-word-btn');\r\n                this.addToUserWordsBtn.disabled = false;\r\n                isLearned = false;\r\n                this.wordController.updateLearnedWord(isLearned, this.id);\r\n            }\r\n            else {\r\n                this.learnWordBtn.classList.add('learn-word-btn');\r\n                this.addToUserWordsBtn.classList.remove('hard-word-btn');\r\n                this.addToUserWordsBtn.disabled = true;\r\n                isLearned = true;\r\n                this.wordController.updateLearnedWord(isLearned, this.id);\r\n            }\r\n            if (group === 6) {\r\n                this.card.style.display = 'none';\r\n                (0, checkEmptyUserBook_1.checkEmptyUserBook)();\r\n            }\r\n            else {\r\n                (0, checkPageAllDone_1.checkPageAllDone)();\r\n            }\r\n        });\r\n    }\r\n    async checkUserWordUpdate(difficulty, learned) {\r\n        if (learned === true && !this.learnWordBtn.classList.contains('learn-word-btn')) {\r\n            this.learnWordBtn.classList.add('learn-word-btn');\r\n            this.addToUserWordsBtn.disabled = true;\r\n        }\r\n        if (difficulty === 'hard' && !this.addToUserWordsBtn.classList.contains('hard-word-btn')) {\r\n            this.addToUserWordsBtn.classList.add('hard-word-btn');\r\n            this.addToUserWordsBtn.disabled = false;\r\n            this.learnWordBtn.classList.remove('learn-word-btn');\r\n        }\r\n    }\r\n    makeSoundURL() {\r\n        const wordSoundString = this.obj.audio;\r\n        const exampleSound = this.obj.audioExample;\r\n        const meaningSound = this.obj.audioMeaning;\r\n        const arr = [];\r\n        arr.push(`${constants_1.BASE_LINK}/${wordSoundString}`, `${constants_1.BASE_LINK}/${meaningSound}`, `${constants_1.BASE_LINK}/${exampleSound}`);\r\n        return arr;\r\n    }\r\n    playNext() {\r\n        this.audioPointer += 1;\r\n        if (this.audioPointer < this.makeSoundURL().length) {\r\n            this.wordAudio = new Audio(this.makeSoundURL()[this.audioPointer]);\r\n            this.wordAudio.addEventListener('ended', this.playNext.bind(this));\r\n            this.wordAudio.play();\r\n        }\r\n    }\r\n    play() {\r\n        this.audioPointer = 0;\r\n        this.wordAudio = new Audio(this.makeSoundURL()[this.audioPointer]);\r\n        this.wordAudio.addEventListener('ended', this.playNext.bind(this));\r\n        this.wordAudio.play();\r\n    }\r\n    playWord() {\r\n        this.playBtn.addEventListener('click', () => {\r\n            this.wordAudio?.pause();\r\n            this.words.forEach((word) => word.wordAudio?.pause());\r\n            this.play();\r\n        });\r\n    }\r\n}\r\nexports.WordUI = WordUI;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDbkUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNuRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ3ZCO0lBQ0gsQ0FBQztJQUVPLElBQUk7UUFDVixJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUNuRSxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVNLFFBQVE7UUFDYixJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7WUFDMUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQztZQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQ3RELElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBdk1ELHdCQXVNQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy90ZXh0Qm9vay9Xb3JkLnRzP2VmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVXNlckFnZ3JlZ2F0ZWRXb3JkLCBXb3JkIH0gZnJvbSAnLi4vdHlwZXMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCBjcmVhdGVOb2RlIGZyb20gJy4uL3V0aWxzL2NyZWF0ZU5vZGUnO1xyXG5pbXBvcnQgeyBCQVNFX0xJTksgfSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBzb3VuZEljb24gfSBmcm9tICcuL3NvdW5kU1ZHJztcclxuaW1wb3J0IHsgV29yZENvbnRyb2xsZXIgfSBmcm9tICcuLi9Xb3JkQ29udHJvbGxlci9Xb3JkQ29udHJvbGxlcic7XHJcbmltcG9ydCB7IHN0b3JhZ2UgfSBmcm9tICcuLi9TdG9yYWdlL1N0b3JhZ2UnO1xyXG5pbXBvcnQgeyBjaGVja1BhZ2VBbGxEb25lIH0gZnJvbSAnLi4vdXRpbHMvY2hlY2tQYWdlQWxsRG9uZSc7XHJcbmltcG9ydCB7IGNoZWNrRW1wdHlVc2VyQm9vayB9IGZyb20gJy4uL3V0aWxzL2NoZWNrRW1wdHlVc2VyQm9vayc7XHJcblxyXG5leHBvcnQgY2xhc3MgV29yZFVJIHtcclxuICBpZDogc3RyaW5nO1xyXG5cclxuICBjYXJkOiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgcGxheUJ0bjogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcblxyXG4gIG9iajogV29yZCB8IFVzZXJBZ2dyZWdhdGVkV29yZDtcclxuXHJcbiAgaW1nOiBIVE1MSW1hZ2VFbGVtZW50O1xyXG5cclxuICB3b3JkOiBIVE1MUGFyYWdyYXBoRWxlbWVudDtcclxuXHJcbiAgdHJhbnNjcmlwdGlvbjogSFRNTFBhcmFncmFwaEVsZW1lbnQ7XHJcblxyXG4gIHRyYW5zbGF0ZTogSFRNTFBhcmFncmFwaEVsZW1lbnQ7XHJcblxyXG4gIGFkZFRvVXNlcldvcmRzQnRuOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuXHJcbiAgbGVhcm5Xb3JkQnRuOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuXHJcbiAgY29ycmVjdDogSFRNTFNwYW5FbGVtZW50O1xyXG5cclxuICBpbmNvcnJlY3Q6IEhUTUxTcGFuRWxlbWVudDtcclxuXHJcbiAgd29yZENvbnRyb2xsZXIgPSBuZXcgV29yZENvbnRyb2xsZXIoKTtcclxuXHJcbiAgc3RvcmFnZTogdHlwZW9mIHN0b3JhZ2U7XHJcblxyXG4gIHdvcmRBdWRpbzogSFRNTEF1ZGlvRWxlbWVudCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgYXVkaW9Qb2ludGVyOiBudW1iZXI7XHJcblxyXG4gIHdvcmRzOiBXb3JkVUlbXTtcclxuXHJcbiAgY29uc3RydWN0b3Iob2JqOiBXb3JkIHwgVXNlckFnZ3JlZ2F0ZWRXb3JkLCBUQldvcmRzOiBXb3JkVUlbXSkge1xyXG4gICAgdGhpcy5vYmogPSBvYmo7XHJcbiAgICBpZiAoKG9iaiBhcyBXb3JkKT8uaWQpIHtcclxuICAgICAgdGhpcy5pZCA9IChvYmogYXMgV29yZCkuaWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcclxuICAgICAgdGhpcy5pZCA9IChvYmogYXMgVXNlckFnZ3JlZ2F0ZWRXb3JkKS5faWQ7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNhcmQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydjYXJkJ10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICB0aGlzLmltZyA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ2NhcmQtaW1nJ10gfSkgYXMgSFRNTEltYWdlRWxlbWVudDtcclxuICAgIHRoaXMucGxheUJ0biA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdidXR0b24nLCBjbGFzc2VzOiBbJ2J0bicsICdidG4tcGxheSddIH0pIGFzIEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgdGhpcy53b3JkID0gY3JlYXRlTm9kZSh7XHJcbiAgICAgIHRhZzogJ3AnLCBjbGFzc2VzOiBbJ3dvcmQnXSwgaW5uZXI6IGAke3RoaXMub2JqLndvcmR9YCxcclxuICAgIH0pIGFzIEhUTUxQYXJhZ3JhcGhFbGVtZW50O1xyXG4gICAgdGhpcy5hZGRUb1VzZXJXb3Jkc0J0biA9IGNyZWF0ZU5vZGUoe1xyXG4gICAgICB0YWc6ICdidXR0b24nLCBjbGFzc2VzOiBbJ2J0bi1hZGQnLCAnYnRuLXNlY29uZGFyeSddLCBhdHJpYnV0ZXNBZG5WYWx1ZXM6IFtbJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmUnXV0sIGlubmVyOiAnPHNwYW4gY2xhc3M9XCJtYXRlcmlhbC1pY29ucy1vdXRsaW5lZCBidG4taWNvblwiPm1lbnVfYm9vazwvc3Bhbj4nLFxyXG4gICAgfSkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICB0aGlzLmxlYXJuV29yZEJ0biA9IGNyZWF0ZU5vZGUoe1xyXG4gICAgICB0YWc6ICdidXR0b24nLCBjbGFzc2VzOiBbJ2J0bi1sZWFybicsICdidG4tc2Vjb25kYXJ5J10sIGF0cmlidXRlc0FkblZhbHVlczogW1snc3R5bGUnLCAnZGlzcGxheTogbm9uZSddXSwgaW5uZXI6ICc8c3BhbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zLW91dGxpbmVkIGJ0bi1pY29uXCI+c3BlbGxjaGVjazwvc3Bhbj4nLFxyXG4gICAgfSkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgICB0aGlzLmNvcnJlY3QgPSBjcmVhdGVOb2RlKHsgdGFnOiAnc3BhbicsIGNsYXNzZXM6IFsnY29ycmVjdC1hbnN3ZXJzJ10sIGlubmVyOiAnMCcgfSkgYXMgSFRNTFNwYW5FbGVtZW50O1xyXG4gICAgdGhpcy5pbmNvcnJlY3QgPSBjcmVhdGVOb2RlKHsgdGFnOiAnc3BhbicsIGNsYXNzZXM6IFsnaW5jb3JyZWN0LWFuc3dlcnMnXSwgaW5uZXI6ICcwJyB9KSBhcyBIVE1MU3BhbkVsZW1lbnQ7XHJcbiAgICB0aGlzLnRyYW5zY3JpcHRpb24gPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFsnd29yZC10cmFuc2NyaXB0aW9uJ10sIGlubmVyOiBgJHt0aGlzLm9iai50cmFuc2NyaXB0aW9ufWAgfSkgYXMgSFRNTFBhcmFncmFwaEVsZW1lbnQ7XHJcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdwJywgY2xhc3NlczogWyd3b3JkLXRyYW5zbGF0ZSddLCBpbm5lcjogYCR7dGhpcy5vYmoud29yZFRyYW5zbGF0ZX1gIH0pIGFzIEhUTUxQYXJhZ3JhcGhFbGVtZW50O1xyXG4gICAgdGhpcy50cmFuc2NyaXB0aW9uID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ3dvcmQtdHJhbnNjcmlwdGlvbiddLCBpbm5lcjogYCR7dGhpcy5vYmoudHJhbnNjcmlwdGlvbn1gIH0pIGFzIEhUTUxQYXJhZ3JhcGhFbGVtZW50O1xyXG4gICAgdGhpcy5wbGF5V29yZCgpO1xyXG4gICAgdGhpcy5saXN0ZW5IYXJkV29yZEJ0bigpO1xyXG4gICAgdGhpcy5saXN0ZW5MZWFybkJ0bigpO1xyXG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcclxuICAgIHRoaXMuYXVkaW9Qb2ludGVyID0gMDtcclxuICAgIHRoaXMud29yZHMgPSBUQldvcmRzO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRyYXdDYXJkKCk6IEhUTUxEaXZFbGVtZW50IHtcclxuICAgIGNvbnN0IGNhcmRNYWluSW5mb1dyYXBwZXI6IEhUTUxEaXZFbGVtZW50ID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnY2FyZC1tYWluLWluZm8td3JhcHBlciddIH0pIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgY29uc3QgY2FyZFdvcmRJbmZvOiBIVE1MRGl2RWxlbWVudCA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ2NhcmQtd29yZC1pbmZvJ10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBjb25zdCB1c2VyQnRuczogSFRNTERpdkVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWyd1c2VyLWJ0bnMnXSB9KSBhcyBIVE1MRGl2RWxlbWVudDtcclxuICAgIGNvbnN0IHdvcmRFeGFtcGxlc1dyYXBwZXI6IEhUTUxEaXZFbGVtZW50ID0gY3JlYXRlTm9kZSh7IHRhZzogJ2RpdicsIGNsYXNzZXM6IFsnY2FyZC1leGFtcGxlcy13cmFwcGVyJ10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBjb25zdCB3b3JkTWVhbmluZzogSFRNTFBhcmFncmFwaEVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFsnd29yZC1tZWFuJ10sIGlubmVyOiBgJHt0aGlzLm9iai50ZXh0TWVhbmluZ31gIH0pIGFzIEhUTUxQYXJhZ3JhcGhFbGVtZW50O1xyXG4gICAgY29uc3Qgd29yZE1lYW5pbmdUcmFuc2xhdGU6IEhUTUxQYXJhZ3JhcGhFbGVtZW50ID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ3dvcmQtbWVhbi10cmFuc2xhdGUnXSwgaW5uZXI6IGAke3RoaXMub2JqLnRleHRNZWFuaW5nVHJhbnNsYXRlfWAgfSkgYXMgSFRNTFBhcmFncmFwaEVsZW1lbnQ7XHJcbiAgICBjb25zdCB3b3JkRXhhbXBsZTogSFRNTFBhcmFncmFwaEVsZW1lbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFsnd29yZC1leCddLCBpbm5lcjogYCR7dGhpcy5vYmoudGV4dEV4YW1wbGV9YCB9KSBhcyBIVE1MUGFyYWdyYXBoRWxlbWVudDtcclxuICAgIGNvbnN0IHdvcmRFeGFtcGxlVHJhbnNsYXRlOiBIVE1MUGFyYWdyYXBoRWxlbWVudCA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdwJywgY2xhc3NlczogWyd3b3JkLWV4LXRyYW5zbGF0ZSddLCBpbm5lcjogYCR7dGhpcy5vYmoudGV4dEV4YW1wbGVUcmFuc2xhdGV9YCB9KSBhcyBIVE1MUGFyYWdyYXBoRWxlbWVudDtcclxuICAgIHRoaXMucGxheUJ0bi5pbm5lckhUTUwgPSBzb3VuZEljb247XHJcbiAgICB0aGlzLmltZy5zdHlsZS5iYWNrZ3JvdW5kID0gYGNlbnRlciAvIGNvdmVyIG5vLXJlcGVhdCB1cmwoJHtCQVNFX0xJTkt9LyR7dGhpcy5vYmouaW1hZ2V9KWA7XHJcbiAgICB3b3JkRXhhbXBsZXNXcmFwcGVyLmFwcGVuZChcclxuICAgICAgd29yZE1lYW5pbmcsXHJcbiAgICAgIHdvcmRNZWFuaW5nVHJhbnNsYXRlLFxyXG4gICAgICB3b3JkRXhhbXBsZSxcclxuICAgICAgd29yZEV4YW1wbGVUcmFuc2xhdGUsXHJcbiAgICApO1xyXG4gICAgY2FyZFdvcmRJbmZvLmFwcGVuZCh0aGlzLndvcmQsIHRoaXMudHJhbnNjcmlwdGlvbiwgdGhpcy50cmFuc2xhdGUpO1xyXG4gICAgY2FyZE1haW5JbmZvV3JhcHBlci5hcHBlbmQodGhpcy5pbWcsIHRoaXMucGxheUJ0biwgY2FyZFdvcmRJbmZvKTtcclxuICAgIHVzZXJCdG5zLmFwcGVuZCh0aGlzLmFkZFRvVXNlcldvcmRzQnRuLCB0aGlzLmxlYXJuV29yZEJ0bik7XHJcbiAgICBpZiAoKHRoaXMub2JqIGFzIFVzZXJBZ2dyZWdhdGVkV29yZCkudXNlcldvcmQpIHtcclxuICAgICAgY29uc3QgYW5zd2VycyA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ2Fuc3dlcnMnXSB9KTtcclxuICAgICAgYW5zd2Vycy5hcHBlbmQodGhpcy5jb3JyZWN0LCAnLycsIHRoaXMuaW5jb3JyZWN0KTtcclxuICAgICAgdXNlckJ0bnMuYXBwZW5kKHRoaXMuYWRkVG9Vc2VyV29yZHNCdG4sIHRoaXMubGVhcm5Xb3JkQnRuLCBhbnN3ZXJzKTtcclxuICAgICAgdGhpcy5jaGVja1VzZXJXb3JkVXBkYXRlKFxyXG4gICAgICAgICh0aGlzLm9iaiBhcyBVc2VyQWdncmVnYXRlZFdvcmQpLnVzZXJXb3JkLmRpZmZpY3VsdHksXHJcbiAgICAgICAgKHRoaXMub2JqIGFzIFVzZXJBZ2dyZWdhdGVkV29yZCkudXNlcldvcmQub3B0aW9uYWwubGVhcm5lZCxcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5jb3JyZWN0LmlubmVySFRNTCA9IFN0cmluZyhcclxuICAgICAgICAodGhpcy5vYmogYXMgVXNlckFnZ3JlZ2F0ZWRXb3JkKS51c2VyV29yZC5vcHRpb25hbC5jb3JyZWN0QW5zd2VycyxcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5pbmNvcnJlY3QuaW5uZXJIVE1MID0gU3RyaW5nKFxyXG4gICAgICAgICh0aGlzLm9iaiBhcyBVc2VyQWdncmVnYXRlZFdvcmQpLnVzZXJXb3JkLm9wdGlvbmFsLmluY29ycmVjdEFuc3dlcnMsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBjYXJkTWFpbkluZm9XcmFwcGVyLmFwcGVuZCh1c2VyQnRucyk7XHJcbiAgICB0aGlzLmNhcmQuYXBwZW5kKGNhcmRNYWluSW5mb1dyYXBwZXIsIHdvcmRFeGFtcGxlc1dyYXBwZXIpO1xyXG4gICAgcmV0dXJuIHRoaXMuY2FyZDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBsaXN0ZW5IYXJkV29yZEJ0bigpIHtcclxuICAgIHRoaXMuYWRkVG9Vc2VyV29yZHNCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgZ3JvdXAgfSA9IHRoaXMuc3RvcmFnZS5nZXREYXRhKCd0ZXh0Qm9vaycpO1xyXG4gICAgICBsZXQgZGlmZmljdWx0eTogJ2Vhc3knIHwgJ2hhcmQnO1xyXG4gICAgICBpZiAodGhpcy5hZGRUb1VzZXJXb3Jkc0J0bi5jbGFzc0xpc3QuY29udGFpbnMoJ2hhcmQtd29yZC1idG4nKSkge1xyXG4gICAgICAgIHRoaXMuYWRkVG9Vc2VyV29yZHNCdG4uY2xhc3NMaXN0LnJlbW92ZSgnaGFyZC13b3JkLWJ0bicpO1xyXG4gICAgICAgIGRpZmZpY3VsdHkgPSAnZWFzeSc7XHJcbiAgICAgICAgdGhpcy53b3JkQ29udHJvbGxlci51cGRhdGVIYXJkV29yZChkaWZmaWN1bHR5LCB0aGlzLmlkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFkZFRvVXNlcldvcmRzQnRuLmNsYXNzTGlzdC5hZGQoJ2hhcmQtd29yZC1idG4nKTtcclxuICAgICAgICBkaWZmaWN1bHR5ID0gJ2hhcmQnO1xyXG4gICAgICAgIHRoaXMud29yZENvbnRyb2xsZXIudXBkYXRlSGFyZFdvcmQoZGlmZmljdWx0eSwgdGhpcy5pZCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGdyb3VwID09PSA2KSB7XHJcbiAgICAgICAgdGhpcy5jYXJkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgY2hlY2tFbXB0eVVzZXJCb29rKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hlY2tQYWdlQWxsRG9uZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBsaXN0ZW5MZWFybkJ0bigpIHtcclxuICAgIHRoaXMubGVhcm5Xb3JkQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IGdyb3VwIH0gPSB0aGlzLnN0b3JhZ2UuZ2V0RGF0YSgndGV4dEJvb2snKTtcclxuICAgICAgbGV0IGlzTGVhcm5lZDogYm9vbGVhbjtcclxuICAgICAgaWYgKHRoaXMubGVhcm5Xb3JkQnRuLmNsYXNzTGlzdC5jb250YWlucygnbGVhcm4td29yZC1idG4nKSkge1xyXG4gICAgICAgIHRoaXMubGVhcm5Xb3JkQnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2xlYXJuLXdvcmQtYnRuJyk7XHJcbiAgICAgICAgdGhpcy5hZGRUb1VzZXJXb3Jkc0J0bi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlzTGVhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMud29yZENvbnRyb2xsZXIudXBkYXRlTGVhcm5lZFdvcmQoaXNMZWFybmVkLCB0aGlzLmlkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxlYXJuV29yZEJ0bi5jbGFzc0xpc3QuYWRkKCdsZWFybi13b3JkLWJ0bicpO1xyXG4gICAgICAgIHRoaXMuYWRkVG9Vc2VyV29yZHNCdG4uY2xhc3NMaXN0LnJlbW92ZSgnaGFyZC13b3JkLWJ0bicpO1xyXG4gICAgICAgIHRoaXMuYWRkVG9Vc2VyV29yZHNCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGlzTGVhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy53b3JkQ29udHJvbGxlci51cGRhdGVMZWFybmVkV29yZChpc0xlYXJuZWQsIHRoaXMuaWQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChncm91cCA9PT0gNikge1xyXG4gICAgICAgIHRoaXMuY2FyZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGNoZWNrRW1wdHlVc2VyQm9vaygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoZWNrUGFnZUFsbERvbmUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNoZWNrVXNlcldvcmRVcGRhdGUoZGlmZmljdWx0eTogJ2Vhc3knIHwgJ2hhcmQnLCBsZWFybmVkOiBib29sZWFuKSB7XHJcbiAgICBpZiAobGVhcm5lZCA9PT0gdHJ1ZSAmJiAhdGhpcy5sZWFybldvcmRCdG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdsZWFybi13b3JkLWJ0bicpKSB7XHJcbiAgICAgIHRoaXMubGVhcm5Xb3JkQnRuLmNsYXNzTGlzdC5hZGQoJ2xlYXJuLXdvcmQtYnRuJyk7XHJcbiAgICAgIHRoaXMuYWRkVG9Vc2VyV29yZHNCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpZmZpY3VsdHkgPT09ICdoYXJkJyAmJiAhdGhpcy5hZGRUb1VzZXJXb3Jkc0J0bi5jbGFzc0xpc3QuY29udGFpbnMoJ2hhcmQtd29yZC1idG4nKSkge1xyXG4gICAgICB0aGlzLmFkZFRvVXNlcldvcmRzQnRuLmNsYXNzTGlzdC5hZGQoJ2hhcmQtd29yZC1idG4nKTtcclxuICAgICAgdGhpcy5hZGRUb1VzZXJXb3Jkc0J0bi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmxlYXJuV29yZEJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdsZWFybi13b3JkLWJ0bicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBtYWtlU291bmRVUkwoKTogc3RyaW5nW10ge1xyXG4gICAgY29uc3Qgd29yZFNvdW5kU3RyaW5nOiBzdHJpbmcgPSB0aGlzLm9iai5hdWRpbyBhcyBzdHJpbmc7XHJcbiAgICBjb25zdCBleGFtcGxlU291bmQgPSB0aGlzLm9iai5hdWRpb0V4YW1wbGUgYXMgc3RyaW5nO1xyXG4gICAgY29uc3QgbWVhbmluZ1NvdW5kID0gdGhpcy5vYmouYXVkaW9NZWFuaW5nIGFzIHN0cmluZztcclxuICAgIGNvbnN0IGFycjogc3RyaW5nW10gPSBbXTtcclxuICAgIGFyci5wdXNoKGAke0JBU0VfTElOS30vJHt3b3JkU291bmRTdHJpbmd9YCwgYCR7QkFTRV9MSU5LfS8ke21lYW5pbmdTb3VuZH1gLCBgJHtCQVNFX0xJTkt9LyR7ZXhhbXBsZVNvdW5kfWApO1xyXG4gICAgcmV0dXJuIGFycjtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGxheU5leHQoKSB7XHJcbiAgICB0aGlzLmF1ZGlvUG9pbnRlciArPSAxO1xyXG4gICAgaWYgKHRoaXMuYXVkaW9Qb2ludGVyIDwgdGhpcy5tYWtlU291bmRVUkwoKS5sZW5ndGgpIHtcclxuICAgICAgdGhpcy53b3JkQXVkaW8gPSBuZXcgQXVkaW8odGhpcy5tYWtlU291bmRVUkwoKVt0aGlzLmF1ZGlvUG9pbnRlcl0pO1xyXG4gICAgICB0aGlzLndvcmRBdWRpby5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMucGxheU5leHQuYmluZCh0aGlzKSk7XHJcbiAgICAgIHRoaXMud29yZEF1ZGlvLnBsYXkoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGxheSgpIHtcclxuICAgIHRoaXMuYXVkaW9Qb2ludGVyID0gMDtcclxuICAgIHRoaXMud29yZEF1ZGlvID0gbmV3IEF1ZGlvKHRoaXMubWFrZVNvdW5kVVJMKClbdGhpcy5hdWRpb1BvaW50ZXJdKTtcclxuICAgIHRoaXMud29yZEF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5wbGF5TmV4dC5iaW5kKHRoaXMpKTtcclxuICAgIHRoaXMud29yZEF1ZGlvLnBsYXkoKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBwbGF5V29yZCgpIHtcclxuICAgIHRoaXMucGxheUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgdGhpcy53b3JkQXVkaW8/LnBhdXNlKCk7XHJcbiAgICAgIHRoaXMud29yZHMuZm9yRWFjaCgod29yZCkgPT4gd29yZC53b3JkQXVkaW8/LnBhdXNlKCkpO1xyXG4gICAgICB0aGlzLnBsYXkoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6610\n")},5327:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.soundIcon = void 0;\r\nexports.soundIcon = `<svg xmlns="http://www.w3.org/2000/svg" version="1.0"  width="50" height="50" viewBox="0 0 75 75">\r\n<path d="M39.389,13.769 L22.235,28.606 L6,28.606 L6,47.699 L21.989,47.699 L39.389,62.75 L39.389,13.769z"\r\nstyle="stroke-width:5;stroke-linejoin:round;"\r\n/>\r\n<path d="M48,27.6a19.5,19.5 0 0 1 0,21.4M55.1,20.5a30,30 0 0 1 0,35.6M61.6,14a38.8,38.8 0 0 1 0,48.6" style="fill:none;stroke-width:5;stroke-linecap:round"/>\r\n</svg>`;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyNy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYSxpQkFBUyxHQUFHOzs7OztPQUtsQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL3RleHRCb29rL3NvdW5kU1ZHLnRzPzUyNTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHNvdW5kSWNvbiA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2ZXJzaW9uPVwiMS4wXCIgIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHZpZXdCb3g9XCIwIDAgNzUgNzVcIj5cclxuPHBhdGggZD1cIk0zOS4zODksMTMuNzY5IEwyMi4yMzUsMjguNjA2IEw2LDI4LjYwNiBMNiw0Ny42OTkgTDIxLjk4OSw0Ny42OTkgTDM5LjM4OSw2Mi43NSBMMzkuMzg5LDEzLjc2OXpcIlxyXG5zdHlsZT1cInN0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtcIlxyXG4vPlxyXG48cGF0aCBkPVwiTTQ4LDI3LjZhMTkuNSwxOS41IDAgMCAxIDAsMjEuNE01NS4xLDIwLjVhMzAsMzAgMCAwIDEgMCwzNS42TTYxLjYsMTRhMzguOCwzOC44IDAgMCAxIDAsNDguNlwiIHN0eWxlPVwiZmlsbDpub25lO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1saW5lY2FwOnJvdW5kXCIvPlxyXG48L3N2Zz5gO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5327\n')},8875:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.GAME = exports.HTTPMethod = exports.ContentType = exports.Endpoint = void 0;\r\nvar Endpoint;\r\n(function (Endpoint) {\r\n    Endpoint["words"] = "/words";\r\n    Endpoint["users"] = "/users";\r\n    Endpoint["signin"] = "/signin";\r\n    Endpoint["tokens"] = "/tokens";\r\n    Endpoint["aggregatedWords"] = "/aggregatedWords";\r\n    Endpoint["statistics"] = "/statistics";\r\n})(Endpoint = exports.Endpoint || (exports.Endpoint = {}));\r\nvar ContentType;\r\n(function (ContentType) {\r\n    ContentType["json"] = "application/json";\r\n})(ContentType = exports.ContentType || (exports.ContentType = {}));\r\nvar HTTPMethod;\r\n(function (HTTPMethod) {\r\n    HTTPMethod["GET"] = "GET";\r\n    HTTPMethod["POST"] = "POST";\r\n    HTTPMethod["PUT"] = "PUT";\r\n    HTTPMethod["DELETE"] = "DELETE";\r\n})(HTTPMethod = exports.HTTPMethod || (exports.HTTPMethod = {}));\r\nvar GAME;\r\n(function (GAME) {\r\n    GAME["AUDIOCALL"] = "audiocall";\r\n    GAME["SPRINT"] = "sprint";\r\n})(GAME = exports.GAME || (exports.GAME = {}));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg3NS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxJQUFZLFFBT1g7QUFQRCxXQUFZLFFBQVE7SUFDbEIsNEJBQWdCO0lBQ2hCLDRCQUFnQjtJQUNoQiw4QkFBa0I7SUFDbEIsOEJBQWtCO0lBQ2xCLGdEQUFvQztJQUNwQyxzQ0FBMEI7QUFDNUIsQ0FBQyxFQVBXLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBT25CO0FBQ0QsSUFBWSxXQUVYO0FBRkQsV0FBWSxXQUFXO0lBQ3JCLHdDQUF5QjtBQUMzQixDQUFDLEVBRlcsV0FBVyxHQUFYLG1CQUFXLEtBQVgsbUJBQVcsUUFFdEI7QUFDRCxJQUFZLFVBS1g7QUFMRCxXQUFZLFVBQVU7SUFDcEIseUJBQVc7SUFDWCwyQkFBYTtJQUNiLHlCQUFXO0lBQ1gsK0JBQWlCO0FBQ25CLENBQUMsRUFMVyxVQUFVLEdBQVYsa0JBQVUsS0FBVixrQkFBVSxRQUtyQjtBQUVELElBQVksSUFHWDtBQUhELFdBQVksSUFBSTtJQUNkLCtCQUF1QjtJQUN2Qix5QkFBaUI7QUFDbkIsQ0FBQyxFQUhXLElBQUksR0FBSixZQUFJLEtBQUosWUFBSSxRQUdmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL3R5cGVzL2VudW1zLnRzP2NhOWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGVudW0gRW5kcG9pbnQge1xyXG4gIHdvcmRzID0gJy93b3JkcycsXHJcbiAgdXNlcnMgPSAnL3VzZXJzJyxcclxuICBzaWduaW4gPSAnL3NpZ25pbicsXHJcbiAgdG9rZW5zID0gJy90b2tlbnMnLFxyXG4gIGFnZ3JlZ2F0ZWRXb3JkcyA9ICcvYWdncmVnYXRlZFdvcmRzJyxcclxuICBzdGF0aXN0aWNzID0gJy9zdGF0aXN0aWNzJyxcclxufVxyXG5leHBvcnQgZW51bSBDb250ZW50VHlwZSB7XHJcbiAganNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJyxcclxufVxyXG5leHBvcnQgZW51bSBIVFRQTWV0aG9kIHtcclxuICBHRVQgPSAnR0VUJyxcclxuICBQT1NUID0gJ1BPU1QnLFxyXG4gIFBVVCA9ICdQVVQnLFxyXG4gIERFTEVURSA9ICdERUxFVEUnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBHQU1FIHtcclxuICBBVURJT0NBTEwgPSAnYXVkaW9jYWxsJyxcclxuICBTUFJJTlQgPSAnc3ByaW50JyxcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8875\n')},3761:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.UserUI = void 0;\r\nconst StatisticUI_1 = __webpack_require__(5021);\r\nconst constants_1 = __webpack_require__(5004);\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nconst Charts_1 = __webpack_require__(1857);\r\nclass UserUI {\r\n    constructor() {\r\n        this.headerEnterBtn = (0, createNode_1.default)({\r\n            tag: 'a', classes: ['enter-cabinet-link'], atributesAdnValues: [['href', '/user'], ['data-navigo', 'true']], inner: '<span class=\"material-icons-outlined user-icon\">account_circle</span>',\r\n        });\r\n        this.userPage = (0, createNode_1.default)({ tag: 'div', classes: ['user-page'] });\r\n        this.name = (0, createNode_1.default)({ tag: 'h2', classes: ['user-name'] });\r\n        this.email = (0, createNode_1.default)({ tag: 'p', classes: ['user-name'] });\r\n        this.exitBtn = (0, createNode_1.default)({ tag: 'button', classes: ['btn', 'exit-cabinet-btn'], inner: 'Выйти из аккаунта' });\r\n        this.statisticPage = (0, createNode_1.default)({ tag: 'div', classes: ['statistic-block'] });\r\n        this.statUI = new StatisticUI_1.StatisticUI();\r\n        this.charts = new Charts_1.Charts();\r\n    }\r\n    authorise(res) {\r\n        this.name.innerHTML = res.name;\r\n        constants_1.REGISTER_BTN.style.display = 'none';\r\n        constants_1.LOGIN_BTN.style.display = 'none';\r\n        constants_1.USER_AUTH_WRAPPER.append(this.headerEnterBtn);\r\n        this.headerEnterBtn.style.display = 'flex';\r\n        return constants_1.USER_AUTH_WRAPPER;\r\n    }\r\n    unAuthorize(hanlder) {\r\n        this.exitBtn.addEventListener('click', () => {\r\n            constants_1.REGISTER_BTN.style.display = 'block';\r\n            constants_1.LOGIN_BTN.style.display = 'block';\r\n            this.headerEnterBtn.style.display = 'none';\r\n            hanlder();\r\n        });\r\n    }\r\n    async renderUserPage() {\r\n        const container = document.querySelector('.main');\r\n        container.innerHTML = '';\r\n        this.userPage.innerHTML = '';\r\n        console.log(this.userPage.innerHTML);\r\n        const userSection = (0, createNode_1.default)({ tag: 'section', classes: ['user-section'] });\r\n        const chartsSection = (0, createNode_1.default)({ tag: 'section', classes: ['charts-section'] });\r\n        const dailyStatSection = (0, createNode_1.default)({ tag: 'section', classes: ['daily-stat-section'] });\r\n        const userBlock = (0, createNode_1.default)({ tag: 'aside', classes: ['aside', 'user-sidebar'] });\r\n        userBlock.append(this.name, this.email, this.exitBtn);\r\n        const todayStatistic = await this.renderTodayStatisticBlock();\r\n        const dailyStatistic = await this.renderStatisticBlock();\r\n        const charts = this.renderChartsBlock();\r\n        userSection.append(userBlock, todayStatistic);\r\n        chartsSection.append(charts);\r\n        dailyStatSection.append(dailyStatistic);\r\n        this.userPage.append(userSection, chartsSection, dailyStatSection);\r\n        container.append(this.userPage);\r\n        const stat = await this.charts.getStatisticForCarts();\r\n        if (stat) {\r\n            this.charts.createChart('myChart-1', stat.dates, stat.newWords, 'Количество новых', 'bar');\r\n            this.charts.createChart('myChart-2', stat.dates, stat.learnedWords, 'Количество выученных', 'line');\r\n        }\r\n        return container;\r\n    }\r\n    async renderStatisticBlock() {\r\n        this.statisticPage.innerHTML = '';\r\n        const statisticData = await this.statUI.drawDailyStat();\r\n        this.statisticPage.append(statisticData);\r\n        return this.statisticPage;\r\n    }\r\n    async renderTodayStatisticBlock() {\r\n        const statisticData = await this.statUI.drawTodayStat();\r\n        return statisticData;\r\n    }\r\n    renderChartsBlock() {\r\n        const charts = (0, createNode_1.default)({ tag: 'section', classes: ['charts'] });\r\n        this.renderChartCanvas(charts, 'chart', 'myChart-1');\r\n        this.renderChartCanvas(charts, 'chart', 'myChart-2');\r\n        return charts;\r\n    }\r\n    renderChartCanvas(container, className, id) {\r\n        const chart = (0, createNode_1.default)({\r\n            tag: 'canvas',\r\n            classes: [className],\r\n            atributesAdnValues: [['id', id]],\r\n        });\r\n        container.append(chart);\r\n    }\r\n}\r\nexports.UserUI = UserUI;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDckQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVPLGlCQUFpQixDQUFDLFNBQXNCLEVBQUUsU0FBaUIsRUFBRSxFQUFVO1FBQzdFLE1BQU0sS0FBSyxHQUFHLHdCQUFVLEVBQUM7WUFDdkIsR0FBRyxFQUFFLFFBQVE7WUFDYixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQUM7WUFDcEIsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNqQyxDQUFDLENBQUM7UUFDSCxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFCLENBQUM7Q0FDRjtBQWxIRCx3QkFrSEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvdXNlci9Vc2VyVUkudHM/ZGVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdXRob3JpemF0aW9uRGF0YSB9IGZyb20gJy4uL3R5cGVzL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBTdGF0aXN0aWNVSSB9IGZyb20gJy4uL1VzZXJTdGF0aXN0aWMvU3RhdGlzdGljVUknO1xyXG5pbXBvcnQgeyBSRUdJU1RFUl9CVE4sIExPR0lOX0JUTiwgVVNFUl9BVVRIX1dSQVBQRVIgfSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xyXG5pbXBvcnQgY3JlYXRlTm9kZSBmcm9tICcuLi91dGlscy9jcmVhdGVOb2RlJztcclxuaW1wb3J0IHsgQ2hhcnRzIH0gZnJvbSAnLi4vQ2hhcnRzL0NoYXJ0cyc7XHJcblxyXG5leHBvcnQgY2xhc3MgVXNlclVJIHtcclxuICB1c2VyUGFnZTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIGhlYWRlckVudGVyQnRuOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuXHJcbiAgbmFtZTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gIGVtYWlsOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgZXhpdEJ0bjogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcblxyXG4gIHN0YXRpc3RpY1BhZ2U6IEhUTUxFbGVtZW50O1xyXG5cclxuICBzdGF0VUk6IFN0YXRpc3RpY1VJO1xyXG5cclxuICBjaGFydHM6IENoYXJ0cztcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmhlYWRlckVudGVyQnRuID0gY3JlYXRlTm9kZSh7XHJcbiAgICAgIHRhZzogJ2EnLCBjbGFzc2VzOiBbJ2VudGVyLWNhYmluZXQtbGluayddLCBhdHJpYnV0ZXNBZG5WYWx1ZXM6IFtbJ2hyZWYnLCAnL3VzZXInXSwgWydkYXRhLW5hdmlnbycsICd0cnVlJ11dLCBpbm5lcjogJzxzcGFuIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnMtb3V0bGluZWQgdXNlci1pY29uXCI+YWNjb3VudF9jaXJjbGU8L3NwYW4+JyxcclxuICAgIH0pIGFzIEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgdGhpcy51c2VyUGFnZSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ3VzZXItcGFnZSddIH0pO1xyXG4gICAgdGhpcy5uYW1lID0gY3JlYXRlTm9kZSh7IHRhZzogJ2gyJywgY2xhc3NlczogWyd1c2VyLW5hbWUnXSB9KTtcclxuICAgIHRoaXMuZW1haWwgPSBjcmVhdGVOb2RlKHsgdGFnOiAncCcsIGNsYXNzZXM6IFsndXNlci1uYW1lJ10gfSk7XHJcbiAgICB0aGlzLmV4aXRCdG4gPSBjcmVhdGVOb2RlKHsgdGFnOiAnYnV0dG9uJywgY2xhc3NlczogWydidG4nLCAnZXhpdC1jYWJpbmV0LWJ0biddLCBpbm5lcjogJ9CS0YvQudGC0Lgg0LjQtyDQsNC60LrQsNGD0L3RgtCwJyB9KSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgIHRoaXMuc3RhdGlzdGljUGFnZSA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdkaXYnLCBjbGFzc2VzOiBbJ3N0YXRpc3RpYy1ibG9jayddIH0pO1xyXG4gICAgdGhpcy5zdGF0VUkgPSBuZXcgU3RhdGlzdGljVUkoKTtcclxuICAgIHRoaXMuY2hhcnRzID0gbmV3IENoYXJ0cygpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGF1dGhvcmlzZShyZXM6IEF1dGhvcml6YXRpb25EYXRhKSB7XHJcbiAgICB0aGlzLm5hbWUuaW5uZXJIVE1MID0gcmVzLm5hbWU7XHJcbiAgICBSRUdJU1RFUl9CVE4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIExPR0lOX0JUTi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgVVNFUl9BVVRIX1dSQVBQRVIuYXBwZW5kKHRoaXMuaGVhZGVyRW50ZXJCdG4pO1xyXG4gICAgdGhpcy5oZWFkZXJFbnRlckJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgcmV0dXJuIFVTRVJfQVVUSF9XUkFQUEVSO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHVuQXV0aG9yaXplKGhhbmxkZXI6ICgpID0+IHZvaWQpIHtcclxuICAgIHRoaXMuZXhpdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgUkVHSVNURVJfQlROLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICBMT0dJTl9CVE4uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgIHRoaXMuaGVhZGVyRW50ZXJCdG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgaGFubGRlcigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgcmVuZGVyVXNlclBhZ2UoKSB7XHJcbiAgICBjb25zdCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4nKSBhcyBIVE1MRWxlbWVudDtcclxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgIHRoaXMudXNlclBhZ2UuaW5uZXJIVE1MID0gJyc7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVzZXJQYWdlLmlubmVySFRNTCk7XHJcbiAgICBjb25zdCB1c2VyU2VjdGlvbiA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdzZWN0aW9uJywgY2xhc3NlczogWyd1c2VyLXNlY3Rpb24nXSB9KTtcclxuICAgIGNvbnN0IGNoYXJ0c1NlY3Rpb24gPSBjcmVhdGVOb2RlKHsgdGFnOiAnc2VjdGlvbicsIGNsYXNzZXM6IFsnY2hhcnRzLXNlY3Rpb24nXSB9KTtcclxuICAgIGNvbnN0IGRhaWx5U3RhdFNlY3Rpb24gPSBjcmVhdGVOb2RlKHsgdGFnOiAnc2VjdGlvbicsIGNsYXNzZXM6IFsnZGFpbHktc3RhdC1zZWN0aW9uJ10gfSk7XHJcbiAgICBjb25zdCB1c2VyQmxvY2sgPSBjcmVhdGVOb2RlKHsgdGFnOiAnYXNpZGUnLCBjbGFzc2VzOiBbJ2FzaWRlJywgJ3VzZXItc2lkZWJhciddIH0pO1xyXG4gICAgdXNlckJsb2NrLmFwcGVuZCh0aGlzLm5hbWUsIHRoaXMuZW1haWwsIHRoaXMuZXhpdEJ0bik7XHJcbiAgICBjb25zdCB0b2RheVN0YXRpc3RpYyA9IGF3YWl0IHRoaXMucmVuZGVyVG9kYXlTdGF0aXN0aWNCbG9jaygpO1xyXG4gICAgY29uc3QgZGFpbHlTdGF0aXN0aWMgPSBhd2FpdCB0aGlzLnJlbmRlclN0YXRpc3RpY0Jsb2NrKCk7XHJcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLnJlbmRlckNoYXJ0c0Jsb2NrKCk7XHJcbiAgICB1c2VyU2VjdGlvbi5hcHBlbmQodXNlckJsb2NrLCB0b2RheVN0YXRpc3RpYyk7XHJcbiAgICBjaGFydHNTZWN0aW9uLmFwcGVuZChjaGFydHMpO1xyXG4gICAgZGFpbHlTdGF0U2VjdGlvbi5hcHBlbmQoZGFpbHlTdGF0aXN0aWMpO1xyXG4gICAgdGhpcy51c2VyUGFnZS5hcHBlbmQodXNlclNlY3Rpb24sIGNoYXJ0c1NlY3Rpb24sIGRhaWx5U3RhdFNlY3Rpb24pO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZCh0aGlzLnVzZXJQYWdlKTtcclxuICAgIGNvbnN0IHN0YXQgPSBhd2FpdCB0aGlzLmNoYXJ0cy5nZXRTdGF0aXN0aWNGb3JDYXJ0cygpO1xyXG4gICAgaWYgKHN0YXQpIHtcclxuICAgICAgdGhpcy5jaGFydHMuY3JlYXRlQ2hhcnQoXHJcbiAgICAgICAgJ215Q2hhcnQtMScsXHJcbiAgICAgICAgc3RhdC5kYXRlcyxcclxuICAgICAgICBzdGF0Lm5ld1dvcmRzLFxyXG4gICAgICAgICfQmtC+0LvQuNGH0LXRgdGC0LLQviDQvdC+0LLRi9GFJyxcclxuICAgICAgICAnYmFyJyxcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5jaGFydHMuY3JlYXRlQ2hhcnQoXHJcbiAgICAgICAgJ215Q2hhcnQtMicsXHJcbiAgICAgICAgc3RhdC5kYXRlcyxcclxuICAgICAgICBzdGF0LmxlYXJuZWRXb3JkcyxcclxuICAgICAgICAn0JrQvtC70LjRh9C10YHRgtCy0L4g0LLRi9GD0YfQtdC90L3Ri9GFJyxcclxuICAgICAgICAnbGluZScsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyByZW5kZXJTdGF0aXN0aWNCbG9jaygpIHtcclxuICAgIHRoaXMuc3RhdGlzdGljUGFnZS5pbm5lckhUTUwgPSAnJztcclxuICAgIGNvbnN0IHN0YXRpc3RpY0RhdGEgPSBhd2FpdCB0aGlzLnN0YXRVSS5kcmF3RGFpbHlTdGF0KCk7XHJcbiAgICB0aGlzLnN0YXRpc3RpY1BhZ2UuYXBwZW5kKHN0YXRpc3RpY0RhdGEpO1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGlzdGljUGFnZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyByZW5kZXJUb2RheVN0YXRpc3RpY0Jsb2NrKCkge1xyXG4gICAgY29uc3Qgc3RhdGlzdGljRGF0YSA9IGF3YWl0IHRoaXMuc3RhdFVJLmRyYXdUb2RheVN0YXQoKTtcclxuICAgIHJldHVybiBzdGF0aXN0aWNEYXRhO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZW5kZXJDaGFydHNCbG9jaygpIHtcclxuICAgIGNvbnN0IGNoYXJ0cyA9IGNyZWF0ZU5vZGUoeyB0YWc6ICdzZWN0aW9uJywgY2xhc3NlczogWydjaGFydHMnXSB9KTtcclxuICAgIHRoaXMucmVuZGVyQ2hhcnRDYW52YXMoY2hhcnRzLCAnY2hhcnQnLCAnbXlDaGFydC0xJyk7XHJcbiAgICB0aGlzLnJlbmRlckNoYXJ0Q2FudmFzKGNoYXJ0cywgJ2NoYXJ0JywgJ215Q2hhcnQtMicpO1xyXG4gICAgcmV0dXJuIGNoYXJ0cztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVuZGVyQ2hhcnRDYW52YXMoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcsIGlkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGNoYXJ0ID0gY3JlYXRlTm9kZSh7XHJcbiAgICAgIHRhZzogJ2NhbnZhcycsXHJcbiAgICAgIGNsYXNzZXM6IFtjbGFzc05hbWVdLFxyXG4gICAgICBhdHJpYnV0ZXNBZG5WYWx1ZXM6IFtbJ2lkJywgaWRdXSxcclxuICAgIH0pO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZChjaGFydCk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3761\n")},7618:(__unused_webpack_module,exports)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BurgerMenu = void 0;\r\nclass BurgerMenu {\r\n    constructor() {\r\n        this.burgerMenu = document.querySelector('.burger-icon');\r\n        this.menu = document.querySelector('.header-menu');\r\n        this.menuLinks = document.querySelectorAll('.menu-item');\r\n    }\r\n    initBurgerMenu() {\r\n        // this.bindEvents.bind(this);\r\n        this.bindEvents();\r\n        console.log(this.menu);\r\n    }\r\n    openMenu() {\r\n        console.log('open');\r\n        this.burgerMenu.classList.add('clicked');\r\n        this.menu.classList.add('opened');\r\n        // overlay.classList.add('shadowed');\r\n        document.body.classList.add('hidden-overflow');\r\n    }\r\n    closeMenu() {\r\n        console.log('close');\r\n        this.burgerMenu.classList.remove('clicked');\r\n        this.menu.classList.remove('opened');\r\n        // overlay.classList.remove('shadowed');\r\n        document.body.classList.remove('hidden-overflow');\r\n    }\r\n    bindEvents() {\r\n        console.log('bind');\r\n        this.burgerMenu.addEventListener('click', () => {\r\n            if (this.burgerMenu.classList.contains('clicked')) {\r\n                this.closeMenu();\r\n            }\r\n            else {\r\n                this.openMenu();\r\n            }\r\n        });\r\n        this.menu.addEventListener('click', (e) => {\r\n            const target = e.target;\r\n            console.log(target);\r\n            if (target.classList.contains('menu-item') || target.closest('.menu-item')) {\r\n                // console.log('e.target');\r\n                this.closeMenu();\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.BurgerMenu = BurgerMenu;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYxOC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxNQUFhLFVBQVU7SUFBdkI7UUFDRSxlQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQWdCLENBQUM7UUFFbkUsU0FBSSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFnQixDQUFDO1FBRTdELGNBQVMsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQWMsWUFBWSxDQUFDLENBQUM7SUEwQ25FLENBQUM7SUF4Q0MsY0FBYztRQUNaLDhCQUE4QjtRQUM5QixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEMscUNBQXFDO1FBQ3JDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRCxTQUFTO1FBQ1AsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyQixJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3JDLHdDQUF3QztRQUN4QyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQsVUFBVTtRQUNSLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDcEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFO1lBQzdDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNqRCxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7YUFDbEI7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQ2pCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLENBQVEsRUFBRSxFQUFFO1lBQy9DLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFxQixDQUFDO1lBQ3ZDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEIsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUMxRSwyQkFBMkI7Z0JBQzNCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQzthQUNsQjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBL0NELGdDQStDQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy91dGlscy9CdXJnZXJNZW51LnRzPzkyMzUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEJ1cmdlck1lbnUge1xyXG4gIGJ1cmdlck1lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYnVyZ2VyLWljb24nKSBhcyBIVE1MRWxlbWVudDtcclxuXHJcbiAgbWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXItbWVudScpIGFzIEhUTUxFbGVtZW50O1xyXG5cclxuICBtZW51TGlua3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxFbGVtZW50PignLm1lbnUtaXRlbScpO1xyXG5cclxuICBpbml0QnVyZ2VyTWVudSgpIHtcclxuICAgIC8vIHRoaXMuYmluZEV2ZW50cy5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLm1lbnUpO1xyXG4gIH1cclxuXHJcbiAgb3Blbk1lbnUoKSB7XHJcbiAgICBjb25zb2xlLmxvZygnb3BlbicpO1xyXG4gICAgdGhpcy5idXJnZXJNZW51LmNsYXNzTGlzdC5hZGQoJ2NsaWNrZWQnKTtcclxuICAgIHRoaXMubWVudS5jbGFzc0xpc3QuYWRkKCdvcGVuZWQnKTtcclxuICAgIC8vIG92ZXJsYXkuY2xhc3NMaXN0LmFkZCgnc2hhZG93ZWQnKTtcclxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaGlkZGVuLW92ZXJmbG93Jyk7XHJcbiAgfVxyXG5cclxuICBjbG9zZU1lbnUoKSB7XHJcbiAgICBjb25zb2xlLmxvZygnY2xvc2UnKTtcclxuICAgIHRoaXMuYnVyZ2VyTWVudS5jbGFzc0xpc3QucmVtb3ZlKCdjbGlja2VkJyk7XHJcbiAgICB0aGlzLm1lbnUuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbmVkJyk7XHJcbiAgICAvLyBvdmVybGF5LmNsYXNzTGlzdC5yZW1vdmUoJ3NoYWRvd2VkJyk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbi1vdmVyZmxvdycpO1xyXG4gIH1cclxuXHJcbiAgYmluZEV2ZW50cygpIHtcclxuICAgIGNvbnNvbGUubG9nKCdiaW5kJyk7XHJcbiAgICB0aGlzLmJ1cmdlck1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmJ1cmdlck1lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKCdjbGlja2VkJykpIHtcclxuICAgICAgICB0aGlzLmNsb3NlTWVudSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMub3Blbk1lbnUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm1lbnUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZTogRXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZW51LWl0ZW0nKSB8fCB0YXJnZXQuY2xvc2VzdCgnLm1lbnUtaXRlbScpKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2UudGFyZ2V0Jyk7XHJcbiAgICAgICAgdGhpcy5jbG9zZU1lbnUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7618\n")},9843:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Modal = void 0;\r\nconst createNode_1 = __importDefault(__webpack_require__(9856));\r\nclass Modal {\r\n    constructor() {\r\n        this.closeBtn = (0, createNode_1.default)({ tag: 'button', classes: ['btn', 'modal-close-btn'] });\r\n        this.modalContent = (0, createNode_1.default)({ tag: 'div', classes: ['modal-wrapper'] });\r\n        this.overLay = (0, createNode_1.default)({ tag: 'div', classes: ['modal-overlay'] });\r\n    }\r\n    renderModal(htmlNode) {\r\n        this.modalContent.innerHTML = '';\r\n        this.closeBtn.innerHTML = '<span class=\"material-icons-outlined material-modal-close-icon\">close</span>';\r\n        this.modalContent.append(htmlNode);\r\n        this.modalContent.prepend(this.closeBtn);\r\n        this.overLay.append(this.modalContent);\r\n        document.body.append(this.overLay);\r\n        document.body.classList.add('hidden-overflow');\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        this.closeBtn.addEventListener('click', this.closeModal.bind(this));\r\n        this.overLay.addEventListener('click', this.closeModal.bind(this));\r\n    }\r\n    closeModal(e) {\r\n        const classes = e.target.classList;\r\n        if (classes.contains('modal-overlay') || classes.contains('modal-close-btn') || classes.contains('material-modal-close-icon')) {\r\n            this.overLay.remove();\r\n            document.body.classList.remove('hidden-overflow');\r\n        }\r\n    }\r\n    exitModal() {\r\n        this.overLay.remove();\r\n        document.body.classList.remove('hidden-overflow');\r\n    }\r\n    showMessage(data) {\r\n        console.log('Success');\r\n        this.modalContent.innerHTML = '';\r\n        const p = (0, createNode_1.default)({ tag: 'p', classes: ['modal-message'], inner: `${data}` });\r\n        this.modalContent.append(p);\r\n        return this.modalContent;\r\n    }\r\n    showLoginMessage() {\r\n        const errMessage = (0, createNode_1.default)({ tag: 'p', classes: ['modal-err-message'], inner: 'Такого пользователя не существует, проверьте данные' });\r\n        this.modalContent.prepend(errMessage);\r\n        return this.modalContent;\r\n    }\r\n}\r\nexports.Modal = Modal;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0lBRUQsZ0JBQWdCO1FBQ2QsTUFBTSxVQUFVLEdBQUcsd0JBQVUsRUFBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsbUJBQW1CLENBQUMsRUFBRSxLQUFLLEVBQUUscURBQXFELEVBQUUsQ0FBQyxDQUFDO1FBQzFJLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0NBQ0Y7QUF2REQsc0JBdURDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL3V0aWxzL01vZGFsLnRzPzc3OTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZU5vZGUgZnJvbSAnLi9jcmVhdGVOb2RlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBNb2RhbCB7XHJcbiAgY2xvc2VCdG46IEhUTUxCdXR0b25FbGVtZW50O1xyXG5cclxuICBtb2RhbENvbnRlbnQ6IEhUTUxEaXZFbGVtZW50O1xyXG5cclxuICBvdmVyTGF5OiBIVE1MRGl2RWxlbWVudDtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNsb3NlQnRuID0gY3JlYXRlTm9kZSh7IHRhZzogJ2J1dHRvbicsIGNsYXNzZXM6IFsnYnRuJywgJ21vZGFsLWNsb3NlLWJ0biddIH0pIGFzIEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgdGhpcy5tb2RhbENvbnRlbnQgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydtb2RhbC13cmFwcGVyJ10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICB0aGlzLm92ZXJMYXkgPSBjcmVhdGVOb2RlKHsgdGFnOiAnZGl2JywgY2xhc3NlczogWydtb2RhbC1vdmVybGF5J10gfSkgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICByZW5kZXJNb2RhbChodG1sTm9kZTogSFRNTEVsZW1lbnQpIHtcclxuICAgIHRoaXMubW9kYWxDb250ZW50LmlubmVySFRNTCA9ICcnO1xyXG4gICAgdGhpcy5jbG9zZUJ0bi5pbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJtYXRlcmlhbC1pY29ucy1vdXRsaW5lZCBtYXRlcmlhbC1tb2RhbC1jbG9zZS1pY29uXCI+Y2xvc2U8L3NwYW4+JztcclxuICAgIHRoaXMubW9kYWxDb250ZW50LmFwcGVuZChodG1sTm9kZSk7XHJcbiAgICB0aGlzLm1vZGFsQ29udGVudC5wcmVwZW5kKHRoaXMuY2xvc2VCdG4pO1xyXG4gICAgdGhpcy5vdmVyTGF5LmFwcGVuZCh0aGlzLm1vZGFsQ29udGVudCk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLm92ZXJMYXkpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdoaWRkZW4tb3ZlcmZsb3cnKTtcclxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gIH1cclxuXHJcbiAgYmluZEV2ZW50cygpIHtcclxuICAgIHRoaXMuY2xvc2VCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlTW9kYWwuYmluZCh0aGlzKSk7XHJcbiAgICB0aGlzLm92ZXJMYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlTW9kYWwuYmluZCh0aGlzKSk7XHJcbiAgfVxyXG5cclxuICBjbG9zZU1vZGFsKGU6IEV2ZW50KSB7XHJcbiAgICBjb25zdCBjbGFzc2VzID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5jbGFzc0xpc3Q7XHJcbiAgICBpZiAoY2xhc3Nlcy5jb250YWlucygnbW9kYWwtb3ZlcmxheScpIHx8IGNsYXNzZXMuY29udGFpbnMoJ21vZGFsLWNsb3NlLWJ0bicpIHx8IGNsYXNzZXMuY29udGFpbnMoJ21hdGVyaWFsLW1vZGFsLWNsb3NlLWljb24nKSkge1xyXG4gICAgICB0aGlzLm92ZXJMYXkucmVtb3ZlKCk7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuLW92ZXJmbG93Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleGl0TW9kYWwoKSB7XHJcbiAgICB0aGlzLm92ZXJMYXkucmVtb3ZlKCk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbi1vdmVyZmxvdycpO1xyXG4gIH1cclxuXHJcbiAgc2hvd01lc3NhZ2UoZGF0YTogc3RyaW5nKSB7XHJcbiAgICBjb25zb2xlLmxvZygnU3VjY2VzcycpO1xyXG4gICAgdGhpcy5tb2RhbENvbnRlbnQuaW5uZXJIVE1MID0gJyc7XHJcbiAgICBjb25zdCBwID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ21vZGFsLW1lc3NhZ2UnXSwgaW5uZXI6IGAke2RhdGF9YCB9KTtcclxuICAgIHRoaXMubW9kYWxDb250ZW50LmFwcGVuZChwKTtcclxuICAgIHJldHVybiB0aGlzLm1vZGFsQ29udGVudDtcclxuICB9XHJcblxyXG4gIHNob3dMb2dpbk1lc3NhZ2UoKSB7XHJcbiAgICBjb25zdCBlcnJNZXNzYWdlID0gY3JlYXRlTm9kZSh7IHRhZzogJ3AnLCBjbGFzc2VzOiBbJ21vZGFsLWVyci1tZXNzYWdlJ10sIGlubmVyOiAn0KLQsNC60L7Qs9C+INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDQvdC1INGB0YPRidC10YHRgtCy0YPQtdGCLCDQv9GA0L7QstC10YDRjNGC0LUg0LTQsNC90L3Ri9C1JyB9KTtcclxuICAgIHRoaXMubW9kYWxDb250ZW50LnByZXBlbmQoZXJyTWVzc2FnZSk7XHJcbiAgICByZXR1cm4gdGhpcy5tb2RhbENvbnRlbnQ7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9843\n")},6285:(__unused_webpack_module,exports)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.checkEmptyUserBook = void 0;\r\nfunction checkEmptyUserBook() {\r\n    const cards = [...document.querySelectorAll('.card')];\r\n    const audioCallBtn = document.getElementById('audiocall-btn');\r\n    const sprintBtn = document.getElementById('sprint-btn');\r\n    const isEmptyPage = cards.every((card) => card.style.display === 'none');\r\n    if (isEmptyPage) {\r\n        audioCallBtn.classList.add('btn__disabled');\r\n        sprintBtn.classList.add('btn__disabled');\r\n        const cardsWrapepr = document.querySelector('.cards-wrapper');\r\n        cardsWrapepr.innerHTML = 'В вашем учебнике нет Сложных слов';\r\n    }\r\n}\r\nexports.checkEmptyUserBook = checkEmptyUserBook;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4NS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxTQUFnQixrQkFBa0I7SUFDaEMsTUFBTSxLQUFLLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBYyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ25FLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZSxDQUFnQixDQUFDO0lBQzdFLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFnQixDQUFDO0lBQ3ZFLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxLQUFLLE1BQU0sQ0FBQyxDQUFDO0lBQ3pFLElBQUksV0FBVyxFQUFFO1FBQ2YsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDNUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBZ0IsQ0FBQztRQUM3RSxZQUFZLENBQUMsU0FBUyxHQUFHLG1DQUFtQyxDQUFDO0tBQzlEO0FBQ0gsQ0FBQztBQVhELGdEQVdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL3V0aWxzL2NoZWNrRW1wdHlVc2VyQm9vay50cz9kYmY0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBjaGVja0VtcHR5VXNlckJvb2soKSB7XHJcbiAgY29uc3QgY2FyZHMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbDxIVE1MRWxlbWVudD4oJy5jYXJkJyldO1xyXG4gIGNvbnN0IGF1ZGlvQ2FsbEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdWRpb2NhbGwtYnRuJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgY29uc3Qgc3ByaW50QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwcmludC1idG4nKSBhcyBIVE1MRWxlbWVudDtcclxuICBjb25zdCBpc0VtcHR5UGFnZSA9IGNhcmRzLmV2ZXJ5KChjYXJkKSA9PiBjYXJkLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyk7XHJcbiAgaWYgKGlzRW1wdHlQYWdlKSB7XHJcbiAgICBhdWRpb0NhbGxCdG4uY2xhc3NMaXN0LmFkZCgnYnRuX19kaXNhYmxlZCcpO1xyXG4gICAgc3ByaW50QnRuLmNsYXNzTGlzdC5hZGQoJ2J0bl9fZGlzYWJsZWQnKTtcclxuICAgIGNvbnN0IGNhcmRzV3JhcGVwciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJkcy13cmFwcGVyJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICBjYXJkc1dyYXBlcHIuaW5uZXJIVE1MID0gJ9CSINCy0LDRiNC10Lwg0YPRh9C10LHQvdC40LrQtSDQvdC10YIg0KHQu9C+0LbQvdGL0YUg0YHQu9C+0LInO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6285\n")},9103:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.checkPageAllDone = void 0;\r\nconst constants_1 = __webpack_require__(5004);\r\nfunction checkPageAllDone() {\r\n    // const cards: HTMLElement[] = [...document.querySelectorAll('.card')] as HTMLElement[];\r\n    const pageWrapper = document.querySelector('.text-book-page');\r\n    const pageNumber = document.querySelector('.page-input');\r\n    const audioCallBtn = document.querySelector('[href=\"/book/audiocall\"]');\r\n    const sprintBtn = document.querySelector('[href=\"/book/sprint\"]');\r\n    const hardBtns = document.querySelectorAll('.hard-word-btn');\r\n    const learnBtns = document.querySelectorAll('.learn-word-btn');\r\n    const conditionEvery = ((learnBtns.length + hardBtns.length) === 20\r\n        && learnBtns.length > 0);\r\n    if ((learnBtns.length === constants_1.WORDS_PER_PAGE) || conditionEvery) {\r\n        pageWrapper.style.border = '3px solid #332a7c';\r\n        pageNumber.style.border = '3px solid #332a7c';\r\n        if (audioCallBtn)\r\n            audioCallBtn.classList.add('btn__disabled');\r\n        if (sprintBtn)\r\n            sprintBtn.classList.add('btn__disabled');\r\n    }\r\n    else {\r\n        pageWrapper.style.border = '3px solid #ffffff';\r\n        if (pageNumber) {\r\n            pageNumber.style.border = 'none';\r\n        }\r\n        if (audioCallBtn)\r\n            audioCallBtn.classList.remove('btn__disabled');\r\n        if (sprintBtn)\r\n            sprintBtn.classList.remove('btn__disabled');\r\n    }\r\n}\r\nexports.checkPageAllDone = checkPageAllDone;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEwMy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSw4Q0FBNkM7QUFFN0MsU0FBZ0IsZ0JBQWdCO0lBQzlCLHlGQUF5RjtJQUN6RixNQUFNLFdBQVcsR0FBZ0IsUUFBUSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBZ0IsQ0FBQztJQUMxRixNQUFNLFVBQVUsR0FBcUIsUUFBUSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQXFCLENBQUM7SUFDL0YsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0lBQ3hFLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQUMsQ0FBQztJQUNsRSxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQWEsQ0FBQztJQUN6RSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQWEsQ0FBQztJQUMzRSxNQUFNLGNBQWMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRTtXQUMvRCxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzFCLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxLQUFLLDBCQUFjLENBQUMsSUFBSSxjQUFjLEVBQUU7UUFDM0QsV0FBVyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsbUJBQW1CLENBQUM7UUFDL0MsVUFBVSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsbUJBQW1CLENBQUM7UUFDOUMsSUFBSSxZQUFZO1lBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDOUQsSUFBSSxTQUFTO1lBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7S0FDekQ7U0FBTTtRQUNMLFdBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLG1CQUFtQixDQUFDO1FBQy9DLElBQUksVUFBVSxFQUFFO1lBQ2QsVUFBVSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1NBQ2xDO1FBQ0QsSUFBSSxZQUFZO1lBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDakUsSUFBSSxTQUFTO1lBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUM7S0FDNUQ7QUFDSCxDQUFDO0FBdkJELDRDQXVCQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy91dGlscy9jaGVja1BhZ2VBbGxEb25lLnRzPzZlYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV09SRFNfUEVSX1BBR0UgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQYWdlQWxsRG9uZSgpIHtcclxuICAvLyBjb25zdCBjYXJkczogSFRNTEVsZW1lbnRbXSA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FyZCcpXSBhcyBIVE1MRWxlbWVudFtdO1xyXG4gIGNvbnN0IHBhZ2VXcmFwcGVyOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0LWJvb2stcGFnZScpIGFzIEhUTUxFbGVtZW50O1xyXG4gIGNvbnN0IHBhZ2VOdW1iZXI6IEhUTUxJbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1pbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgY29uc3QgYXVkaW9DYWxsQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2hyZWY9XCIvYm9vay9hdWRpb2NhbGxcIl0nKTtcclxuICBjb25zdCBzcHJpbnRCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbaHJlZj1cIi9ib29rL3NwcmludFwiXScpO1xyXG4gIGNvbnN0IGhhcmRCdG5zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmhhcmQtd29yZC1idG4nKSBhcyBOb2RlTGlzdDtcclxuICBjb25zdCBsZWFybkJ0bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubGVhcm4td29yZC1idG4nKSBhcyBOb2RlTGlzdDtcclxuICBjb25zdCBjb25kaXRpb25FdmVyeSA9ICgobGVhcm5CdG5zLmxlbmd0aCArIGhhcmRCdG5zLmxlbmd0aCkgPT09IDIwXHJcbiAgICYmIGxlYXJuQnRucy5sZW5ndGggPiAwKTtcclxuICBpZiAoKGxlYXJuQnRucy5sZW5ndGggPT09IFdPUkRTX1BFUl9QQUdFKSB8fCBjb25kaXRpb25FdmVyeSkge1xyXG4gICAgcGFnZVdyYXBwZXIuc3R5bGUuYm9yZGVyID0gJzNweCBzb2xpZCAjMzMyYTdjJztcclxuICAgIHBhZ2VOdW1iZXIuc3R5bGUuYm9yZGVyID0gJzNweCBzb2xpZCAjMzMyYTdjJztcclxuICAgIGlmIChhdWRpb0NhbGxCdG4pIGF1ZGlvQ2FsbEJ0bi5jbGFzc0xpc3QuYWRkKCdidG5fX2Rpc2FibGVkJyk7XHJcbiAgICBpZiAoc3ByaW50QnRuKSBzcHJpbnRCdG4uY2xhc3NMaXN0LmFkZCgnYnRuX19kaXNhYmxlZCcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYWdlV3JhcHBlci5zdHlsZS5ib3JkZXIgPSAnM3B4IHNvbGlkICNmZmZmZmYnO1xyXG4gICAgaWYgKHBhZ2VOdW1iZXIpIHtcclxuICAgICAgcGFnZU51bWJlci5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XHJcbiAgICB9XHJcbiAgICBpZiAoYXVkaW9DYWxsQnRuKSBhdWRpb0NhbGxCdG4uY2xhc3NMaXN0LnJlbW92ZSgnYnRuX19kaXNhYmxlZCcpO1xyXG4gICAgaWYgKHNwcmludEJ0bikgc3ByaW50QnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2J0bl9fZGlzYWJsZWQnKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9103\n")},5004:(__unused_webpack_module,exports)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EMAIL_REGEX = exports.GAMES_DATA_TEXT = exports.WORDS_DATA_TEXT = exports.USER_AUTH_WRAPPER = exports.USER_ICON = exports.LOGIN_BTN = exports.REGISTER_BTN = exports.WORDS_PER_PAGE = exports.MAX_PAGE_NUMBER = exports.LEVELS_OF_TEXTBOOK = exports.REFRESHTOKEN_LIFETIME_IN_HOURS = exports.TOKEN_LIFETIME_IN_HOURS = exports.APP_LINK = exports.BASE_LINK = void 0;\r\nexports.BASE_LINK = 'https://rss-learnwords.herokuapp.com';\r\nexports.APP_LINK = 'http://localhost:8000';\r\nexports.TOKEN_LIFETIME_IN_HOURS = 3;\r\nexports.REFRESHTOKEN_LIFETIME_IN_HOURS = 4;\r\nexports.LEVELS_OF_TEXTBOOK = 7;\r\nexports.MAX_PAGE_NUMBER = 30;\r\nexports.WORDS_PER_PAGE = 20;\r\n// Header Auth buttons and div\r\nexports.REGISTER_BTN = document.getElementById('register-btn');\r\nexports.LOGIN_BTN = document.getElementById('login-btn');\r\nexports.USER_ICON = document.getElementById('user-icon');\r\nexports.USER_AUTH_WRAPPER = document.querySelector('.auth');\r\n// Statistic data\r\nexports.WORDS_DATA_TEXT = ['новые слова', 'изученные слова', 'правильные ответы'];\r\nexports.GAMES_DATA_TEXT = ['новые слова', 'правильные ответы', 'самая длинная серия'];\r\n// Forms validation\r\nexports.EMAIL_REGEX = /^[A-Za-z0-9_!#$%&'*+\\\\/=?`{|}~^.-]+@[A-Za-z0-9.-]+$/gm;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAwNC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYSxpQkFBUyxHQUFXLHNDQUFzQyxDQUFDO0FBQzNELGdCQUFRLEdBQVcsdUJBQXVCLENBQUM7QUFDM0MsK0JBQXVCLEdBQVcsQ0FBQyxDQUFDO0FBQ3BDLHNDQUE4QixHQUFXLENBQUMsQ0FBQztBQUMzQywwQkFBa0IsR0FBVyxDQUFDLENBQUM7QUFDL0IsdUJBQWUsR0FBVyxFQUFFLENBQUM7QUFDN0Isc0JBQWMsR0FBVyxFQUFFLENBQUM7QUFFekMsOEJBQThCO0FBQ2pCLG9CQUFZLEdBQXNCLFFBQVEsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFzQixDQUFDO0FBQy9GLGlCQUFTLEdBQXNCLFFBQVEsQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFzQixDQUFDO0FBQ3pGLGlCQUFTLEdBQWdCLFFBQVEsQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFnQixDQUFDO0FBQzdFLHlCQUFpQixHQUFnQixRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBZ0IsQ0FBQztBQUU3RixpQkFBaUI7QUFDSix1QkFBZSxHQUFhLENBQUMsYUFBYSxFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixDQUFDLENBQUM7QUFDcEYsdUJBQWUsR0FBYSxDQUFDLGFBQWEsRUFBRSxtQkFBbUIsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0FBRXJHLG1CQUFtQjtBQUNOLG1CQUFXLEdBQVcsdURBQXVELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvY29uc3RhbnRzLnRzP2MzODkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEJBU0VfTElOSzogc3RyaW5nID0gJ2h0dHBzOi8vcnNzLWxlYXJud29yZHMuaGVyb2t1YXBwLmNvbSc7XHJcbmV4cG9ydCBjb25zdCBBUFBfTElOSzogc3RyaW5nID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCc7XHJcbmV4cG9ydCBjb25zdCBUT0tFTl9MSUZFVElNRV9JTl9IT1VSUzogbnVtYmVyID0gMztcclxuZXhwb3J0IGNvbnN0IFJFRlJFU0hUT0tFTl9MSUZFVElNRV9JTl9IT1VSUzogbnVtYmVyID0gNDtcclxuZXhwb3J0IGNvbnN0IExFVkVMU19PRl9URVhUQk9PSzogbnVtYmVyID0gNztcclxuZXhwb3J0IGNvbnN0IE1BWF9QQUdFX05VTUJFUjogbnVtYmVyID0gMzA7XHJcbmV4cG9ydCBjb25zdCBXT1JEU19QRVJfUEFHRTogbnVtYmVyID0gMjA7XHJcblxyXG4vLyBIZWFkZXIgQXV0aCBidXR0b25zIGFuZCBkaXZcclxuZXhwb3J0IGNvbnN0IFJFR0lTVEVSX0JUTjogSFRNTEJ1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVnaXN0ZXItYnRuJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbmV4cG9ydCBjb25zdCBMT0dJTl9CVE46IEhUTUxCdXR0b25FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ2luLWJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xyXG5leHBvcnQgY29uc3QgVVNFUl9JQ09OOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VyLWljb24nKSBhcyBIVE1MRWxlbWVudDtcclxuZXhwb3J0IGNvbnN0IFVTRVJfQVVUSF9XUkFQUEVSOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hdXRoJykgYXMgSFRNTEVsZW1lbnQ7XHJcblxyXG4vLyBTdGF0aXN0aWMgZGF0YVxyXG5leHBvcnQgY29uc3QgV09SRFNfREFUQV9URVhUOiBzdHJpbmdbXSA9IFsn0L3QvtCy0YvQtSDRgdC70L7QstCwJywgJ9C40LfRg9GH0LXQvdC90YvQtSDRgdC70L7QstCwJywgJ9C/0YDQsNCy0LjQu9GM0L3Ri9C1INC+0YLQstC10YLRiyddO1xyXG5leHBvcnQgY29uc3QgR0FNRVNfREFUQV9URVhUOiBzdHJpbmdbXSA9IFsn0L3QvtCy0YvQtSDRgdC70L7QstCwJywgJ9C/0YDQsNCy0LjQu9GM0L3Ri9C1INC+0YLQstC10YLRiycsICfRgdCw0LzQsNGPINC00LvQuNC90L3QsNGPINGB0LXRgNC40Y8nXTtcclxuXHJcbi8vIEZvcm1zIHZhbGlkYXRpb25cclxuZXhwb3J0IGNvbnN0IEVNQUlMX1JFR0VYOiBSZWdFeHAgPSAvXltBLVphLXowLTlfISMkJSYnKitcXFxcLz0/YHt8fX5eLi1dK0BbQS1aYS16MC05Li1dKyQvZ207XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5004\n")},1682:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.convertAggregatedWordToWord = void 0;\r\nconst convertAggregatedWordToWord = (aggrWord) => ({\r\n    id: aggrWord._id,\r\n    group: aggrWord.group,\r\n    page: aggrWord.page,\r\n    word: aggrWord.word,\r\n    image: aggrWord.image,\r\n    audio: aggrWord.audio,\r\n    audioMeaning: aggrWord.audioMeaning,\r\n    audioExample: aggrWord.audioExample,\r\n    textMeaning: aggrWord.textMeaning,\r\n    textExample: aggrWord.textExample,\r\n    transcription: aggrWord.transcription,\r\n    wordTranslate: aggrWord.wordTranslate,\r\n    textMeaningTranslate: aggrWord.textMeaningTranslate,\r\n    textExampleTranslate: aggrWord.textExampleTranslate,\r\n});\r\nexports.convertAggregatedWordToWord = convertAggregatedWordToWord;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7QUFHTyxNQUFNLDJCQUEyQixHQUFHLENBQUMsUUFBNEIsRUFBUSxFQUFFLENBQUMsQ0FBQztJQUNsRixFQUFFLEVBQUUsUUFBUSxDQUFDLEdBQUc7SUFDaEIsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLO0lBQ3JCLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSTtJQUNuQixJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUk7SUFDbkIsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLO0lBQ3JCLEtBQUssRUFBRSxRQUFRLENBQUMsS0FBSztJQUNyQixZQUFZLEVBQUUsUUFBUSxDQUFDLFlBQVk7SUFDbkMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxZQUFZO0lBQ25DLFdBQVcsRUFBRSxRQUFRLENBQUMsV0FBVztJQUNqQyxXQUFXLEVBQUUsUUFBUSxDQUFDLFdBQVc7SUFDakMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxhQUFhO0lBQ3JDLGFBQWEsRUFBRSxRQUFRLENBQUMsYUFBYTtJQUNyQyxvQkFBb0IsRUFBRSxRQUFRLENBQUMsb0JBQW9CO0lBQ25ELG9CQUFvQixFQUFFLFFBQVEsQ0FBQyxvQkFBb0I7Q0FDcEQsQ0FBQyxDQUFDO0FBZlUsbUNBQTJCLCtCQWVyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy91dGlscy9jb252ZXJ0QWdncmVnYXRlZFdvcmRUb1dvcmQudHM/NWE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xyXG5pbXBvcnQgeyBVc2VyQWdncmVnYXRlZFdvcmQsIFdvcmQgfSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcclxuXHJcbmV4cG9ydCBjb25zdCBjb252ZXJ0QWdncmVnYXRlZFdvcmRUb1dvcmQgPSAoYWdncldvcmQ6IFVzZXJBZ2dyZWdhdGVkV29yZCk6IFdvcmQgPT4gKHtcclxuICBpZDogYWdncldvcmQuX2lkLFxyXG4gIGdyb3VwOiBhZ2dyV29yZC5ncm91cCxcclxuICBwYWdlOiBhZ2dyV29yZC5wYWdlLFxyXG4gIHdvcmQ6IGFnZ3JXb3JkLndvcmQsXHJcbiAgaW1hZ2U6IGFnZ3JXb3JkLmltYWdlLFxyXG4gIGF1ZGlvOiBhZ2dyV29yZC5hdWRpbyxcclxuICBhdWRpb01lYW5pbmc6IGFnZ3JXb3JkLmF1ZGlvTWVhbmluZyxcclxuICBhdWRpb0V4YW1wbGU6IGFnZ3JXb3JkLmF1ZGlvRXhhbXBsZSxcclxuICB0ZXh0TWVhbmluZzogYWdncldvcmQudGV4dE1lYW5pbmcsXHJcbiAgdGV4dEV4YW1wbGU6IGFnZ3JXb3JkLnRleHRFeGFtcGxlLFxyXG4gIHRyYW5zY3JpcHRpb246IGFnZ3JXb3JkLnRyYW5zY3JpcHRpb24sXHJcbiAgd29yZFRyYW5zbGF0ZTogYWdncldvcmQud29yZFRyYW5zbGF0ZSxcclxuICB0ZXh0TWVhbmluZ1RyYW5zbGF0ZTogYWdncldvcmQudGV4dE1lYW5pbmdUcmFuc2xhdGUsXHJcbiAgdGV4dEV4YW1wbGVUcmFuc2xhdGU6IGFnZ3JXb3JkLnRleHRFeGFtcGxlVHJhbnNsYXRlLFxyXG59KTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1682\n')},9856:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports["default"] = (obj) => {\r\n    const node = document.createElement(obj.tag);\r\n    if (obj.classes) {\r\n        node.classList.add(...obj.classes);\r\n    }\r\n    if (obj.atributesAdnValues) {\r\n        obj.atributesAdnValues\r\n            .forEach((atributeAndValue) => node.setAttribute(atributeAndValue[0], atributeAndValue[1]));\r\n    }\r\n    if (obj.inner) {\r\n        node.innerHTML = obj.inner;\r\n    }\r\n    return node;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg1Ni5qcyIsIm1hcHBpbmdzIjoiOztBQUFBLHFCQUFlLENBQXdDLEdBS3RELEVBQWUsRUFBRTtJQUNoQixNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUU3QyxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUU7UUFDZixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNwQztJQUNELElBQUksR0FBRyxDQUFDLGtCQUFrQixFQUFFO1FBQzFCLEdBQUcsQ0FBQyxrQkFBa0I7YUFDbkIsT0FBTyxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQy9GO0lBQ0QsSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDO0tBQzVCO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvY3JlYXRlTm9kZS50cz9iZWUwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IDxLIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwPihvYmo6IHtcclxuICB0YWc6IEs7XHJcbiAgY2xhc3Nlcz86IHN0cmluZ1tdO1xyXG4gIGF0cmlidXRlc0FkblZhbHVlcz86IFtzdHJpbmcsIHN0cmluZ11bXTtcclxuICBpbm5lcj86IHN0cmluZztcclxufSk6IEhUTUxFbGVtZW50ID0+IHtcclxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvYmoudGFnKTtcclxuXHJcbiAgaWYgKG9iai5jbGFzc2VzKSB7XHJcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoLi4ub2JqLmNsYXNzZXMpO1xyXG4gIH1cclxuICBpZiAob2JqLmF0cmlidXRlc0FkblZhbHVlcykge1xyXG4gICAgb2JqLmF0cmlidXRlc0FkblZhbHVlc1xyXG4gICAgICAuZm9yRWFjaCgoYXRyaWJ1dGVBbmRWYWx1ZSkgPT4gbm9kZS5zZXRBdHRyaWJ1dGUoYXRyaWJ1dGVBbmRWYWx1ZVswXSwgYXRyaWJ1dGVBbmRWYWx1ZVsxXSkpO1xyXG4gIH1cclxuICBpZiAob2JqLmlubmVyKSB7XHJcbiAgICBub2RlLmlubmVySFRNTCA9IG9iai5pbm5lcjtcclxuICB9XHJcbiAgcmV0dXJuIG5vZGU7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9856\n')},8346:(__unused_webpack_module,exports)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.findCorrectAnswPercent = void 0;\r\nfunction findCorrectAnswPercent(corr, incorr) {\r\n    if (corr || incorr) {\r\n        const answers = Math.round((corr / (corr + incorr)) * 100);\r\n        return `${answers}%`;\r\n    }\r\n    return '0';\r\n}\r\nexports.findCorrectAnswPercent = findCorrectAnswPercent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM0Ni5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxTQUFnQixzQkFBc0IsQ0FBQyxJQUFZLEVBQUUsTUFBYztJQUNqRSxJQUFJLElBQUksSUFBSSxNQUFNLEVBQUU7UUFDbEIsTUFBTSxPQUFPLEdBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ25FLE9BQU8sR0FBRyxPQUFPLEdBQUcsQ0FBQztLQUN0QjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQU5ELHdEQU1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL3V0aWxzL2ZpbmRDb3JyZWN0QW5zd2Vyc1BlcmNlbnQudHM/YWFmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZmluZENvcnJlY3RBbnN3UGVyY2VudChjb3JyOiBudW1iZXIsIGluY29ycjogbnVtYmVyKTogc3RyaW5nIHtcclxuICBpZiAoY29yciB8fCBpbmNvcnIpIHtcclxuICAgIGNvbnN0IGFuc3dlcnM6IG51bWJlciA9IE1hdGgucm91bmQoKGNvcnIgLyAoY29yciArIGluY29ycikpICogMTAwKTtcclxuICAgIHJldHVybiBgJHthbnN3ZXJzfSVgO1xyXG4gIH1cclxuICByZXR1cm4gJzAnO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8346\n")},9593:(__unused_webpack_module,exports)=>{"use strict";eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.makeFirslLetterUpperCase = exports.getRandomIntInclusive = exports.createHTMLElement = exports.makeUrl = exports.generateQueryString = void 0;\r\nconst generateQueryString = (queryParam) => `?${Object.keys(queryParam)\r\n    .map((key) => `${key}=${queryParam[key]}`)\r\n    .join('&')}`;\r\nexports.generateQueryString = generateQueryString;\r\nconst makeUrl = (base, endpoint, queryParam) => {\r\n    const paramString = queryParam ? (0, exports.generateQueryString)(queryParam) : '';\r\n    return new URL(`${endpoint}${paramString}`, base);\r\n};\r\nexports.makeUrl = makeUrl;\r\nfunction createHTMLElement(tag, classes, atributesAdnValues, content) {\r\n    const node = document.createElement(tag);\r\n    if (classes) {\r\n        node.classList.add(...classes);\r\n    }\r\n    if (atributesAdnValues) {\r\n        atributesAdnValues.forEach((atributeAndValue) => {\r\n            node.setAttribute(atributeAndValue[0], atributeAndValue[1]);\r\n        });\r\n    }\r\n    if (content) {\r\n        node.innerHTML = content;\r\n    }\r\n    return node;\r\n}\r\nexports.createHTMLElement = createHTMLElement;\r\nfunction getRandomIntInclusive(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\nexports.getRandomIntInclusive = getRandomIntInclusive;\r\nfunction makeFirslLetterUpperCase(string) {\r\n    const firstLetter = string[0].toUpperCase();\r\n    const rest = string.slice(1).toLowerCase();\r\n    const res = firstLetter + rest;\r\n    return res;\r\n}\r\nexports.makeFirslLetterUpperCase = makeFirslLetterUpperCase;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU5My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFFTyxNQUFNLG1CQUFtQixHQUFHLENBQUMsVUFBa0MsRUFBVSxFQUFFLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztLQUMzRyxHQUFHLENBQUMsQ0FBQyxHQUFXLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO0tBQ2pELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO0FBRkYsMkJBQW1CLHVCQUVqQjtBQUVSLE1BQU0sT0FBTyxHQUFHLENBQ3JCLElBQVksRUFDWixRQUFrQixFQUNsQixVQUFtQyxFQUM5QixFQUFFO0lBQ1AsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQywrQkFBbUIsRUFBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3RFLE9BQU8sSUFBSSxHQUFHLENBQUMsR0FBRyxRQUFRLEdBQUcsV0FBVyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDO0FBUFcsZUFBTyxXQU9sQjtBQUVGLFNBQWdCLGlCQUFpQixDQUMvQixHQUFXLEVBQ1gsT0FBa0IsRUFDbEIsa0JBQXVDLEVBQ3ZDLE9BQWdCO0lBRWhCLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekMsSUFBSSxPQUFPLEVBQUU7UUFDWCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO0tBQ2hDO0lBQ0QsSUFBSSxrQkFBa0IsRUFBRTtRQUN0QixrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFO1lBQzlDLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUMsQ0FBQztLQUNKO0lBQ0QsSUFBSSxPQUFPLEVBQUU7UUFDWCxJQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQztLQUMxQjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQW5CRCw4Q0FtQkM7QUFFRCxTQUFnQixxQkFBcUIsQ0FBQyxHQUFXLEVBQUUsR0FBVztJQUM1RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMzRCxDQUFDO0FBRkQsc0RBRUM7QUFFRCxTQUFnQix3QkFBd0IsQ0FBQyxNQUFjO0lBQ3JELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM1QyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzNDLE1BQU0sR0FBRyxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7SUFDL0IsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBTEQsNERBS0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvZnVuY3Rpb25zLnRzPzMyZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW5kcG9pbnQgfSBmcm9tICcuLi90eXBlcy9lbnVtcyc7XHJcblxyXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVRdWVyeVN0cmluZyA9IChxdWVyeVBhcmFtOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogc3RyaW5nID0+IGA/JHtPYmplY3Qua2V5cyhxdWVyeVBhcmFtKVxyXG4gIC5tYXAoKGtleTogc3RyaW5nKSA9PiBgJHtrZXl9PSR7cXVlcnlQYXJhbVtrZXldfWApXHJcbiAgLmpvaW4oJyYnKX1gO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1ha2VVcmwgPSAoXHJcbiAgYmFzZTogc3RyaW5nLFxyXG4gIGVuZHBvaW50OiBFbmRwb2ludCxcclxuICBxdWVyeVBhcmFtPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcclxuKTogVVJMID0+IHtcclxuICBjb25zdCBwYXJhbVN0cmluZyA9IHF1ZXJ5UGFyYW0gPyBnZW5lcmF0ZVF1ZXJ5U3RyaW5nKHF1ZXJ5UGFyYW0pIDogJyc7XHJcbiAgcmV0dXJuIG5ldyBVUkwoYCR7ZW5kcG9pbnR9JHtwYXJhbVN0cmluZ31gLCBiYXNlKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIVE1MRWxlbWVudChcclxuICB0YWc6IHN0cmluZyxcclxuICBjbGFzc2VzPzogc3RyaW5nW10sXHJcbiAgYXRyaWJ1dGVzQWRuVmFsdWVzPzogW3N0cmluZywgc3RyaW5nXVtdLFxyXG4gIGNvbnRlbnQ/OiBzdHJpbmcsXHJcbik6IEhUTUxFbGVtZW50IHtcclxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xyXG4gIGlmIChjbGFzc2VzKSB7XHJcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XHJcbiAgfVxyXG4gIGlmIChhdHJpYnV0ZXNBZG5WYWx1ZXMpIHtcclxuICAgIGF0cmlidXRlc0FkblZhbHVlcy5mb3JFYWNoKChhdHJpYnV0ZUFuZFZhbHVlKSA9PiB7XHJcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0cmlidXRlQW5kVmFsdWVbMF0sIGF0cmlidXRlQW5kVmFsdWVbMV0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChjb250ZW50KSB7XHJcbiAgICBub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tSW50SW5jbHVzaXZlKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmlyc2xMZXR0ZXJVcHBlckNhc2Uoc3RyaW5nOiBzdHJpbmcpIHtcclxuICBjb25zdCBmaXJzdExldHRlciA9IHN0cmluZ1swXS50b1VwcGVyQ2FzZSgpO1xyXG4gIGNvbnN0IHJlc3QgPSBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcclxuICBjb25zdCByZXMgPSBmaXJzdExldHRlciArIHJlc3Q7XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9593\n")},127:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.randomInteger = void 0;\r\nfunction randomInteger(min, max) {\r\n    return Math.round(min - 0.5 + Math.random() * (max - min + 1));\r\n}\r\nexports.randomInteger = randomInteger;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLFNBQWdCLGFBQWEsQ0FBQyxHQUFXLEVBQUUsR0FBVztJQUNwRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakUsQ0FBQztBQUZELHNDQUVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL3NyYy9jb21wb25lbnRzL3V0aWxzL2dldFJhbmRvbUludGVnZXIudHM/Y2ZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcmFuZG9tSW50ZWdlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcclxuICByZXR1cm4gTWF0aC5yb3VuZChtaW4gLSAwLjUgKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///127\n')},9721:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.getRandomWordByGroup = exports.getRandomWordsByGroup = void 0;\r\nconst api_1 = __webpack_require__(1341);\r\nconst getRandomInteger_1 = __webpack_require__(127);\r\nconst shuffleArray_1 = __webpack_require__(4879);\r\nconst MAX_PAGE_NUMBER = 29;\r\nasync function getRandomWordsByGroup(group, count) {\r\n    const randomPageNumber = (0, getRandomInteger_1.randomInteger)(1, MAX_PAGE_NUMBER);\r\n    const words = await api_1.api.getWords({ group, page: String(randomPageNumber) });\r\n    const randomWords = (0, shuffleArray_1.shuffleArray)(words).slice(0, count);\r\n    return randomWords;\r\n}\r\nexports.getRandomWordsByGroup = getRandomWordsByGroup;\r\nasync function getRandomWordByGroup(group) {\r\n    return (await getRandomWordsByGroup(group, 1))[0];\r\n}\r\nexports.getRandomWordByGroup = getRandomWordByGroup;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcyMS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSx3Q0FBbUM7QUFDbkMsb0RBQW1EO0FBQ25ELGlEQUE4QztBQUU5QyxNQUFNLGVBQWUsR0FBRyxFQUFFLENBQUM7QUFFcEIsS0FBSyxVQUFVLHFCQUFxQixDQUFDLEtBQWEsRUFBRSxLQUFhO0lBQ3RFLE1BQU0sZ0JBQWdCLEdBQUcsb0NBQWEsRUFBQyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDM0QsTUFBTSxLQUFLLEdBQUcsTUFBTSxTQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDNUUsTUFBTSxXQUFXLEdBQUcsK0JBQVksRUFBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3hELE9BQU8sV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFMRCxzREFLQztBQUVNLEtBQUssVUFBVSxvQkFBb0IsQ0FBQyxLQUFhO0lBQ3RELE9BQU8sQ0FBQyxNQUFNLHFCQUFxQixDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BELENBQUM7QUFGRCxvREFFQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvY29tcG9uZW50cy91dGlscy9nZXRSYW5kb21Xb3Jkcy50cz81NTJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwaSB9IGZyb20gJy4uL01vZGVsL2FwaSc7XHJcbmltcG9ydCB7IHJhbmRvbUludGVnZXIgfSBmcm9tICcuL2dldFJhbmRvbUludGVnZXInO1xyXG5pbXBvcnQgeyBzaHVmZmxlQXJyYXkgfSBmcm9tICcuL3NodWZmbGVBcnJheSc7XHJcblxyXG5jb25zdCBNQVhfUEFHRV9OVU1CRVIgPSAyOTtcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSYW5kb21Xb3Jkc0J5R3JvdXAoZ3JvdXA6IHN0cmluZywgY291bnQ6IG51bWJlcikge1xyXG4gIGNvbnN0IHJhbmRvbVBhZ2VOdW1iZXIgPSByYW5kb21JbnRlZ2VyKDEsIE1BWF9QQUdFX05VTUJFUik7XHJcbiAgY29uc3Qgd29yZHMgPSBhd2FpdCBhcGkuZ2V0V29yZHMoeyBncm91cCwgcGFnZTogU3RyaW5nKHJhbmRvbVBhZ2VOdW1iZXIpIH0pO1xyXG4gIGNvbnN0IHJhbmRvbVdvcmRzID0gc2h1ZmZsZUFycmF5KHdvcmRzKS5zbGljZSgwLCBjb3VudCk7XHJcbiAgcmV0dXJuIHJhbmRvbVdvcmRzO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmFuZG9tV29yZEJ5R3JvdXAoZ3JvdXA6IHN0cmluZykge1xyXG4gIHJldHVybiAoYXdhaXQgZ2V0UmFuZG9tV29yZHNCeUdyb3VwKGdyb3VwLCAxKSlbMF07XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9721\n')},8105:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.makeDailyStat = void 0;\r\nfunction makeDailyStat(stat) {\r\n    const dates = Object.keys(stat.optional.words);\r\n    const obj = dates.reduce((acc, currentDate) => {\r\n        acc[currentDate] = {};\r\n        acc[currentDate].games = { audiocall: {}, sprint: {} };\r\n        acc[currentDate].words = stat.optional.words[currentDate];\r\n        acc[currentDate].games.audiocall = stat.optional.games.audiocall[currentDate];\r\n        acc[currentDate].games.sprint = stat.optional.games.sprint[currentDate];\r\n        return acc;\r\n    }, {});\r\n    const res = Object.entries(obj);\r\n    return res.reverse();\r\n}\r\nexports.makeDailyStat = makeDailyStat;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEwNS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFJQSxTQUFnQixhQUFhLENBQUMsSUFBZTtJQUMzQyxNQUFNLEtBQUssR0FBYSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekQsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxXQUFtQixFQUFFLEVBQUU7UUFDcEQsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQWtCLENBQUM7UUFDdEMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUFtQixFQUFFLE1BQU0sRUFBRSxFQUFtQixFQUFFLENBQUM7UUFDekYsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMxRCxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDOUUsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQyxFQUFFLEVBQWUsQ0FBQyxDQUFDO0lBQ3BCLE1BQU0sR0FBRyxHQUE2QixNQUFNLENBQUMsT0FBTyxDQUFDLEdBQWdCLENBQUMsQ0FBQztJQUN2RSxPQUFPLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN2QixDQUFDO0FBWkQsc0NBWUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvbWFrZURhaWx5U3RhdE9iamVjdC50cz9iYzg2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgU3RhdGlzdGljLCBEYWlseVN0YXQsIERhaWx5U3RhdE9iaiwgR2FtZVN0YXRpc3RpYyxcclxufSBmcm9tICcuLi90eXBlcy9pbnRlcmZhY2VzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlRGFpbHlTdGF0KHN0YXQ6IFN0YXRpc3RpYykge1xyXG4gIGNvbnN0IGRhdGVzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKHN0YXQub3B0aW9uYWwud29yZHMpO1xyXG4gIGNvbnN0IG9iaiA9IGRhdGVzLnJlZHVjZSgoYWNjLCBjdXJyZW50RGF0ZTogc3RyaW5nKSA9PiB7XHJcbiAgICBhY2NbY3VycmVudERhdGVdID0ge30gYXMgRGFpbHlTdGF0T2JqO1xyXG4gICAgYWNjW2N1cnJlbnREYXRlXS5nYW1lcyA9IHsgYXVkaW9jYWxsOiB7fSBhcyBHYW1lU3RhdGlzdGljLCBzcHJpbnQ6IHt9IGFzIEdhbWVTdGF0aXN0aWMgfTtcclxuICAgIGFjY1tjdXJyZW50RGF0ZV0ud29yZHMgPSBzdGF0Lm9wdGlvbmFsLndvcmRzW2N1cnJlbnREYXRlXTtcclxuICAgIGFjY1tjdXJyZW50RGF0ZV0uZ2FtZXMuYXVkaW9jYWxsID0gc3RhdC5vcHRpb25hbC5nYW1lcy5hdWRpb2NhbGxbY3VycmVudERhdGVdO1xyXG4gICAgYWNjW2N1cnJlbnREYXRlXS5nYW1lcy5zcHJpbnQgPSBzdGF0Lm9wdGlvbmFsLmdhbWVzLnNwcmludFtjdXJyZW50RGF0ZV07XHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sIHt9IGFzIERhaWx5U3RhdCk7XHJcbiAgY29uc3QgcmVzOiBbc3RyaW5nLCBEYWlseVN0YXRPYmpdW10gPSBPYmplY3QuZW50cmllcyhvYmogYXMgRGFpbHlTdGF0KTtcclxuICByZXR1cm4gcmVzLnJldmVyc2UoKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8105\n')},4879:(__unused_webpack_module,exports)=>{"use strict";eval('\r\nObject.defineProperty(exports, "__esModule", ({ value: true }));\r\nexports.shuffleArray = void 0;\r\nfunction shuffleArray(array) {\r\n    const shuffledArray = [...array].sort(() => Math.random() - 0.5);\r\n    return shuffledArray;\r\n}\r\nexports.shuffleArray = shuffleArray;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg3OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxTQUFnQixZQUFZLENBQUksS0FBVTtJQUN4QyxNQUFNLGFBQWEsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUNqRSxPQUFPLGFBQWEsQ0FBQztBQUN2QixDQUFDO0FBSEQsb0NBR0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ycy1sYW5nLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvc2h1ZmZsZUFycmF5LnRzPzgwNDkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGVBcnJheTxUPihhcnJheTogVFtdKSB7XHJcbiAgY29uc3Qgc2h1ZmZsZWRBcnJheSA9IFsuLi5hcnJheV0uc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcclxuICByZXR1cm4gc2h1ZmZsZWRBcnJheTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4879\n')},3607:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("var __webpack_unused_export__;\n\r\n__webpack_unused_export__ = ({ value: true });\r\nconst Controller_1 = __webpack_require__(2962);\r\n__webpack_require__(3690);\r\nconsole.log('Lets go');\r\nconst controller = new Controller_1.Controller();\r\ncontroller.initRouter();\r\ncontroller.initApp();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYwNy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBZ0U7QUFDaEUsMEJBQXVCO0FBRXZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7QUFFdkIsTUFBTSxVQUFVLEdBQUcsSUFBSSx1QkFBVSxFQUFFLENBQUM7QUFFcEMsVUFBVSxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ3hCLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JzLWxhbmcvLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL2NvbnRyb2xsZXIvQ29udHJvbGxlcic7XHJcbmltcG9ydCAnLi9nbG9iYWwuc2Nzcyc7XHJcblxyXG5jb25zb2xlLmxvZygnTGV0cyBnbycpO1xyXG5cclxuY29uc3QgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XHJcblxyXG5jb250cm9sbGVyLmluaXRSb3V0ZXIoKTtcclxuY29udHJvbGxlci5pbml0QXBwKCk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3607\n")},7933:t=>{"use strict";t.exports="data:image/svg+xml,%3Csvg width=%2750px%27 height=%2750px%27 viewBox=%270 0 1024 1024%27 xmlns=%27http://www.w3.org/2000/svg%27 class=%27icon-git%27%3E%3Cpath d=%27M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z%27%3E%3C/path%3E%3C/svg%3E"},4902:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/info-section2.jpg"},2182:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/main-bg1.jpg"},7193:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/branch.svg"},7769:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/circle-empty.svg"},5331:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/sound-default.svg"},8198:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/sound-mute.svg"},1340:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/sprint-bg-bottom.svg"},4e3:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/sprint-bg-left.svg"},8385:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/sprint-bg-right.svg"},1733:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/true-series.svg"},5680:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/voice-grey.svg"},8752:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/voice-hover.svg"},6096:(t,n,Q)=>{"use strict";t.exports=Q.p+"./assets/voice.svg"},8597:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ auto)\n});\n\n;// CONCATENATED MODULE: ./node_modules/chart.js/dist/chunks/helpers.segment.mjs\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\nfunction noop() {}\nconst uid = (function() {\n  let id = 0;\n  return function() {\n    return id++;\n  };\n}());\nfunction isNullOrUndef(value) {\n  return value === null || typeof value === 'undefined';\n}\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\nconst isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : value / dimension;\nconst toDimension = (value, dimension) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone$1(source) {\n  if (isArray(source)) {\n    return source.map(clone$1);\n  }\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone$1(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone$1(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  for (let i = 0; i < ilen; ++i) {\n    source = sources[i];\n    if (!isObject(source)) {\n      continue;\n    }\n    const keys = Object.keys(source);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, source, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  return merge(target, source, {merger: _mergerIf});\n}\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone$1(sval);\n  }\n}\nfunction _deprecated(scope, value, previous, current) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n\t\t\t'\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\nconst keyResolvers = {\n  '': v => v,\n  x: o => o.x,\n  y: o => o.y\n};\nfunction resolveObjectKey(obj, key) {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\nfunction _getKeyResolver(key) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\nfunction _splitKey(key) {\n  const parts = key.split('.');\n  const keys = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value) => typeof value !== 'undefined';\nconst isFunction = (value) => typeof value === 'function';\nconst setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction _isClickEvent(e) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < (-0.5 * PI)) {\n    angle += TAU;\n  }\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {lo, hi};\n}\nconst _lookupByKey = (table, key, value, last) =>\n  _lookup(table, value, last\n    ? index => table[index][key] <= value\n    : index => table[index][key] < value);\nconst _rlookupByKey = (table, key, value) =>\n  _lookup(table, value, index => table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n  const set = new Set();\n  let i, ilen;\n  for (i = 0, ilen = items.length; i < ilen; ++i) {\n    set.add(items[i]);\n  }\n  if (set.size === ilen) {\n    return items;\n  }\n  return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\nconst requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\nfunction throttled(fn, thisArg, updateFn) {\n  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));\n  let ticking = false;\n  let args = [];\n  return function(...rest) {\n    args = updateArgs(rest);\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, args);\n      });\n    }\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function(...args) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\nconst _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\nconst _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        _lookupByKey(_parsed, iScale.axis, min).lo,\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {start, count};\n}\nfunction _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n\nconst atEdge = (t) => t === 0 || t === 1;\nconst elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n  linear: t => t,\n  easeInQuad: t => t * t,\n  easeOutQuad: t => -t * (t - 2),\n  easeInOutQuad: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n  easeInCubic: t => t * t * t,\n  easeOutCubic: t => (t -= 1) * t * t + 1,\n  easeInOutCubic: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: t => t * t * t * t,\n  easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: t => t * t * t * t * t,\n  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: t => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: t => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: t => Math.sin(t * HALF_PI),\n  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: t => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: t => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n  easeInOutBounce: t => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n};\n\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nfunction isPatternOrGradient(value) {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n  return false;\n}\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, ''), scope);\n}\nclass Defaults {\n  constructor(_descriptors) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = '_' + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n}\nvar defaults = new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n});\n\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  ctx = ctx || canvas.getContext('2d');\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n  let type, xOffset, yOffset, size, cornerRadius, width;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n  default:\n    if (w) {\n      ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n    } else {\n      ctx.arc(x, y, radius, 0, TAU);\n    }\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      width = w ? w / 2 : size;\n      ctx.rect(x - width, y - size, 2 * width, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = w ? w / 2 : Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += font.lineHeight;\n  }\n  ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction addRoundedRectPath(ctx, rect) {\n  const {x, y, w, h, radius} = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n  case 'px':\n    return value;\n  case '%':\n    value /= 100;\n    break;\n  }\n  return size * value;\n}\nconst numberOrZero = v => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\nfunction toTRBL(value) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = '';\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n  font.string = toFontString(font);\n  return font;\n}\nfunction resolve(inputs, context, index, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\n\nfunction _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {\n  if (!defined(fallback)) {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: rootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    get(target, prop) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    get(target, prop, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nconst readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n  const value = resolve();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop];\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  value = value(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  if (defined(_context.index) && isIndexable(prop)) {\n    value = value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (defined(fallback) && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (defined(value)) {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set = new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array(count);\n  let i, ilen, index, item;\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\nfunction splineCurveMonotone(points, indexAxis = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n      : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n\nfunction _isDomSupported() {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = parent.host;\n  }\n  return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf('%') !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nconst getComputedStyle = (element) => window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nconst useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {offsetX, offsetY} = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\nfunction getRelativePosition(evt, chart) {\n  if ('native' in evt) {\n    return evt;\n  }\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(evt, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nconst round1 = v => Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n  return {\n    width,\n    height\n  };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = deviceHeight / pixelRatio;\n  chart.width = deviceWidth / pixelRatio;\n  const canvas = chart.canvas;\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\nconst supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    window.addEventListener('test', null, options);\n    window.removeEventListener('test', null, options);\n  } catch (e) {\n  }\n  return passiveSupported;\n}());\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n    : mode === 'after' ? t < 1 ? p1.y : p2.y\n    : t > 0 ? p2.y : p1.y\n  };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\nconst getLeftToRightAdapter = function() {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    },\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n    style.setProperty('direction', direction, 'important');\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== undefined) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  let {start, end, loop} = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {start, end};\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/chart.js/dist/chart.mjs\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\n\n\n\nclass Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\nvar animator = new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  color(from, to, factor) {\n    const c0 = color(from || transparent);\n    const c1 = c0.valid && color(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\nclass Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n    this._active = from !== to && (loop || (elapsed < duration));\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from, to, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n\nconst numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\ndefaults.set('animation', {\n  delay: undefined,\n  duration: 1000,\n  easing: 'easeOutQuart',\n  fn: undefined,\n  from: undefined,\n  loop: undefined,\n  to: undefined,\n  type: undefined,\n});\nconst animationOptions = Object.keys(defaults.animation);\ndefaults.describe('animation', {\n  _fallback: false,\n  _indexable: false,\n  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n});\ndefaults.set('animations', {\n  colors: {\n    type: 'color',\n    properties: colors\n  },\n  numbers: {\n    type: 'number',\n    properties: numbers\n  },\n});\ndefaults.describe('animations', {\n  _fallback: 'animation',\n});\ndefaults.set('transitions', {\n  active: {\n    animation: {\n      duration: 400\n    }\n  },\n  resize: {\n    animation: {\n      duration: 0\n    }\n  },\n  show: {\n    animations: {\n      colors: {\n        from: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        duration: 0\n      },\n    }\n  },\n  hide: {\n    animations: {\n      colors: {\n        to: 'transparent'\n      },\n      visible: {\n        type: 'boolean',\n        easing: 'linear',\n        fn: v => v | 0\n      },\n    }\n  }\n});\nclass Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n  }\n}\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\nclass DatasetController {\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n  reset() {\n    this._update('reset');\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {}\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    const context = () => this.getContext(index, active);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n  updateElements(element, start, count, mode) {}\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\nclass BarController extends DatasetController {\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n    return stacks;\n  }\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1;\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n}\nBarController.id = 'bar';\nBarController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'bar',\n  categoryPercentage: 0.8,\n  barPercentage: 0.9,\n  grouped: true,\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'base', 'width', 'height']\n    }\n  }\n};\nBarController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n      offset: true,\n      grid: {\n        offset: true\n      }\n    },\n    _value_: {\n      type: 'linear',\n      beginAtZero: true,\n    }\n  }\n};\n\nclass BubbleController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: meta.label,\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n}\nBubbleController.id = 'bubble';\nBubbleController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'borderWidth', 'radius']\n    }\n  }\n};\nBubbleController.overrides = {\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        }\n      }\n    }\n  }\n};\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\nclass DoughnutController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n  linkScales() {}\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\nDoughnutController.id = 'doughnut';\nDoughnutController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: false\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n    },\n  },\n  cutout: '50%',\n  rotation: 0,\n  circumference: 360,\n  radius: '100%',\n  spacing: 0,\n  indexAxis: 'r',\n};\nDoughnutController.descriptors = {\n  _scriptable: (name) => name !== 'spacing',\n  _indexable: (name) => name !== 'spacing',\n};\nDoughnutController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(tooltipItem) {\n          let dataLabel = tooltipItem.label;\n          const value = ': ' + tooltipItem.formattedValue;\n          if (isArray(dataLabel)) {\n            dataLabel = dataLabel.slice();\n            dataLabel[0] += value;\n          } else {\n            dataLabel += value;\n          }\n          return dataLabel;\n        }\n      }\n    }\n  }\n};\n\nclass LineController extends DatasetController {\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\nLineController.id = 'line';\nLineController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  showLine: true,\n  spanGaps: false,\n};\nLineController.overrides = {\n  scales: {\n    _index_: {\n      type: 'category',\n    },\n    _value_: {\n      type: 'linear',\n    },\n  }\n};\n\nclass PolarAreaController extends DatasetController {\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n    return range;\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\nPolarAreaController.id = 'polarArea';\nPolarAreaController.defaults = {\n  dataElementType: 'arc',\n  animation: {\n    animateRotate: true,\n    animateScale: true\n  },\n  animations: {\n    numbers: {\n      type: 'number',\n      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n    },\n  },\n  indexAxis: 'r',\n  startAngle: 0,\n};\nPolarAreaController.overrides = {\n  aspectRatio: 1,\n  plugins: {\n    legend: {\n      labels: {\n        generateLabels(chart) {\n          const data = chart.data;\n          if (data.labels.length && data.datasets.length) {\n            const {labels: {pointStyle}} = chart.legend.options;\n            return data.labels.map((label, i) => {\n              const meta = chart.getDatasetMeta(0);\n              const style = meta.controller.getStyle(i);\n              return {\n                text: label,\n                fillStyle: style.backgroundColor,\n                strokeStyle: style.borderColor,\n                lineWidth: style.borderWidth,\n                pointStyle: pointStyle,\n                hidden: !chart.getDataVisibility(i),\n                index: i\n              };\n            });\n          }\n          return [];\n        }\n      },\n      onClick(e, legendItem, legend) {\n        legend.chart.toggleDataVisibility(legendItem.index);\n        legend.chart.update();\n      }\n    },\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(context) {\n          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;\n        }\n      }\n    }\n  },\n  scales: {\n    r: {\n      type: 'radialLinear',\n      angleLines: {\n        display: false\n      },\n      beginAtZero: true,\n      grid: {\n        circular: true\n      },\n      pointLabels: {\n        display: false\n      },\n      startAngle: 0\n    }\n  }\n};\n\nclass PieController extends DoughnutController {\n}\nPieController.id = 'pie';\nPieController.defaults = {\n  cutout: 0,\n  rotation: 0,\n  circumference: 360,\n  radius: '100%'\n};\n\nclass RadarController extends DatasetController {\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, undefined, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\nRadarController.id = 'radar';\nRadarController.defaults = {\n  datasetElementType: 'line',\n  dataElementType: 'point',\n  indexAxis: 'r',\n  showLine: true,\n  elements: {\n    line: {\n      fill: 'start'\n    }\n  },\n};\nRadarController.overrides = {\n  aspectRatio: 1,\n  scales: {\n    r: {\n      type: 'radialLinear',\n    }\n  }\n};\n\nclass Element {\n  constructor() {\n    this.x = undefined;\n    this.y = undefined;\n    this.active = false;\n    this.options = undefined;\n    this.$animations = undefined;\n  }\n  tooltipPosition(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach(prop => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\n\nconst formatters = {\n  values(value) {\n    return isArray(value) ? value : '' + value;\n  },\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));\n    if (remain === 1 || remain === 2 || remain === 5) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {formatters};\n\ndefaults.set('scale', {\n  display: true,\n  offset: false,\n  reverse: false,\n  beginAtZero: false,\n  bounds: 'ticks',\n  grace: 0,\n  grid: {\n    display: true,\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickLength: 8,\n    tickWidth: (_ctx, options) => options.lineWidth,\n    tickColor: (_ctx, options) => options.color,\n    offset: false,\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderWidth: 1\n  },\n  title: {\n    display: false,\n    text: '',\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  ticks: {\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    textStrokeWidth: 0,\n    textStrokeColor: '',\n    padding: 3,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 3,\n    labelOffset: 0,\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {},\n    align: 'center',\n    crossAlign: 'near',\n    showLabelBackdrop: false,\n    backdropColor: 'rgba(255, 255, 255, 0.75)',\n    backdropPadding: 2,\n  }\n});\ndefaults.route('scale.ticks', 'color', '', 'color');\ndefaults.route('scale.grid', 'color', '', 'borderColor');\ndefaults.route('scale.grid', 'borderColor', '', 'borderColor');\ndefaults.route('scale.title', 'color', '', 'color');\ndefaults.describe('scale', {\n  _fallback: false,\n  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',\n});\ndefaults.describe('scales', {\n  _fallback: 'scale',\n});\ndefaults.describe('scale.ticks', {\n  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n  _indexable: (name) => name !== 'backdropPadding',\n});\n\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return (lines * font.lineHeight) + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\nclass Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = undefined;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.paddingTop = undefined;\n    this.paddingBottom = undefined;\n    this.paddingLeft = undefined;\n    this.paddingRight = undefined;\n    this.axis = undefined;\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = undefined;\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index) {\n    return raw;\n  }\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    callback(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = this.ticks.length;\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; ++i) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {}\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {min, max} = this;\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n  getContext(index) {\n    const ticks = this.ticks || [];\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== 'auto') {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const optsAtIndex = grid.setContext(this.getContext(i));\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndex.borderDash || [];\n      const borderDashOffset = optsAtIndex.borderDashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === undefined) {\n        continue;\n      }\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n      if (isHorizontal) {\n        x = pixel;\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = y + textOffset - labelPadding.top;\n        let left = x - labelPadding.left;\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        }\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor,\n        };\n      }\n      items.push({\n        rotation,\n        label,\n        font,\n        color,\n        strokeColor,\n        strokeWidth,\n        textOffset,\n        textAlign: tickTextAlign,\n        textBaseline,\n        translation: [x, y],\n        backdrop,\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n    let align = 'center';\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n    return {textAlign, x};\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {chart, ctx, options: {grid}} = this;\n    const borderOpts = grid.setContext(this.getContext());\n    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.borderWidth;\n    ctx.strokeStyle = borderOpts.borderColor;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    let i, ilen;\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      const item = items[i];\n      const tickFont = item.font;\n      const label = item.label;\n      if (item.backdrop) {\n        ctx.fillStyle = item.backdrop.color;\n        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n      }\n      let y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, item);\n    }\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n    if (!title.display) {\n      return;\n    }\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: gz + 1,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n\nclass TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n  defaults.set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each('register', args);\n  }\n  remove(...args) {\n    this._each('unregister', args);\n  }\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        each(arg, item => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    callback(component['before' + camelMethod], [], component);\n    registry[method](component);\n    callback(component['after' + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n}\nvar registry = new Registry();\n\nclass ScatterController extends DatasetController {\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    if (this.options.showLine) {\n      const {dataset: line, _dataset} = meta;\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    }\n    this.updateElements(points, start, count, mode);\n  }\n  addElements() {\n    const {showLine} = this.options;\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = registry.getElement('line');\n    }\n    super.addElements();\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\nScatterController.id = 'scatter';\nScatterController.defaults = {\n  datasetElementType: false,\n  dataElementType: 'point',\n  showLine: false,\n  fill: false\n};\nScatterController.overrides = {\n  interaction: {\n    mode: 'point'\n  },\n  plugins: {\n    tooltip: {\n      callbacks: {\n        title() {\n          return '';\n        },\n        label(item) {\n          return '(' + item.label + ', ' + item.formattedValue + ')';\n        }\n      }\n    }\n  },\n  scales: {\n    x: {\n      type: 'linear'\n    },\n    y: {\n      type: 'linear'\n    }\n  }\n};\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPolarAreaController: PolarAreaController,\nPieController: PieController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\nfunction chart_abstract() {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\nclass DateAdapter {\n  constructor(options) {\n    this.options = options || {};\n  }\n  init(chartOptions) {}\n  formats() {\n    return chart_abstract();\n  }\n  parse(value, format) {\n    return chart_abstract();\n  }\n  format(timestamp, format) {\n    return chart_abstract();\n  }\n  add(timestamp, amount, unit) {\n    return chart_abstract();\n  }\n  diff(a, b, unit) {\n    return chart_abstract();\n  }\n  startOf(timestamp, unit, weekday) {\n    return chart_abstract();\n  }\n  endOf(timestamp, unit) {\n    return chart_abstract();\n  }\n}\nDateAdapter.override = function(members) {\n  Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n  _date: DateAdapter\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  return {lo: 0, hi: data.length - 1};\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  evaluateInteractionItems,\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n      return elements;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\ndefaults.set('layout', {\n  autoPadding: true,\n  padding: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }\n});\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n\nclass BasePlatform {\n  acquireContext(canvas, aspectRatio) {}\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {}\n  removeEventListener(chart, type, listener) {}\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n}\n\nclass BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n\nconst EXPANDO_KEY = '$chartjs';\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\nconst isNullOrEmpty = value => value === null || value === '';\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || 'block';\n  style.boxSizing = style.boxSizing || 'border-box';\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart, (args) => {\n    const event = args[0];\n    return [event, event.offsetX, event.offsetY];\n  });\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nclass DomPlatform extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nclass PluginService {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n  return {plugins, localIds};\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\nfunction determineAxis(id, scaleOptions) {\n  if (id === 'x' || id === 'y') {\n    return id;\n  }\n  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const firstIDs = Object.create(null);\n  const scales = Object.create(null);\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    firstIDs[axis] = firstIDs[axis] || id;\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\nclass Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = new Set();\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {options, type} = this;\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {},\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar version = \"3.9.1\";\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins('afterRender');\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\nclass Chart {\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  _initialize() {\n    this.notifyPlugins('beforeInit');\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins('afterInit');\n    return this;\n  }\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins('resize', {size: newSize});\n    callback(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass.prototype, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins('beforeElementsUpdate');\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins('afterUpdate', {mode});\n    this._layers.sort(compare2Level('z', '_idx'));\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n    this.notifyPlugins('afterLayout');\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins('afterDraw');\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = this.chartArea;\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      unclipArea(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    this.notifyPlugins('destroy');\n    delete instances[this.id];\n    this.notifyPlugins('afterDestroy');\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    each(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove('attach', attached);\n      this.attached = true;\n      this.resize();\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove('resize', listener);\n      this._stop();\n      this._resize(0, 0);\n      _add('attach', attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n    if (inChartArea) {\n      this._lastEvent = null;\n      callback(options.onHover, [e, active, this], this);\n      if (isClick) {\n        callback(options.onClick, [e, active, this], this);\n      }\n    }\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\nconst invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n  defaults: {\n    enumerable,\n    value: defaults\n  },\n  instances: {\n    enumerable,\n    value: instances\n  },\n  overrides: {\n    enumerable,\n    value: overrides\n  },\n  registry: {\n    enumerable,\n    value: registry\n  },\n  version: {\n    enumerable,\n    value: version\n  },\n  getChart: {\n    enumerable,\n    value: getChart\n  },\n  register: {\n    enumerable,\n    value: (...items) => {\n      registry.add(...items);\n      invalidatePlugins();\n    }\n  },\n  unregister: {\n    enumerable,\n    value: (...items) => {\n      registry.remove(...items);\n      invalidatePlugins();\n    }\n  }\n});\n\nfunction clipArc(ctx, element, endAngle) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  if (circular) {\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + circumference % TAU;\n      if (circumference % TAU === 0) {\n        endAngle += TAU;\n      }\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n  const {x, y, startAngle, pixelMargin, fullCircles} = element;\n  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n  const innerRadius = element.innerRadius + pixelMargin;\n  let i;\n  if (inner) {\n    clipArc(ctx, element, startAngle + TAU);\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);\n  for (i = 0; i < fullCircles; ++i) {\n    ctx.stroke();\n  }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n  const {options} = element;\n  const {borderWidth, borderJoinStyle} = options;\n  const inner = options.borderAlign === 'inner';\n  if (!borderWidth) {\n    return;\n  }\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n  if (element.fullCircles) {\n    drawFullCircleBorders(ctx, element, inner);\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.stroke();\n}\nclass ArcElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = this.options.spacing / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return (betweenAngles && withinRadius);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference',\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 2;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    let radiusOffset = 0;\n    if (offset) {\n      radiusOffset = offset / 2;\n      const halfAngle = (this.startAngle + this.endAngle) / 2;\n      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n      if (this.circumference >= PI) {\n        radiusOffset = offset;\n      }\n    }\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n    ctx.restore();\n  }\n}\nArcElement.id = 'arc';\nArcElement.defaults = {\n  borderAlign: 'center',\n  borderColor: '#fff',\n  borderJoinStyle: undefined,\n  borderRadius: 0,\n  borderWidth: 2,\n  offset: 0,\n  spacing: 0,\n  angle: undefined,\n  circular: true,\n};\nArcElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor'\n};\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n  return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nclass LineElement extends Element {\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || (this.points.length - start);\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\nLineElement.id = 'line';\nLineElement.defaults = {\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderWidth: 3,\n  capBezierPoints: true,\n  cubicInterpolationMode: 'default',\n  fill: false,\n  spanGaps: false,\n  stepped: false,\n  tension: 0,\n};\nLineElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\nLineElement.descriptors = {\n  _scriptable: true,\n  _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n};\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\nclass PointElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, 'x', useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, 'y', useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n}\nPointElement.id = 'point';\nPointElement.defaults = {\n  borderWidth: 1,\n  hitRadius: 1,\n  hoverBorderWidth: 1,\n  hoverRadius: 4,\n  pointStyle: 'circle',\n  radius: 3,\n  rotation: 0\n};\nPointElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {left, top, right, bottom};\n}\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nclass BarElement extends Element {\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nBarElement.id = 'bar';\nBarElement.defaults = {\n  borderSkipped: 'start',\n  borderWidth: 0,\n  borderRadius: 0,\n  inflateAmount: 'auto',\n  pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n  backgroundColor: 'backgroundColor',\n  borderColor: 'borderColor'\n};\n\nvar chart_elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nLineElement: LineElement,\nPointElement: PointElement,\nBarElement: BarElement\n});\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {value: data});\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {start, count};\n}\nvar plugin_decimation = {\n  id: 'decimation',\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        return;\n      }\n      if (!meta.controller.supportsDecimation) {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = _boundSegments(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\nfunction _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n  if (!propagate) {\n    return fill;\n  }\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isNumberFinite(fill)) {\n      return fill;\n    }\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill;\n    }\n    visited.push(fill);\n    fill = target.fill;\n  }\n  return false;\n}\nfunction _decodeFill(line, index, count) {\n  const fill = parseFillOption(line);\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n  let target = parseFloat(fill);\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n  return target;\n}\nfunction _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n  let value;\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n  if (fill === false || fill === null) {\n    return false;\n  }\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n\nfunction _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n\nclass simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n\nfunction _getTarget(source) {\n  const {chart, fill, line} = source;\n  if (isNumberFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n  if (fill === 'shape') {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n  if (isNumberFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n  return null;\n}\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n  ctx.save();\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n  ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n    ctx.restore();\n  }\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\nvar index = {\n  id: 'filler',\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {options, ctx} = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight});\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight});\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n      this._draw();\n      unclipArea(ctx);\n    }\n  }\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {color: fontColor, padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    overrideTextDirection(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor || fontColor;\n      ctx.fillStyle = legendItem.fontColor || fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = _alignStartEnd(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: 'legend',\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: 0,\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n\nclass Title extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: 'title',\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst chart_map = new WeakMap();\nvar plugin_subtitle = {\n  id: 'subtitle',\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    chart_map.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart_map.get(chart));\n    chart_map.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart_map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: 'color'\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n\nconst positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {width, height};\n}\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart || config._chart;\n    this._chart = this.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {callbacks} = options;\n    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);\n    const title = callbacks.title.apply(this, [context]);\n    const afterTitle = callbacks.afterTitle.apply(this, [context]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));\n  }\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));\n  }\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);\n    const footer = callbacks.footer.apply(this, [tooltipItems]);\n    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(scoped.labelColor.call(this, context));\n      labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n      labelTextColors.push(scoped.labelTextColor.call(this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColors = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.fillStyle = labelColors.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : (labelColors.borderWidth || 1);\n      ctx.strokeStyle = labelColors.borderColor;\n      ctx.setLineDash(labelColors.borderDash || []);\n      ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n      const borderRadius = toTRBLCorners(labelColors.borderRadius);\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColors.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      each(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n    const positionChanged = this._positionChanged(active, e);\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n    if (e.type === 'mouseout') {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n    if (options.reverse) {\n      active.reverse();\n    }\n    return active;\n  }\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n      if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {\n        return;\n      }\n      tooltip.draw(chart.ctx);\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: {\n      beforeTitle: noop,\n      title(tooltipItems) {\n        if (tooltipItems.length > 0) {\n          const item = tooltipItems[0];\n          const labels = item.chart.data.labels;\n          const labelCount = labels ? labels.length : 0;\n          if (this && this.options && this.options.mode === 'dataset') {\n            return item.dataset.label || '';\n          } else if (item.label) {\n            return item.label;\n          } else if (labelCount > 0 && item.dataIndex < labelCount) {\n            return labels[item.dataIndex];\n          }\n        }\n        return '';\n      },\n      afterTitle: noop,\n      beforeBody: noop,\n      beforeLabel: noop,\n      label(tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n          label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n          label += value;\n        }\n        return label;\n      },\n      labelColor(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          borderColor: options.borderColor,\n          backgroundColor: options.backgroundColor,\n          borderWidth: options.borderWidth,\n          borderDash: options.borderDash,\n          borderDashOffset: options.borderDashOffset,\n          borderRadius: 0,\n        };\n      },\n      labelTextColor() {\n        return this.options.bodyColor;\n      },\n      labelPointStyle(tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n          pointStyle: options.pointStyle,\n          rotation: options.rotation,\n        };\n      },\n      afterLabel: noop,\n      afterBody: noop,\n      beforeFooter: noop,\n      footer: noop,\n      afterFooter: noop\n    }\n  },\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n  additionalOptionScopes: ['interaction']\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n      return labels[value];\n    }\n    return value;\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n}\nCategoryScale.id = 'category';\nCategoryScale.defaults = {\n  ticks: {\n    callback: CategoryScale.prototype.getLabelForValue\n  }\n};\n\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n      if (niceMin < min) {\n        j++;\n      }\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = 1;\n      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n        offset = Math.abs(max * 0.05);\n      }\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n\nclass LinearScale extends LinearScaleBase {\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? min : 0;\n    this.max = isNumberFinite(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\nLinearScale.id = 'linear';\nLinearScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.numeric\n  }\n};\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));\n  return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n  const endExp = Math.floor(log10(dataRange.max));\n  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n  const ticks = [];\n  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));\n  let exp = Math.floor(log10(tickVal));\n  let significand = Math.floor(tickVal / Math.pow(10, exp));\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  do {\n    ticks.push({value: tickVal, major: isMajor(tickVal)});\n    ++significand;\n    if (significand === 10) {\n      significand = 1;\n      ++exp;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n  } while (exp < endExp || (exp === endExp && significand < endSignificand));\n  const lastTick = finiteOrDefault(generationOptions.max, tickVal);\n  ticks.push({value: lastTick, major: isMajor(tickVal)});\n  return ticks;\n}\nclass LogarithmicScale extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = undefined;\n    this.end = undefined;\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(exp(min, -1));\n        setMax(exp(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(exp(max, -1));\n    }\n    if (max <= 0) {\n      setMax(exp(min, +1));\n    }\n    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n      setMin(exp(min, -1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\nLogarithmicScale.id = 'logarithmic';\nLogarithmicScale.defaults = {\n  ticks: {\n    callback: Ticks.formatters.logarithmic,\n    major: {\n      enabled: true\n    }\n  }\n};\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const extra = getTickBackdropHeight(opts) / 2;\n  const outerDistance = scale.drawingArea;\n  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const size = labelSizes[i];\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    items.push({\n      x: pointLabelPosition.x,\n      y,\n      textAlign,\n      left,\n      top: y,\n      right: left + size.w,\n      bottom: y + size.h\n    });\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n  return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];\n    const {backdropColor} = optsAtIndex;\n    if (!isNullOrUndef(backdropColor)) {\n      const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);\n      const padding = toPadding(optsAtIndex.backdropPadding);\n      ctx.fillStyle = backdropColor;\n      const backdropLeft = left - padding.left;\n      const backdropTop = top - padding.top;\n      const backdropWidth = right - left + padding.width;\n      const backdropHeight = bottom - top + padding.height;\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: backdropLeft,\n          y: backdropTop,\n          w: backdropWidth,\n          h: backdropHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n      }\n    }\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {color, lineWidth} = gridLineOpts;\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(gridLineOpts.borderDash);\n  ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\nclass RadialLinearScale extends LinearScaleBase {\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = undefined;\n    this.yCenter = undefined;\n    this.drawingArea = undefined;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid} = opts;\n    const labelCount = this._pointLabels.length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const optsAtIndex = grid.setContext(this.getContext(index - 1));\n          drawRadiusLine(this, optsAtIndex, offset, labelCount);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n        if (!lineWidth || !color) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {}\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {}\n}\nRadialLinearScale.id = 'radialLinear';\nRadialLinearScale.defaults = {\n  display: true,\n  animate: true,\n  position: 'chartArea',\n  angleLines: {\n    display: true,\n    lineWidth: 1,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  grid: {\n    circular: false\n  },\n  startAngle: 0,\n  ticks: {\n    showLabelBackdrop: true,\n    callback: Ticks.formatters.numeric\n  },\n  pointLabels: {\n    backdropColor: undefined,\n    backdropPadding: 2,\n    display: true,\n    font: {\n      size: 10\n    },\n    callback(label) {\n      return label;\n    },\n    padding: 5,\n    centerPointLabels: false\n  }\n};\nRadialLinearScale.defaultRoutes = {\n  'angleLines.color': 'borderColor',\n  'pointLabels.color': 'color',\n  'ticks.color': 'color'\n};\nRadialLinearScale.descriptors = {\n  angleLines: {\n    _fallback: 'grid'\n  }\n};\n\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\nconst UNITS = (Object.keys(INTERVALS));\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n  if (!isNumberFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, parser)\n      : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = 'day';\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n  init(scaleOpts, opts) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    adapter.init(opts);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index) {\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = _filterBetween(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  afterAutoSkip() {\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n  initOffsets(timestamps) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(timeOpts.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    const formatter = options.ticks.callback;\n    return formatter ? callback(formatter, [label, index, ticks], this) : label;\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return (this._cache.data = this.normalize(timestamps));\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n}\nTimeScale.id = 'time';\nTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  ticks: {\n    source: 'auto',\n    major: {\n      enabled: false\n    }\n  }\n};\n\nfunction chart_interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = undefined;\n    this._tableRange = undefined;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = chart_interpolate(table, this.min);\n    this._tableRange = chart_interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (chart_interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return chart_interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\nTimeSeriesScale.id = 'timeseries';\nTimeSeriesScale.defaults = TimeScale.defaults;\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n  controllers,\n  chart_elements,\n  plugins,\n  scales,\n];\n\n\n\n;// CONCATENATED MODULE: ./node_modules/chart.js/auto/auto.mjs\n\n\nChart.register(...registerables);\n\n/* harmony default export */ const auto = (Chart);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsOEJBQThCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxTQUFTO0FBQzNDLGFBQWEsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxTQUFTO0FBQ2pELGVBQWUsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2Q0FBNkM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLHNDQUFzQztBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUNBQXlDLGtDQUFrQztBQUMzRSxTQUFTLGlHQUFpRztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBd0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUF3RDtBQUNqRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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QU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFFBQVE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsUUFBUTtBQUNWO0FBQ0E7QUFDQSxNQUFNLGVBQWU7QUFDckI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVSxpQ0FBaUMsK0JBQStCO0FBQ3JGLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sV0FBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5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QVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0JBQWtCO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxFQUFFLGNBQVE7QUFDVjtBQUNBO0FBQ0E7O0FBRTRyQjs7O0FDeGdWcm9COztBQUV2RCxjQUFjLElBQUksYUFBYTs7QUFFL0IsMkNBQWUsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnMtbGFuZy8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzP2FjZjAiLCJ3ZWJwYWNrOi8vcnMtbGFuZy8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0Lm1qcz8zZmIxIiwid2VicGFjazovL3JzLWxhbmcvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvYXV0by9hdXRvLm1qcz9kOWFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ2hhcnQuanMgdjMuOS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjIgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWQrKztcbiAgfTtcbn0oKSk7XG5mdW5jdGlvbiBpc051bGxPclVuZGVmKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmNvbnN0IGlzTnVtYmVyRmluaXRlID0gKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbmZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cbmNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiB2YWx1ZSAvIGRpbWVuc2lvbjtcbmNvbnN0IHRvRGltZW5zaW9uID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcbmZ1bmN0aW9uIGNhbGxiYWNrKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZWFjaChsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcbiAgbGV0IGksIGxlbiwga2V5cztcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfZWxlbWVudHNFcXVhbChhMCwgYTEpIHtcbiAgbGV0IGksIGlsZW4sIHYwLCB2MTtcbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2xvbmUkMShzb3VyY2UpIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lJDEpO1xuICB9XG4gIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZSQxKHNvdXJjZVtrZXlzW2tdXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBpc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcbiAgY29uc3QgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1lcmdlSWYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXJJZihrZXksIHRhcmdldCwgc291cmNlKSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZSwgdmFsdWUsIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuXHRcdFx0J1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cbmNvbnN0IGtleVJlc29sdmVycyA9IHtcbiAgJyc6IHYgPT4gdixcbiAgeDogbyA9PiBvLngsXG4gIHk6IG8gPT4gby55XG59O1xuZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5mdW5jdGlvbiBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSB7XG4gIGNvbnN0IGtleXMgPSBfc3BsaXRLZXkoa2V5KTtcbiAgcmV0dXJuIG9iaiA9PiB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iaiAmJiBvYmpba107XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5mdW5jdGlvbiBfc3BsaXRLZXkoa2V5KSB7XG4gIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgbGV0IHRtcCA9ICcnO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICB0bXAgKz0gcGFydDtcbiAgICBpZiAodG1wLmVuZHNXaXRoKCdcXFxcJykpIHtcbiAgICAgIHRtcCA9IHRtcC5zbGljZSgwLCAtMSkgKyAnLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh0bXApO1xuICAgICAgdG1wID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5jb25zdCBkZWZpbmVkID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuY29uc3Qgc2V0c0VxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBfaXNDbGlja0V2ZW50KGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XG59XG5cbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFRBVSA9IDIgKiBQSTtcbmNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5jb25zdCBJTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbmNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5jb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuY29uc3QgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbmNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcbmZ1bmN0aW9uIG5pY2VOdW0ocmFuZ2UpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxOyBpIDwgc3FydDsgaSsrKSB7XG4gICAgaWYgKHZhbHVlICUgaSA9PT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSAvIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3FydCA9PT0gKHNxcnQgfCAwKSkge1xuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhIC0gYikucG9wKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc051bWJlcihuKSB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5mdW5jdGlvbiBhbG1vc3RFcXVhbHMoeCwgeSwgZXBzaWxvbikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cbmZ1bmN0aW9uIGFsbW9zdFdob2xlKHgsIGVwc2lsb24pIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cbmZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShhcnJheSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAqIChQSSAvIDE4MCk7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5mdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4KSB7XG4gIGlmICghaXNOdW1iZXJGaW5pdGUoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKGRpc3RhbmNlRnJvbVlDZW50ZXIsIGRpc3RhbmNlRnJvbVhDZW50ZXIpO1xuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDEsIHB0Mikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xufVxuZnVuY3Rpb24gX2FuZ2xlRGlmZihhLCBiKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhKSB7XG4gIHJldHVybiAoYSAlIFRBVSArIFRBVSkgJSBUQVU7XG59XG5mdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydCwgZW5kLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGUpIHtcbiAgY29uc3QgYSA9IF9ub3JtYWxpemVBbmdsZShhbmdsZSk7XG4gIGNvbnN0IHMgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICBjb25zdCBlID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIGNvbnN0IGFuZ2xlVG9TdGFydCA9IF9ub3JtYWxpemVBbmdsZShzIC0gYSk7XG4gIGNvbnN0IGFuZ2xlVG9FbmQgPSBfbm9ybWFsaXplQW5nbGUoZSAtIGEpO1xuICBjb25zdCBzdGFydFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIHMpO1xuICBjb25zdCBlbmRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBlKTtcbiAgcmV0dXJuIGEgPT09IHMgfHwgYSA9PT0gZSB8fCAoc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlICYmIHMgPT09IGUpXG4gICAgfHwgKGFuZ2xlVG9TdGFydCA+IGFuZ2xlVG9FbmQgJiYgc3RhcnRUb0FuZ2xlIDwgZW5kVG9BbmdsZSk7XG59XG5mdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWUpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cbmZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWUsIHN0YXJ0LCBlbmQsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuXG5mdW5jdGlvbiBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgY21wKSB7XG4gIGNtcCA9IGNtcCB8fCAoKGluZGV4KSA9PiB0YWJsZVtpbmRleF0gPCB2YWx1ZSk7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBtaWQ7XG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvLCBoaX07XG59XG5jb25zdCBfbG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUsIGxhc3QpID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBsYXN0XG4gICAgPyBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8PSB2YWx1ZVxuICAgIDogaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5jb25zdCBfcmxvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPj0gdmFsdWUpO1xuZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzLCBtaW4sIG1heCkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcbiAgd2hpbGUgKHN0YXJ0IDwgZW5kICYmIHZhbHVlc1tzdGFydF0gPCBtaW4pIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiB2YWx1ZXNbZW5kIC0gMV0gPiBtYXgpIHtcbiAgICBlbmQtLTtcbiAgfVxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XG5mdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHtcbiAgICAgIGxpc3RlbmVyczogW2xpc3RlbmVyXVxuICAgIH1cbiAgfSk7XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBjb25zdCBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG4gIGlmICghc3R1Yikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgZGVsZXRlIGFycmF5W2tleV07XG4gIH0pO1xuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5mdW5jdGlvbiBfYXJyYXlVbmlxdWUoaXRlbXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHNldC5hZGQoaXRlbXNbaV0pO1xuICB9XG4gIGlmIChzZXQuc2l6ZSA9PT0gaWxlbikge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuXG5mdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZSwgZm9udFN0eWxlLCBmb250RmFtaWx5KSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5jb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnLCB1cGRhdGVGbikge1xuICBjb25zdCB1cGRhdGVBcmdzID0gdXBkYXRlRm4gfHwgKChhcmdzKSA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSk7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG4gIGxldCBhcmdzID0gW107XG4gIHJldHVybiBmdW5jdGlvbiguLi5yZXN0KSB7XG4gICAgYXJncyA9IHVwZGF0ZUFyZ3MocmVzdCk7XG4gICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5jb25zdCBfdG9MZWZ0UmlnaHRDZW50ZXIgPSAoYWxpZ24pID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuY29uc3QgX2FsaWduU3RhcnRFbmQgPSAoYWxpZ24sIHN0YXJ0LCBlbmQpID0+IGFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcbmNvbnN0IF90ZXh0WCA9IChhbGlnbiwgbGVmdCwgcmlnaHQsIHJ0bCkgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCBfcGFyc2VkfSA9IG1ldGE7XG4gICAgY29uc3QgYXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IF9saW1pdFZhbHVlKE1hdGgubWluKFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1pbikubG8sXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyksXG4gICAgICAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKE1hdGgubWF4KFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSwgdHJ1ZSkuaGkgKyAxKSxcbiAgICAgIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmNvbnN0IGF0RWRnZSA9ICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDE7XG5jb25zdCBlbGFzdGljSW4gPSAodCwgcywgcCkgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XG5jb25zdCBlbGFzdGljT3V0ID0gKHQsIHMsIHApID0+IE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogdCA9PiB0LFxuICBlYXNlSW5RdWFkOiB0ID0+IHQgKiB0LFxuICBlYXNlT3V0UXVhZDogdCA9PiAtdCAqICh0IC0gMiksXG4gIGVhc2VJbk91dFF1YWQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG4gIGVhc2VJbkN1YmljOiB0ID0+IHQgKiB0ICogdCxcbiAgZWFzZU91dEN1YmljOiB0ID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRDdWJpYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblF1YXJ0OiB0ID0+IHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWFydDogdCA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG4gIGVhc2VJbk91dFF1YXJ0OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcbiAgZWFzZUluUXVpbnQ6IHQgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG4gIGVhc2VPdXRRdWludDogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuICBlYXNlSW5PdXRRdWludDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuICBlYXNlSW5TaW5lOiB0ID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuICBlYXNlT3V0U2luZTogdCA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG4gIGVhc2VJbk91dFNpbmU6IHQgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG4gIGVhc2VJbkV4cG86IHQgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG4gIGVhc2VPdXRFeHBvOiB0ID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuICBlYXNlSW5PdXRFeHBvOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcbiAgZWFzZUluQ2lyYzogdCA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG4gIGVhc2VPdXRDaXJjOiB0ID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcbiAgZWFzZUluT3V0Q2lyYzogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcbiAgZWFzZUluRWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlT3V0RWxhc3RpYzogdCA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZUluT3V0RWxhc3RpYyh0KSB7XG4gICAgY29uc3QgcyA9IDAuMTEyNTtcbiAgICBjb25zdCBwID0gMC40NTtcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XG4gICAgICB0IDwgMC41XG4gICAgICAgID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKVxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgfSxcbiAgZWFzZUluQmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG4gIGVhc2VPdXRCYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuICBlYXNlSW5PdXRCYWNrKHQpIHtcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcbiAgfSxcbiAgZWFzZUluQm91bmNlOiB0ID0+IDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpLFxuICBlYXNlT3V0Qm91bmNlKHQpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcbiAgZWFzZUluT3V0Qm91bmNlOiB0ID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn07XG5cbi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4yLjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyMiBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcm91bmQodikge1xuICByZXR1cm4gdiArIDAuNSB8IDA7XG59XG5jb25zdCBsaW0gPSAodiwgbCwgaCkgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgaCksIGwpO1xuZnVuY3Rpb24gcDJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBuMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJuKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gbjJwKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMTAwKSwgMCwgMTAwKTtcbn1cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuY29uc3QgSFVFX1JFID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgcmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2JuKGgsIHMsIHYpIHtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcbiAgcmV0dXJuIFtmKDUpLCBmKDMpLCBmKDEpXTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcbiAgY29uc3QgcmdiID0gaHNsMnJnYm4oaCwgMSwgMC41KTtcbiAgbGV0IGk7XG4gIGlmICh3ICsgYiA+IDEpIHtcbiAgICBpID0gMSAvICh3ICsgYik7XG4gICAgdyAqPSBpO1xuICAgIGIgKj0gaTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmdiW2ldICo9IDEgLSB3IC0gYjtcbiAgICByZ2JbaV0gKz0gdztcbiAgfVxuICByZXR1cm4gcmdiO1xufVxuZnVuY3Rpb24gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KSB7XG4gIGlmIChyID09PSBtYXgpIHtcbiAgICByZXR1cm4gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKTtcbiAgfVxuICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIChiIC0gcikgLyBkICsgMjtcbiAgfVxuICByZXR1cm4gKHIgLSBnKSAvIGQgKyA0O1xufVxuZnVuY3Rpb24gcmdiMmhzbCh2KSB7XG4gIGNvbnN0IHJhbmdlID0gMjU1O1xuICBjb25zdCByID0gdi5yIC8gcmFuZ2U7XG4gIGNvbnN0IGcgPSB2LmcgLyByYW5nZTtcbiAgY29uc3QgYiA9IHYuYiAvIHJhbmdlO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGxldCBoLCBzLCBkO1xuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBoID0gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KTtcbiAgICBoID0gaCAqIDYwICsgMC41O1xuICB9XG4gIHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhKVxuICAgICAgPyBmKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgICA6IGYoYSwgYiwgYylcbiAgKS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuICByZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG4gIHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcbiAgcmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG4gIHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgdjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzVdICE9PSB2KSB7XG4gICAgYSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcbiAgfVxuICBjb25zdCBoID0gaHVlKCttWzJdKTtcbiAgY29uc3QgcDEgPSArbVszXSAvIDEwMDtcbiAgY29uc3QgcDIgPSArbVs0XSAvIDEwMDtcbiAgaWYgKG1bMV0gPT09ICdod2InKSB7XG4gICAgdiA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuICAgIHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSB7XG4gICAgdiA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IHZbMF0sXG4gICAgZzogdlsxXSxcbiAgICBiOiB2WzJdLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcbiAgdmFyIGggPSByZ2IyaHNsKHYpO1xuICBoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuICBoID0gaHNsMnJnYihoKTtcbiAgdi5yID0gaFswXTtcbiAgdi5nID0gaFsxXTtcbiAgdi5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG4gIGlmICghdikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gcmdiMmhzbCh2KTtcbiAgY29uc3QgaCA9IGFbMF07XG4gIGNvbnN0IHMgPSBuMnAoYVsxXSk7XG4gIGNvbnN0IGwgPSBuMnAoYVsyXSk7XG4gIHJldHVybiB2LmEgPCAyNTVcbiAgICA/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuICAgIDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cbmNvbnN0IG1hcCA9IHtcbiAgeDogJ2RhcmsnLFxuICBaOiAnbGlnaHQnLFxuICBZOiAncmUnLFxuICBYOiAnYmx1JyxcbiAgVzogJ2dyJyxcbiAgVjogJ21lZGl1bScsXG4gIFU6ICdzbGF0ZScsXG4gIEE6ICdlZScsXG4gIFQ6ICdvbCcsXG4gIFM6ICdvcicsXG4gIEI6ICdyYScsXG4gIEM6ICdsYXRlZycsXG4gIEQ6ICdpZ2h0cycsXG4gIFI6ICdpbicsXG4gIFE6ICd0dXJxdW9pcycsXG4gIEU6ICdoaScsXG4gIFA6ICdybycsXG4gIE86ICdhbCcsXG4gIE46ICdsZScsXG4gIE06ICdkZScsXG4gIEw6ICd5ZWxsbycsXG4gIEY6ICdlbicsXG4gIEs6ICdjaCcsXG4gIEc6ICdhcmtzJyxcbiAgSDogJ2VhJyxcbiAgSTogJ2lnaHRnJyxcbiAgSjogJ3doJ1xufTtcbmNvbnN0IG5hbWVzJDEgPSB7XG4gIE9pY2VYZTogJ2YwZjhmZicsXG4gIGFudGlxdWV3RXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJ2ZmZmYnLFxuICBhcXVhbWFyUmU6ICc3ZmZmZDQnLFxuICBhenVZOiAnZjBmZmZmJyxcbiAgYmVpZ2U6ICdmNWY1ZGMnLFxuICBiaXNxdWU6ICdmZmU0YzQnLFxuICBibGFjazogJzAnLFxuICBibGFuS2VkT21vbmQ6ICdmZmViY2QnLFxuICBYZTogJ2ZmJyxcbiAgWGV2aVRldDogJzhhMmJlMicsXG4gIGJQd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYU10WGU6ICc1ZjllYTAnLFxuICBLYXJ0WXVzZTogJzdmZmYwMCcsXG4gIEtvY1RhdGU6ICdkMjY5MWUnLFxuICBjU086ICdmZjdmNTAnLFxuICBjU25mbG93ZXJYZTogJzY0OTVlZCcsXG4gIGNTbnNpbGs6ICdmZmY4ZGMnLFxuICBjcmltc29uOiAnZGMxNDNjJyxcbiAgY3lhbjogJ2ZmZmYnLFxuICB4WGU6ICc4YicsXG4gIHhjeWFuOiAnOGI4YicsXG4gIHhnVE1uUGQ6ICdiODg2MGInLFxuICB4V2F5OiAnYTlhOWE5JyxcbiAgeGdZRjogJzY0MDAnLFxuICB4Z1l5OiAnYTlhOWE5JyxcbiAgeGtoYWtpOiAnYmRiNzZiJyxcbiAgeG1hZ0Z0YTogJzhiMDA4YicsXG4gIHhUaXZlZ1lGOiAnNTU2YjJmJyxcbiAgeFNhbmdlOiAnZmY4YzAwJyxcbiAgeFNjRWQ6ICc5OTMyY2MnLFxuICB4WWQ6ICc4YjAwMDAnLFxuICB4c09tb246ICdlOTk2N2EnLFxuICB4c0hnWUY6ICc4ZmJjOGYnLFxuICB4VVhlOiAnNDgzZDhiJyxcbiAgeFVXYXk6ICcyZjRmNGYnLFxuICB4VWdZeTogJzJmNGY0ZicsXG4gIHhRZTogJ2NlZDEnLFxuICB4dmlUZXQ6ICc5NDAwZDMnLFxuICBkQXBwUms6ICdmZjE0OTMnLFxuICBkQXBza3lYZTogJ2JmZmYnLFxuICBkaW1XYXk6ICc2OTY5NjknLFxuICBkaW1nWXk6ICc2OTY5NjknLFxuICBkb2RnZXJYZTogJzFlOTBmZicsXG4gIGZpWWJyaWNrOiAnYjIyMjIyJyxcbiAgZmxTT3dFdGU6ICdmZmZhZjAnLFxuICBmb1lzdFdBbjogJzIyOGIyMicsXG4gIGZ1S3NpYTogJ2ZmMDBmZicsXG4gIGdhUnNiU286ICdkY2RjZGMnLFxuICBnaG9zdHdFdGU6ICdmOGY4ZmYnLFxuICBnVGQ6ICdmZmQ3MDAnLFxuICBnVE1uUGQ6ICdkYWE1MjAnLFxuICBXYXk6ICc4MDgwODAnLFxuICBnWUY6ICc4MDAwJyxcbiAgZ1lGTHc6ICdhZGZmMmYnLFxuICBnWXk6ICc4MDgwODAnLFxuICBob25leU13OiAnZjBmZmYwJyxcbiAgaG90cFJrOiAnZmY2OWI0JyxcbiAgUmRpYW5ZZDogJ2NkNWM1YycsXG4gIFJkaWdvOiAnNGIwMDgyJyxcbiAgaXZTeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2Rk1yOiAnZTZlNmZhJyxcbiAgbGF2Rk1yWHNoOiAnZmZmMGY1JyxcbiAgbGF3bmdZRjogJzdjZmMwMCcsXG4gIE5tb25jRWZmb246ICdmZmZhY2QnLFxuICBaWGU6ICdhZGQ4ZTYnLFxuICBaY1NPOiAnZjA4MDgwJyxcbiAgWmN5YW46ICdlMGZmZmYnLFxuICBaZ1RNblBkTHc6ICdmYWZhZDInLFxuICBaV2F5OiAnZDNkM2QzJyxcbiAgWmdZRjogJzkwZWU5MCcsXG4gIFpnWXk6ICdkM2QzZDMnLFxuICBacFJrOiAnZmZiNmMxJyxcbiAgWnNPbW9uOiAnZmZhMDdhJyxcbiAgWnNIZ1lGOiAnMjBiMmFhJyxcbiAgWnNreVhlOiAnODdjZWZhJyxcbiAgWlVXYXk6ICc3Nzg4OTknLFxuICBaVWdZeTogJzc3ODg5OScsXG4gIFpzdEFsWGU6ICdiMGM0ZGUnLFxuICBaTHc6ICdmZmZmZTAnLFxuICBsaW1lOiAnZmYwMCcsXG4gIGxpbWVnWUY6ICczMmNkMzInLFxuICBsUkY6ICdmYWYwZTYnLFxuICBtYWdGdGE6ICdmZjAwZmYnLFxuICBtYVBvbjogJzgwMDAwMCcsXG4gIFZhcXVhbWFyUmU6ICc2NmNkYWEnLFxuICBWWGU6ICdjZCcsXG4gIFZTY0VkOiAnYmE1NWQzJyxcbiAgVnB1cnBOOiAnOTM3MGRiJyxcbiAgVnNIZ1lGOiAnM2NiMzcxJyxcbiAgVlVYZTogJzdiNjhlZScsXG4gIFZzcHJSZ2dZRjogJ2ZhOWEnLFxuICBWUWU6ICc0OGQxY2MnLFxuICBWdmlUZXRZZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0WGU6ICcxOTE5NzAnLFxuICBtUnRjWWFtOiAnZjVmZmZhJyxcbiAgbWlzdHlQc2U6ICdmZmU0ZTEnLFxuICBtb2NjYXNSOiAnZmZlNGI1JyxcbiAgbmF2YWpvd0V0ZTogJ2ZmZGVhZCcsXG4gIG5hdnk6ICc4MCcsXG4gIFRkbGFjZTogJ2ZkZjVlNicsXG4gIFRpdmU6ICc4MDgwMDAnLFxuICBUaXZlZEJiOiAnNmI4ZTIzJyxcbiAgU2FuZ2U6ICdmZmE1MDAnLFxuICBTYW5nZVlkOiAnZmY0NTAwJyxcbiAgU2NFZDogJ2RhNzBkNicsXG4gIHBPZWdUTW5QZDogJ2VlZThhYScsXG4gIHBPZWdZRjogJzk4ZmI5OCcsXG4gIHBPZVFlOiAnYWZlZWVlJyxcbiAgcE9ldmlUZXRZZDogJ2RiNzA5MycsXG4gIHBhcGF5YXdFcDogJ2ZmZWZkNScsXG4gIHBIS3B1ZmY6ICdmZmRhYjknLFxuICBwZXJ1OiAnY2Q4NTNmJyxcbiAgcFJrOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd01yWGU6ICdiMGUwZTYnLFxuICBwdXJwTjogJzgwMDA4MCcsXG4gIFliZWNjYXB1cnBOOiAnNjYzMzk5JyxcbiAgWWQ6ICdmZjAwMDAnLFxuICBQc3licm93bjogJ2JjOGY4ZicsXG4gIFB5T1hlOiAnNDE2OWUxJyxcbiAgc2FkZE5iUHduOiAnOGI0NTEzJyxcbiAgc09tb246ICdmYTgwNzInLFxuICBzYW5keWJQd246ICdmNGE0NjAnLFxuICBzSGdZRjogJzJlOGI1NycsXG4gIHNIc2hlbGw6ICdmZmY1ZWUnLFxuICBzaUZuYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreVhlOiAnODdjZWViJyxcbiAgVVhlOiAnNmE1YWNkJyxcbiAgVVdheTogJzcwODA5MCcsXG4gIFVnWXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByUmdnWUY6ICdmZjdmJyxcbiAgc3RBbFhlOiAnNDY4MmI0JyxcbiAgdGFuOiAnZDJiNDhjJyxcbiAgdGVPOiAnODA4MCcsXG4gIHRFc3ROOiAnZDhiZmQ4JyxcbiAgdG9tYXRvOiAnZmY2MzQ3JyxcbiAgUWU6ICc0MGUwZDAnLFxuICB2aVRldDogJ2VlODJlZScsXG4gIEpIdDogJ2Y1ZGViMycsXG4gIHdFdGU6ICdmZmZmZmYnLFxuICB3RXRlc21va2U6ICdmNWY1ZjUnLFxuICBMdzogJ2ZmZmYwMCcsXG4gIEx3Z1lGOiAnOWFjZDMyJ1xufTtcbmZ1bmN0aW9uIHVucGFjaygpIHtcbiAgY29uc3QgdW5wYWNrZWQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVzJDEpO1xuICBjb25zdCB0a2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gIGxldCBpLCBqLCBrLCBvaywgbms7XG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2sgPSBuayA9IGtleXNbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IHRrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICBrID0gdGtleXNbal07XG4gICAgICBuayA9IG5rLnJlcGxhY2UoaywgbWFwW2tdKTtcbiAgICB9XG4gICAgayA9IHBhcnNlSW50KG5hbWVzJDFbb2tdLCAxNik7XG4gICAgdW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XG4gIH1cbiAgcmV0dXJuIHVucGFja2VkO1xufVxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuICBjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCByLCBnLCBiO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bN10gIT09IHIpIHtcbiAgICBjb25zdCB2ID0gK21bN107XG4gICAgYSA9IG1bOF0gPyBwMmIodikgOiBsaW0odiAqIDI1NSwgMCwgMjU1KTtcbiAgfVxuICByID0gK21bMV07XG4gIGcgPSArbVszXTtcbiAgYiA9ICttWzVdO1xuICByID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiBsaW0ociwgMCwgMjU1KSk7XG4gIGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGxpbShnLCAwLCAyNTUpKTtcbiAgYiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogbGltKGIsIDAsIDI1NSkpO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJnYlN0cmluZyh2KSB7XG4gIHJldHVybiB2ICYmIChcbiAgICB2LmEgPCAyNTVcbiAgICAgID8gYHJnYmEoJHt2LnJ9LCAke3YuZ30sICR7di5ifSwgJHtiMm4odi5hKX0pYFxuICAgICAgOiBgcmdiKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0pYFxuICApO1xufVxuY29uc3QgdG8gPSB2ID0+IHYgPD0gMC4wMDMxMzA4ID8gdiAqIDEyLjkyIDogTWF0aC5wb3codiwgMS4wIC8gMi40KSAqIDEuMDU1IC0gMC4wNTU7XG5jb25zdCBmcm9tID0gdiA9PiB2IDw9IDAuMDQwNDUgPyB2IC8gMTIuOTIgOiBNYXRoLnBvdygodiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocmdiMSwgcmdiMiwgdCkge1xuICBjb25zdCByID0gZnJvbShiMm4ocmdiMS5yKSk7XG4gIGNvbnN0IGcgPSBmcm9tKGIybihyZ2IxLmcpKTtcbiAgY29uc3QgYiA9IGZyb20oYjJuKHJnYjEuYikpO1xuICByZXR1cm4ge1xuICAgIHI6IG4yYih0byhyICsgdCAqIChmcm9tKGIybihyZ2IyLnIpKSAtIHIpKSksXG4gICAgZzogbjJiKHRvKGcgKyB0ICogKGZyb20oYjJuKHJnYjIuZykpIC0gZykpKSxcbiAgICBiOiBuMmIodG8oYiArIHQgKiAoZnJvbShiMm4ocmdiMi5iKSkgLSBiKSkpLFxuICAgIGE6IHJnYjEuYSArIHQgKiAocmdiMi5hIC0gcmdiMS5hKVxuICB9O1xufVxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuICByZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IGluZGV4X2VzbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IGluZGV4X2VzbSh2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cblxuY29uc3Qgb3ZlcnJpZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFNjb3BlJDEobm9kZSwga2V5KSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgbm9kZSA9IG5vZGVba10gfHwgKG5vZGVba10gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgc2NvcGUpLCB2YWx1ZXMpO1xuICB9XG4gIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMpIHtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuYm9yZGVyQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmNvbG9yID0gJyM2NjYnO1xuICAgIHRoaXMuZGF0YXNldHMgPSB7fTtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW8gPSAoY29udGV4dCkgPT4gY29udGV4dC5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0gW1xuICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAnbW91c2VvdXQnLFxuICAgICAgJ2NsaWNrJyxcbiAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICd0b3VjaG1vdmUnXG4gICAgXTtcbiAgICB0aGlzLmZvbnQgPSB7XG4gICAgICBmYW1pbHk6IFwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixcbiAgICAgIHNpemU6IDEyLFxuICAgICAgc3R5bGU6ICdub3JtYWwnLFxuICAgICAgbGluZUhlaWdodDogMS4yLFxuICAgICAgd2VpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmhvdmVyID0ge307XG4gICAgdGhpcy5ob3ZlckJhY2tncm91bmRDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcik7XG4gICAgdGhpcy5ob3ZlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmNvbG9yKTtcbiAgICB0aGlzLmluZGV4QXhpcyA9ICd4JztcbiAgICB0aGlzLmludGVyYWN0aW9uID0ge1xuICAgICAgbW9kZTogJ25lYXJlc3QnLFxuICAgICAgaW50ZXJzZWN0OiB0cnVlLFxuICAgICAgaW5jbHVkZUludmlzaWJsZTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5vbkhvdmVyID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xpY2sgPSBudWxsO1xuICAgIHRoaXMucGFyc2luZyA9IHRydWU7XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgdGhpcy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRydWU7XG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICB9XG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBnZXQoc2NvcGUpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gIH1cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgcm91dGUoc2NvcGUsIG5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKSB7XG4gICAgY29uc3Qgc2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgW3ByaXZhdGVOYW1lXToge1xuICAgICAgICB2YWx1ZTogc2NvcGVPYmplY3RbbmFtZV0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFNjb3BlT2JqZWN0W3RhcmdldE5hbWVdO1xuICAgICAgICAgIGlmIChpc09iamVjdChsb2NhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIGxvY2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KGxvY2FsLCB0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbnZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuICBsZXQgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddO1xuICBpZiAoIXRleHRXaWR0aCkge1xuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgfVxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuICAgIGxvbmdlc3QgPSB0ZXh0V2lkdGg7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LCBhcnJheU9mVGhpbmdzLCBjYWNoZSkge1xuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xuICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICBsZXQgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0IHx8IFtdO1xuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udDtcbiAgbGV0IGxvbmdlc3QgPSAwO1xuICBjb25zdCBpbGVuID0gYXJyYXlPZlRoaW5ncy5sZW5ndGg7XG4gIGxldCBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICBpZiAoZ2NMZW4gPiBhcnJheU9mVGhpbmdzLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgaSsrKSB7XG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XG4gICAgfVxuICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gIH1cbiAgcmV0dXJuIGxvbmdlc3Q7XG59XG5mdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpIHtcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHguc2F2ZSgpO1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgeCwgeSkge1xuICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIHcpIHtcbiAgbGV0IHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cywgd2lkdGg7XG4gIGNvbnN0IHN0eWxlID0gb3B0aW9ucy5wb2ludFN0eWxlO1xuICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuICBsZXQgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgc3dpdGNoIChzdHlsZSkge1xuICBkZWZhdWx0OlxuICAgIGlmICh3KSB7XG4gICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0cmlhbmdsZSc6XG4gICAgY3R4Lm1vdmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG4gICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgY3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgY3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWN0JzpcbiAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgY3R4LnJlY3QoeCAtIHdpZHRoLCB5IC0gc2l6ZSwgMiAqIHdpZHRoLCAyICogc2l6ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ3JlY3RSb3QnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Nyb3NzUm90JzpcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAnY3Jvc3MnOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3Rhcic6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnbGluZSc6XG4gICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAnZGFzaCc6XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgYnJlYWs7XG4gIH1cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNQb2ludEluQXJlYShwb2ludCwgYXJlYSwgbWFyZ2luKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7XG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuZnVuY3Rpb24gY2xpcEFyZWEoY3R4LCBhcmVhKSB7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB1bmNsaXBBcmVhKGN0eCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwLCBtb2RlKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgcHJldmlvdXMueSk7XG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdhZnRlcicgIT09ICEhZmxpcCkge1xuICAgIGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHByZXZpb3VzLnkpO1xuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRleHQoY3R4LCB0ZXh0LCB4LCB5LCBmb250LCBvcHRzID0ge30pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpLCBsaW5lO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuICAgIGN0eC5maWxsVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcbiAgICB5ICs9IGZvbnQubGluZUhlaWdodDtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgIGN0eC5yb3RhdGUob3B0cy5yb3RhdGlvbik7XG4gIH1cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9IG9wdHMudGV4dEJhc2VsaW5lO1xuICB9XG59XG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIC1IQUxGX1BJLCBQSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCByYWRpdXMuYm90dG9tUmlnaHQsIEhBTEZfUEksIDAsIHRydWUpO1xuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy50b3BSaWdodCwgeSArIHJhZGl1cy50b3BSaWdodCwgcmFkaXVzLnRvcFJpZ2h0LCAwLCAtSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cblxuY29uc3QgTElORV9IRUlHSFQgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcbmNvbnN0IEZPTlRfU1RZTEUgPSBuZXcgUmVnRXhwKC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvKTtcbmZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZSwgc2l6ZSkge1xuICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXNbMV0gPT09ICdub3JtYWwnKSB7XG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gIH1cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gIGNhc2UgJ3B4JzpcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNhc2UgJyUnOlxuICAgIHZhbHVlIC89IDEwMDtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuY29uc3QgbnVtYmVyT3JaZXJvID0gdiA9PiArdiB8fCAwO1xuZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0b1RSQkwodmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7dG9wOiAneScsIHJpZ2h0OiAneCcsIGJvdHRvbTogJ3knLCBsZWZ0OiAneCd9KTtcbn1cbmZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ3RvcExlZnQnLCAndG9wUmlnaHQnLCAnYm90dG9tTGVmdCcsICdib3R0b21SaWdodCddKTtcbn1cbmZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZSkge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpO1xuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gdG9Gb250KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8IGRlZmF1bHRzLmZvbnQ7XG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9ICcnO1xuICB9XG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcbiAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gIHJldHVybiBmb250O1xufVxuZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHMsIGNvbnRleHQsIGluZGV4LCBpbmZvKSB7XG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xuICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvICYmICFjYWNoZWFibGUpIHtcbiAgICAgICAgaW5mby5jYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXgsIGdyYWNlLCBiZWdpbkF0WmVybykge1xuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xuICBjb25zdCBjaGFuZ2UgPSB0b0RpbWVuc2lvbihncmFjZSwgKG1heCAtIG1pbikgLyAyKTtcbiAgY29uc3Qga2VlcFplcm8gPSAodmFsdWUsIGFkZCkgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChwYXJlbnRDb250ZXh0LCBjb250ZXh0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyA9IFsnJ10sIHJvb3RTY29wZXMgPSBzY29wZXMsIGZhbGxiYWNrLCBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF0pIHtcbiAgaWYgKCFkZWZpbmVkKGZhbGxiYWNrKSkge1xuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxuICAgIF9jYWNoZWFibGU6IHRydWUsXG4gICAgX3Njb3Blczogc2NvcGVzLFxuICAgIF9yb290U2NvcGVzOiByb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCByb290U2NvcGVzLCBmYWxsYmFjayksXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHNjb3Blc1swXSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0KHByb3h5LCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5c1xuICAgICAgICA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9IDogdW5kZWZpbmVkXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhwcm94eSwgZGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfSkge1xuICBjb25zdCB7X3NjcmlwdGFibGUgPSBkZWZhdWx0cy5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlID0gZGVmYXVsdHMuaW5kZXhhYmxlLCBfYWxsS2V5cyA9IGRlZmF1bHRzLmFsbEtleXN9ID0gcHJveHk7XG4gIHJldHVybiB7XG4gICAgYWxsS2V5czogX2FsbEtleXMsXG4gICAgc2NyaXB0YWJsZTogX3NjcmlwdGFibGUsXG4gICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxuICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpID0+IF9pbmRleGFibGVcbiAgfTtcbn1cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4LCBuYW1lKSA9PiBwcmVmaXggPyBwcmVmaXggKyBfY2FwaXRhbGl6ZShuYW1lKSA6IG5hbWU7XG5jb25zdCBuZWVkc1N1YlJlc29sdmVyID0gKHByb3AsIHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbmZ1bmN0aW9uIF9jYWNoZWQodGFyZ2V0LCBwcm9wLCByZXNvbHZlKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cbiAgY29uc3QgdmFsdWUgPSByZXNvbHZlKCk7XG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGxldCB2YWx1ZSA9IF9wcm94eVtwcm9wXTtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGRlc2NyaXB0b3JzLmlzSW5kZXhhYmxlKTtcbiAgfVxuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfc3RhY2t9ID0gdGFyZ2V0O1xuICBpZiAoX3N0YWNrLmhhcyhwcm9wKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaW9uIGRldGVjdGVkOiAnICsgQXJyYXkuZnJvbShfc3RhY2spLmpvaW4oJy0+JykgKyAnLT4nICsgcHJvcCk7XG4gIH1cbiAgX3N0YWNrLmFkZChwcm9wKTtcbiAgdmFsdWUgPSB2YWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBjcmVhdGVTdWJSZXNvbHZlcihfcHJveHkuX3Njb3BlcywgX3Byb3h5LCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBpc0luZGV4YWJsZSkge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgaWYgKGRlZmluZWQoX2NvbnRleHQuaW5kZXgpICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhmYWxsYmFjaywgcHJvcCwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5jb25zdCBnZXRTY29wZSA9IChrZXksIHBhcmVudCkgPT4ga2V5ID09PSB0cnVlID8gcGFyZW50XG4gIDogdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyByZXNvbHZlT2JqZWN0S2V5KHBhcmVudCwga2V5KSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGFkZFNjb3BlcyhzZXQsIHBhcmVudFNjb3Blcywga2V5LCBwYXJlbnRGYWxsYmFjaywgdmFsdWUpIHtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50U2NvcGVzKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBnZXRTY29wZShrZXksIHBhcmVudCk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBzZXQuYWRkKHNjb3BlKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHNjb3BlLl9mYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIGRlZmluZWQocGFyZW50RmFsbGJhY2spICYmIGtleSAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJSZXNvbHZlcihwYXJlbnRTY29wZXMsIHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IHByb3ApIHtcbiAgICBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBmYWxsYmFjaywga2V5LCB2YWx1ZSk7XG4gICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZVJlc29sdmVyKEFycmF5LmZyb20oc2V0KSwgWycnXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssXG4gICAgKCkgPT4gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSkge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHByb3h5KSB7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlKHJlYWRLZXkocHJlZml4LCBwcm9wKSwgc2NvcGVzKTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5LCBzY29wZXMpIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5mdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcbmNvbnN0IGdldFBvaW50ID0gKHBvaW50cywgaSkgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuZnVuY3Rpb24gc3BsaW5lQ3VydmUoZmlyc3RQb2ludCwgbWlkZGxlUG9pbnQsIGFmdGVyUG9pbnQsIHQpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gIGxldCBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuICBjb25zdCBmYSA9IHQgKiBzMDE7XG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcbiAgcmV0dXJuIHtcbiAgICBwcmV2aW91czoge1xuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH0sXG4gICAgbmV4dDoge1xuICAgICAgeDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICB5OiBjdXJyZW50LnkgKyBmYiAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSykge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQgfHwgIXBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgIG1LW2kgKyAxXSA9IGJldGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgfVxufVxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSyA9IEFycmF5KHBvaW50c0xlbik7XG4gIGxldCBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcbn1cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSkge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcbiAgbGV0IGluQXJlYU5leHQgPSBfaXNQb2ludEluQXJlYShwb2ludHNbMF0sIGFyZWEpO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XG4gICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICBpbkFyZWFOZXh0ID0gaSA8IGlsZW4gLSAxICYmIF9pc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0sIGFyZWEpO1xuICAgIGlmICghaW5BcmVhKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgaWYgKGluQXJlYVByZXYpIHtcbiAgICAgIHBvaW50LmNwMXggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgaWYgKGluQXJlYU5leHQpIHtcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcbiAgICAgIHBvaW50LmNwMnkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHBvaW50cywgb3B0aW9ucywgYXJlYSwgbG9vcCwgaW5kZXhBeGlzKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgY29udHJvbFBvaW50cztcbiAgaWYgKG9wdGlvbnMuc3BhbkdhcHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCkgPT4gIXB0LnNraXApO1xuICB9XG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzRG9tU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM7XG4gIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHByb3BlcnR5KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cbmNvbnN0IHBvc2l0aW9ucyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGVzLCBzdHlsZSwgc3VmZml4KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4LCB5LCB0YXJnZXQpID0+ICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgIXRhcmdldC5zaGFkb3dSb290KTtcbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKGUsIGNhbnZhcykge1xuICBjb25zdCB0b3VjaGVzID0gZS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSB0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID8gdG91Y2hlc1swXSA6IGU7XG4gIGNvbnN0IHtvZmZzZXRYLCBvZmZzZXRZfSA9IHNvdXJjZTtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZXZ0LCBjaGFydCkge1xuICBpZiAoJ25hdGl2ZScgaW4gZXZ0KSB7XG4gICAgcmV0dXJuIGV2dDtcbiAgfVxuICBjb25zdCB7Y2FudmFzLCBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpb30gPSBjaGFydDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IGJvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnO1xuICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICBjb25zdCB7eCwgeSwgYm94fSA9IGdldENhbnZhc1Bvc2l0aW9uKGV2dCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5lclNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGxldCBtYXhXaWR0aCwgbWF4SGVpZ2h0O1xuICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtYXhXaWR0aDogbWF4V2lkdGggfHwgSU5GSU5JVFksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgfTtcbn1cbmNvbnN0IHJvdW5kMSA9IHYgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XG5mdW5jdGlvbiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICBjb25zdCBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4V2lkdGgsIGNhbnZhcywgJ2NsaWVudFdpZHRoJykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoc3R5bGUubWF4SGVpZ2h0LCBjYW52YXMsICdjbGllbnRIZWlnaHQnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjb250YWluZXJTaXplO1xuICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIG1hcmdpbnMud2lkdGgpO1xuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICBoZWlnaHQgPSByb3VuZDEoTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQsIGNvbnRhaW5lclNpemUubWF4SGVpZ2h0KSk7XG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJldGluYVNjYWxlKGNoYXJ0LCBmb3JjZVJhdGlvLCBmb3JjZVN0eWxlKSB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVdpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCAqIHBpeGVsUmF0aW8pO1xuICBjaGFydC5oZWlnaHQgPSBkZXZpY2VIZWlnaHQgLyBwaXhlbFJhdGlvO1xuICBjaGFydC53aWR0aCA9IGRldmljZVdpZHRoIC8gcGl4ZWxSYXRpbztcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBpZiAoY2FudmFzLnN0eWxlICYmIChmb3JjZVN0eWxlIHx8ICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkpIHtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnQuaGVpZ2h0fXB4YDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjaGFydC53aWR0aH1weGA7XG4gIH1cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59KCkpO1xuZnVuY3Rpb24gcmVhZFVzZWRTaXplKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9wb2ludEluTGluZShwMSwgcDIsIHQsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5mdW5jdGlvbiBfc3RlcHBlZEludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgOiBtb2RlID09PSAnYWZ0ZXInID8gdCA8IDEgPyBwMS55IDogcDIueVxuICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XG4gIGNvbnN0IGNwMSA9IHt4OiBwMS5jcDJ4LCB5OiBwMS5jcDJ5fTtcbiAgY29uc3QgY3AyID0ge3g6IHAyLmNwMXgsIHk6IHAyLmNwMXl9O1xuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICBjb25zdCBiID0gX3BvaW50SW5MaW5lKGNwMSwgY3AyLCB0KTtcbiAgY29uc3QgYyA9IF9wb2ludEluTGluZShjcDIsIHAyLCB0KTtcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgY29uc3QgZSA9IF9wb2ludEluTGluZShiLCBjLCB0KTtcbiAgcmV0dXJuIF9wb2ludEluTGluZShkLCBlLCB0KTtcbn1cblxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgY2FjaGVLZXkgPSBsb2NhbGUgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgbGV0IGZvcm1hdHRlciA9IGludGxDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWZvcm1hdHRlcikge1xuICAgIGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgIGludGxDYWNoZS5zZXQoY2FjaGVLZXksIGZvcm1hdHRlcik7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0sIGxvY2FsZSwgb3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYLCB3aWR0aCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBpdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgIH0sXG4gIH07XG59O1xuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4ICsgdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIF9pdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGwsIHJlY3RYLCB3aWR0aCkge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIGRpcmVjdGlvbikge1xuICBsZXQgc3R5bGUsIG9yaWdpbmFsO1xuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJyB8fCBkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xuICAgIG9yaWdpbmFsID0gW1xuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcbiAgICBdO1xuICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICBjdHgucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcmlnaW5hbCkge1xuICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBjdHgucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUZuKHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxuICAgICAgY29tcGFyZTogX2FuZ2xlRGlmZixcbiAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuICAgIGNvbXBhcmU6IChhLCBiKSA9PiBhIC0gYixcbiAgICBub3JtYWxpemU6IHggPT4geFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCB7YmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCB7c3RhcnQsIGVuZCwgbG9vcH0gPSBzZWdtZW50O1xuICBsZXQgaSwgaWxlbjtcbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBlbmQgKz0gY291bnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGlmICghYm91bmRzKSB7XG4gICAgcmV0dXJuIFtzZWdtZW50XTtcbiAgfVxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGxldCBzdWJTdGFydCA9IG51bGw7XG4gIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcbiAgY29uc3Qgc3RhcnRJc0JlZm9yZSA9ICgpID0+IGJldHdlZW4oc3RhcnRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSkgJiYgY29tcGFyZShzdGFydEJvdW5kLCBwcmV2VmFsdWUpICE9PSAwO1xuICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpID0+IGNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcbiAgY29uc3Qgc2hvdWxkU3RhcnQgPSAoKSA9PiBpbnNpZGUgfHwgc3RhcnRJc0JlZm9yZSgpO1xuICBjb25zdCBzaG91bGRTdG9wID0gKCkgPT4gIWluc2lkZSB8fCBlbmRJc0JlZm9yZSgpO1xuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZShwb2ludFtwcm9wZXJ0eV0pO1xuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xuICAgIGlmIChzdWJTdGFydCA9PT0gbnVsbCAmJiBzaG91bGRTdGFydCgpKSB7XG4gICAgICBzdWJTdGFydCA9IGNvbXBhcmUodmFsdWUsIHN0YXJ0Qm91bmQpID09PSAwID8gaSA6IHByZXY7XG4gICAgfVxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9ib3VuZFNlZ21lbnRzKGxpbmUsIGJvdW5kcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3ViID0gX2JvdW5kU2VnbWVudChzZWdtZW50c1tpXSwgbGluZS5wb2ludHMsIGJvdW5kcyk7XG4gICAgaWYgKHN1Yi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC4uLnN1Yik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGNvdW50IC0gMTtcbiAgaWYgKGxvb3AgJiYgIXNwYW5HYXBzKSB7XG4gICAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgIXBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICBzdGFydCAlPSBjb3VudDtcbiAgaWYgKGxvb3ApIHtcbiAgICBlbmQgKz0gc3RhcnQ7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG4gIGVuZCAlPSBjb3VudDtcbiAgcmV0dXJuIHtzdGFydCwgZW5kfTtcbn1cbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBsYXN0ID0gc3RhcnQ7XG4gIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgbGV0IGVuZDtcbiAgZm9yIChlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKSB7XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2VuZCAlIGNvdW50XTtcbiAgICBpZiAoY3VyLnNraXAgfHwgY3VyLnN0b3ApIHtcbiAgICAgIGlmICghcHJldi5za2lwKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IChlbmQgLSAxKSAlIGNvdW50LCBsb29wfSk7XG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogbGFzdCAlIGNvdW50LCBsb29wfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgbG9vcCA9ICEhbGluZS5fbG9vcDtcbiAgY29uc3Qge3N0YXJ0LCBlbmR9ID0gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKTtcbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBjb21wbGV0ZUxvb3ApLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgaWYgKCFzZWdtZW50T3B0aW9ucyB8fCAhc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dCB8fCAhcG9pbnRzKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xuICB9XG4gIHJldHVybiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG4gIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgaWYgKHMgPT09IGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICBsZXQgc3R5bGU7XG4gICAgZm9yIChpID0gc3RhcnQgKyAxOyBpIDw9IHNlZ21lbnQuZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICB9KSkpO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICByZXR1cm4gcHJldlN0eWxlICYmIEpTT04uc3RyaW5naWZ5KHN0eWxlKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlKTtcbn1cblxuZXhwb3J0IHsgX2lzUG9pbnRJbkFyZWEgYXMgJCwgX2ZhY3Rvcml6ZSBhcyBBLCBmaW5pdGVPckRlZmF1bHQgYXMgQiwgY2FsbGJhY2sgYXMgQywgX2FkZEdyYWNlIGFzIEQsIF9saW1pdFZhbHVlIGFzIEUsIHRvRGVncmVlcyBhcyBGLCBfbWVhc3VyZVRleHQgYXMgRywgSEFMRl9QSSBhcyBILCBfaW50MTZSYW5nZSBhcyBJLCBfYWxpZ25QaXhlbCBhcyBKLCB0b1BhZGRpbmcgYXMgSywgY2xpcEFyZWEgYXMgTCwgcmVuZGVyVGV4dCBhcyBNLCB1bmNsaXBBcmVhIGFzIE4sIHRvRm9udCBhcyBPLCBQSSBhcyBQLCBlYWNoIGFzIFEsIF90b0xlZnRSaWdodENlbnRlciBhcyBSLCBfYWxpZ25TdGFydEVuZCBhcyBTLCBUQVUgYXMgVCwgb3ZlcnJpZGVzIGFzIFUsIG1lcmdlIGFzIFYsIF9jYXBpdGFsaXplIGFzIFcsIGdldFJlbGF0aXZlUG9zaXRpb24gYXMgWCwgX3Jsb29rdXBCeUtleSBhcyBZLCBfbG9va3VwQnlLZXkgYXMgWiwgX2FycmF5VW5pcXVlIGFzIF8sIHJlc29sdmUgYXMgYSwgdG9MaW5lSGVpZ2h0IGFzIGEkLCBnZXRBbmdsZUZyb21Qb2ludCBhcyBhMCwgZ2V0TWF4aW11bVNpemUgYXMgYTEsIF9nZXRQYXJlbnROb2RlIGFzIGEyLCByZWFkVXNlZFNpemUgYXMgYTMsIHRocm90dGxlZCBhcyBhNCwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyBhcyBhNSwgX2lzRG9tU3VwcG9ydGVkIGFzIGE2LCBkZXNjcmlwdG9ycyBhcyBhNywgaXNGdW5jdGlvbiBhcyBhOCwgX2F0dGFjaENvbnRleHQgYXMgYTksIGdldFJ0bEFkYXB0ZXIgYXMgYUEsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiBhcyBhQiwgX3RleHRYIGFzIGFDLCByZXN0b3JlVGV4dERpcmVjdGlvbiBhcyBhRCwgZHJhd1BvaW50TGVnZW5kIGFzIGFFLCBub29wIGFzIGFGLCBkaXN0YW5jZUJldHdlZW5Qb2ludHMgYXMgYUcsIF9zZXRNaW5BbmRNYXhCeUtleSBhcyBhSCwgbmljZU51bSBhcyBhSSwgYWxtb3N0V2hvbGUgYXMgYUosIGFsbW9zdEVxdWFscyBhcyBhSywgX2RlY2ltYWxQbGFjZXMgYXMgYUwsIF9sb25nZXN0VGV4dCBhcyBhTSwgX2ZpbHRlckJldHdlZW4gYXMgYU4sIF9sb29rdXAgYXMgYU8sIGlzUGF0dGVybk9yR3JhZGllbnQgYXMgYVAsIGdldEhvdmVyQ29sb3IgYXMgYVEsIGNsb25lJDEgYXMgYVIsIF9tZXJnZXIgYXMgYVMsIF9tZXJnZXJJZiBhcyBhVCwgX2RlcHJlY2F0ZWQgYXMgYVUsIF9zcGxpdEtleSBhcyBhViwgdG9Gb250U3RyaW5nIGFzIGFXLCBzcGxpbmVDdXJ2ZSBhcyBhWCwgc3BsaW5lQ3VydmVNb25vdG9uZSBhcyBhWSwgZ2V0U3R5bGUgYXMgYVosIGZvbnRTdHJpbmcgYXMgYV8sIF9jcmVhdGVSZXNvbHZlciBhcyBhYSwgX2Rlc2NyaXB0b3JzIGFzIGFiLCBtZXJnZUlmIGFzIGFjLCB1aWQgYXMgYWQsIGRlYm91bmNlIGFzIGFlLCByZXRpbmFTY2FsZSBhcyBhZiwgY2xlYXJDYW52YXMgYXMgYWcsIHNldHNFcXVhbCBhcyBhaCwgX2VsZW1lbnRzRXF1YWwgYXMgYWksIF9pc0NsaWNrRXZlbnQgYXMgYWosIF9pc0JldHdlZW4gYXMgYWssIF9yZWFkVmFsdWVUb1Byb3BzIGFzIGFsLCBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyBhcyBhbSwgX2NvbXB1dGVTZWdtZW50cyBhcyBhbiwgX2JvdW5kU2VnbWVudHMgYXMgYW8sIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiBhcyBhcCwgX2JlemllckludGVycG9sYXRpb24gYXMgYXEsIF9wb2ludEluTGluZSBhcyBhciwgX3N0ZXBwZWRMaW5lVG8gYXMgYXMsIF9iZXppZXJDdXJ2ZVRvIGFzIGF0LCBkcmF3UG9pbnQgYXMgYXUsIGFkZFJvdW5kZWRSZWN0UGF0aCBhcyBhdiwgdG9UUkJMIGFzIGF3LCB0b1RSQkxDb3JuZXJzIGFzIGF4LCBfYm91bmRTZWdtZW50IGFzIGF5LCBfbm9ybWFsaXplQW5nbGUgYXMgYXosIGlzQXJyYXkgYXMgYiwgUElUQVUgYXMgYjAsIElORklOSVRZIGFzIGIxLCBSQURfUEVSX0RFRyBhcyBiMiwgUVVBUlRFUl9QSSBhcyBiMywgVFdPX1RISVJEU19QSSBhcyBiNCwgX2FuZ2xlRGlmZiBhcyBiNSwgY29sb3IgYXMgYywgZGVmYXVsdHMgYXMgZCwgZWZmZWN0cyBhcyBlLCByZXNvbHZlT2JqZWN0S2V5IGFzIGYsIGlzTnVtYmVyRmluaXRlIGFzIGcsIGNyZWF0ZUNvbnRleHQgYXMgaCwgaXNPYmplY3QgYXMgaSwgZGVmaW5lZCBhcyBqLCBpc051bGxPclVuZGVmIGFzIGssIGxpc3RlbkFycmF5RXZlbnRzIGFzIGwsIHRvUGVyY2VudGFnZSBhcyBtLCB0b0RpbWVuc2lvbiBhcyBuLCBmb3JtYXROdW1iZXIgYXMgbywgX2FuZ2xlQmV0d2VlbiBhcyBwLCBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyBhcyBxLCByZXF1ZXN0QW5pbUZyYW1lIGFzIHIsIHNpZ24gYXMgcywgdG9SYWRpYW5zIGFzIHQsIHVubGlzdGVuQXJyYXlFdmVudHMgYXMgdSwgdmFsdWVPckRlZmF1bHQgYXMgdiwgX3NjYWxlUmFuZ2VzQ2hhbmdlZCBhcyB3LCBpc051bWJlciBhcyB4LCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUgYXMgeSwgbG9nMTAgYXMgeiB9O1xuIiwiLyohXG4gKiBDaGFydC5qcyB2My45LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMiBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByIGFzIHJlcXVlc3RBbmltRnJhbWUsIGEgYXMgcmVzb2x2ZSwgZSBhcyBlZmZlY3RzLCBjIGFzIGNvbG9yLCBkIGFzIGRlZmF1bHRzLCBpIGFzIGlzT2JqZWN0LCBiIGFzIGlzQXJyYXksIHYgYXMgdmFsdWVPckRlZmF1bHQsIHUgYXMgdW5saXN0ZW5BcnJheUV2ZW50cywgbCBhcyBsaXN0ZW5BcnJheUV2ZW50cywgZiBhcyByZXNvbHZlT2JqZWN0S2V5LCBnIGFzIGlzTnVtYmVyRmluaXRlLCBoIGFzIGNyZWF0ZUNvbnRleHQsIGogYXMgZGVmaW5lZCwgcyBhcyBzaWduLCBrIGFzIGlzTnVsbE9yVW5kZWYsIF8gYXMgX2FycmF5VW5pcXVlLCB0IGFzIHRvUmFkaWFucywgbSBhcyB0b1BlcmNlbnRhZ2UsIG4gYXMgdG9EaW1lbnNpb24sIFQgYXMgVEFVLCBvIGFzIGZvcm1hdE51bWJlciwgcCBhcyBfYW5nbGVCZXR3ZWVuLCBIIGFzIEhBTEZfUEksIFAgYXMgUEksIHEgYXMgX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIHcgYXMgX3NjYWxlUmFuZ2VzQ2hhbmdlZCwgeCBhcyBpc051bWJlciwgeSBhcyBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUsIHogYXMgbG9nMTAsIEEgYXMgX2ZhY3Rvcml6ZSwgQiBhcyBmaW5pdGVPckRlZmF1bHQsIEMgYXMgY2FsbGJhY2ssIEQgYXMgX2FkZEdyYWNlLCBFIGFzIF9saW1pdFZhbHVlLCBGIGFzIHRvRGVncmVlcywgRyBhcyBfbWVhc3VyZVRleHQsIEkgYXMgX2ludDE2UmFuZ2UsIEogYXMgX2FsaWduUGl4ZWwsIEsgYXMgdG9QYWRkaW5nLCBMIGFzIGNsaXBBcmVhLCBNIGFzIHJlbmRlclRleHQsIE4gYXMgdW5jbGlwQXJlYSwgTyBhcyB0b0ZvbnQsIFEgYXMgZWFjaCwgUiBhcyBfdG9MZWZ0UmlnaHRDZW50ZXIsIFMgYXMgX2FsaWduU3RhcnRFbmQsIFUgYXMgb3ZlcnJpZGVzLCBWIGFzIG1lcmdlLCBXIGFzIF9jYXBpdGFsaXplLCBYIGFzIGdldFJlbGF0aXZlUG9zaXRpb24sIFkgYXMgX3Jsb29rdXBCeUtleSwgWiBhcyBfbG9va3VwQnlLZXksICQgYXMgX2lzUG9pbnRJbkFyZWEsIGEwIGFzIGdldEFuZ2xlRnJvbVBvaW50LCBhMSBhcyBnZXRNYXhpbXVtU2l6ZSwgYTIgYXMgX2dldFBhcmVudE5vZGUsIGEzIGFzIHJlYWRVc2VkU2l6ZSwgYTQgYXMgdGhyb3R0bGVkLCBhNSBhcyBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCBhNiBhcyBfaXNEb21TdXBwb3J0ZWQsIGE3IGFzIGRlc2NyaXB0b3JzLCBhOCBhcyBpc0Z1bmN0aW9uLCBhOSBhcyBfYXR0YWNoQ29udGV4dCwgYWEgYXMgX2NyZWF0ZVJlc29sdmVyLCBhYiBhcyBfZGVzY3JpcHRvcnMsIGFjIGFzIG1lcmdlSWYsIGFkIGFzIHVpZCwgYWUgYXMgZGVib3VuY2UsIGFmIGFzIHJldGluYVNjYWxlLCBhZyBhcyBjbGVhckNhbnZhcywgYWggYXMgc2V0c0VxdWFsLCBhaSBhcyBfZWxlbWVudHNFcXVhbCwgYWogYXMgX2lzQ2xpY2tFdmVudCwgYWsgYXMgX2lzQmV0d2VlbiwgYWwgYXMgX3JlYWRWYWx1ZVRvUHJvcHMsIGFtIGFzIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLCBhbiBhcyBfY29tcHV0ZVNlZ21lbnRzLCBhbyBhcyBfYm91bmRTZWdtZW50cywgYXAgYXMgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uLCBhcSBhcyBfYmV6aWVySW50ZXJwb2xhdGlvbiwgYXIgYXMgX3BvaW50SW5MaW5lLCBhcyBhcyBfc3RlcHBlZExpbmVUbywgYXQgYXMgX2JlemllckN1cnZlVG8sIGF1IGFzIGRyYXdQb2ludCwgYXYgYXMgYWRkUm91bmRlZFJlY3RQYXRoLCBhdyBhcyB0b1RSQkwsIGF4IGFzIHRvVFJCTENvcm5lcnMsIGF5IGFzIF9ib3VuZFNlZ21lbnQsIGF6IGFzIF9ub3JtYWxpemVBbmdsZSwgYUEgYXMgZ2V0UnRsQWRhcHRlciwgYUIgYXMgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLCBhQyBhcyBfdGV4dFgsIGFEIGFzIHJlc3RvcmVUZXh0RGlyZWN0aW9uLCBhRSBhcyBkcmF3UG9pbnRMZWdlbmQsIGFGIGFzIG5vb3AsIGFHIGFzIGRpc3RhbmNlQmV0d2VlblBvaW50cywgYUggYXMgX3NldE1pbkFuZE1heEJ5S2V5LCBhSSBhcyBuaWNlTnVtLCBhSiBhcyBhbG1vc3RXaG9sZSwgYUsgYXMgYWxtb3N0RXF1YWxzLCBhTCBhcyBfZGVjaW1hbFBsYWNlcywgYU0gYXMgX2xvbmdlc3RUZXh0LCBhTiBhcyBfZmlsdGVyQmV0d2VlbiwgYU8gYXMgX2xvb2t1cCB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanMnO1xuZXhwb3J0IHsgZCBhcyBkZWZhdWx0cyB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanMnO1xuXG5jbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xuICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG52YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBjb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICBkZWxheTogdW5kZWZpbmVkLFxuICBkdXJhdGlvbjogMTAwMCxcbiAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgZm46IHVuZGVmaW5lZCxcbiAgZnJvbTogdW5kZWZpbmVkLFxuICBsb29wOiB1bmRlZmluZWQsXG4gIHRvOiB1bmRlZmluZWQsXG4gIHR5cGU6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG59KTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgfSxcbiAgbnVtYmVyczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgfSxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG59KTtcbmRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gIGFjdGl2ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMFxuICAgIH1cbiAgfSxcbiAgcmVzaXplOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMFxuICAgIH1cbiAgfSxcbiAgc2hvdzoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgaGlkZToge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBmbjogdiA9PiB2IHwgMFxuICAgICAgfSxcbiAgICB9XG4gIH1cbn0pO1xuY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzTnVtYmVyRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTtcbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcbmNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgbWV0YS5fcGFyc2VkID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG4gICAgICAgIGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIG1ldGEuZGF0YXNldCA9IG5ldyB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgfVxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcbiAgICBpZiAoc3RhY2tDaGFuZ2VkIHx8IG9sZFN0YWNrZWQgIT09IG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBsZXQgc29ydGVkID0gc3RhcnQgPT09IDAgJiYgY291bnQgPT09IGRhdGEubGVuZ3RoID8gdHJ1ZSA6IG1ldGEuX3NvcnRlZDtcbiAgICBsZXQgcHJldiA9IHN0YXJ0ID4gMCAmJiBtZXRhLl9wYXJzZWRbc3RhcnQgLSAxXTtcbiAgICBsZXQgaSwgY3VyLCBwYXJzZWQ7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG4gICAgaWYgKF9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXVxuICAgIH07XG4gICAgcmV0dXJuIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBtZXRhLmluZGV4LCB7bW9kZX0pO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHN0YWNrICYmIHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdO1xuICAgIGlmIChzdGFjayAmJiB2YWx1ZXMpIHtcbiAgICAgIHN0YWNrLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHZhbHVlID0gYXBwbHlTdGFjayhzdGFjaywgcGFyc2VkVmFsdWUsIHRoaXMuX2NhY2hlZE1ldGEuaW5kZXgpO1xuICAgIH1cbiAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIHZhbHVlKTtcbiAgfVxuICBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgX3BhcnNlZCA9IG1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCBzb3J0ZWQgPSBtZXRhLl9zb3J0ZWQgJiYgc2NhbGUgPT09IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IGlsZW4gPSBfcGFyc2VkLmxlbmd0aDtcbiAgICBjb25zdCBvdGhlclNjYWxlID0gdGhpcy5fZ2V0T3RoZXJTY2FsZShzY2FsZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjYW5TdGFjaywgbWV0YSwgdGhpcy5jaGFydCk7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBjb25zdCB7bWluOiBvdGhlck1pbiwgbWF4OiBvdGhlck1heH0gPSBnZXRVc2VyQm91bmRzKG90aGVyU2NhbGUpO1xuICAgIGxldCBpLCBwYXJzZWQ7XG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc051bWJlckZpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdmFsdWUgPSBwYXJzZWRbaV1bc2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge31cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuICAgIGlmIChtZXRhLmRhdGFzZXQpIHtcbiAgICAgIG1ldGEuZGF0YXNldC5kcmF3KGN0eCwgYXJlYSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuICBnZXRTdHlsZShpbmRleCwgYWN0aXZlKSB7XG4gICAgY29uc3QgbW9kZSA9IGFjdGl2ZSA/ICdhY3RpdmUnIDogJ2RlZmF1bHQnO1xuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldFxuICAgICAgPyB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSlcbiAgICAgIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgY29udGV4dDtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dCA9IGVsZW1lbnQuJGNvbnRleHQgfHxcbiAgICAgICAgKGVsZW1lbnQuJGNvbnRleHQgPSBjcmVhdGVEYXRhQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIGVsZW1lbnQpKTtcbiAgICAgIGNvbnRleHQucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgY29udGV4dC5yYXcgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YUluZGV4ID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzLiRjb250ZXh0IHx8XG4gICAgICAgICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlRGF0YXNldENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMuaW5kZXgpKTtcbiAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH1cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICBjb25zdCBjb250ZXh0ID0gKCkgPT4gdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZy5yZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoY2xvbmVJZk5vdFNoYXJlZCh2YWx1ZXMsIHNoYXJpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuICBpbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gIH1cbiAgX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpIHtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zID0gdGhpcy5fc2hhcmVkT3B0aW9ucztcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHx8IChzaGFyZWRPcHRpb25zICE9PSBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyk7XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gICAgcmV0dXJuIHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc307XG4gIH1cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgbmV3T3B0aW9ucykge1xuICAgIGlmIChzaGFyZWRPcHRpb25zICYmICFpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSkudXBkYXRlKHNoYXJlZE9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIHRydWUpO1xuICB9XG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgY29uc3QgbnVtTWV0YSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGVsZW1lbnQsIHN0YXJ0LCBjb3VudCwgbW9kZSkge31cbiAgX3JlbW92ZUVsZW1lbnRzKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBjb25zdCByZW1vdmVkID0gbWV0YS5fcGFyc2VkLnNwbGljZShzdGFydCwgY291bnQpO1xuICAgICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSwgcmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgfVxuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG4gIF9vbkRhdGFQdXNoKCkge1xuICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnRdKTtcbiAgfVxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG4gIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgc3RhcnQsIGNvdW50XSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgaWYgKG5ld0NvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgc3RhcnQsIG5ld0NvdW50XSk7XG4gICAgfVxuICB9XG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbkRhdGFzZXRDb250cm9sbGVyLmRlZmF1bHRzID0ge307XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICB9XG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSkge1xuICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICByZXR1cm4gbWluO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge3RvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgbGVmdDogdHJ1ZX07XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cbmNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpbmRleCwgX2NhY2hlZE1ldGE6IHt2U2NhbGV9fSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucztcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgb3B0aW9ucywgcnVsZXIucmF0aW8pO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlZCAmJiBwYXJzZWRbbWV0YS52U2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG4gICAgICA6IC0xO1xuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuICBfZ2V0UnVsZXIoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgcGl4ZWxzLFxuICAgICAgc3RhcnQ6IGlTY2FsZS5fc3RhcnRQaXhlbCxcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBpU2NhbGUsXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IHt2U2NhbGUsIF9zdGFja2VkfSwgb3B0aW9uczoge2Jhc2U6IGJhc2VWYWx1ZSwgbWluQmFyTGVuZ3RofX0gPSB0aGlzO1xuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkW3ZTY2FsZS5heGlzXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgbGV0IGhlYWQsIHNpemU7XG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICB2YWx1ZSA9IGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGxlbmd0aCA9IGN1c3RvbS5iYXJFbmQgLSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBpZiAodmFsdWUgIT09IDAgJiYgc2lnbih2YWx1ZSkgIT09IHNpZ24oY3VzdG9tLmJhckVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gYmFzZTtcbiAgICB9XG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMCk7XG4gICAgICBjb25zdCBlbmRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMSk7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBiYXNlID0gTWF0aC5tYXgoTWF0aC5taW4oYmFzZSwgbWF4KSwgbWluKTtcbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzaXplLFxuICAgICAgYmFzZSxcbiAgICAgIGhlYWQsXG4gICAgICBjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KTtcbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5CYXJDb250cm9sbGVyLmlkID0gJ2Jhcic7XG5CYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgYmFyUGVyY2VudGFnZTogMC45LFxuICBncm91cGVkOiB0cnVlLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgfVxuICB9XG59O1xuQmFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBtZXRhLmxhYmVsLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG5CdWJibGVDb250cm9sbGVyLmlkID0gJ2J1YmJsZSc7XG5CdWJibGVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgfVxuICB9XG59O1xuQnViYmxlQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5jbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7fVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuRG91Z2hudXRDb250cm9sbGVyLmlkID0gJ2RvdWdobnV0JztcbkRvdWdobnV0Q29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgfSxcbiAgfSxcbiAgY3V0b3V0OiAnNTAlJyxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJScsXG4gIHNwYWNpbmc6IDAsXG4gIGluZGV4QXhpczogJ3InLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgICBsZXQgZGF0YUxhYmVsID0gdG9vbHRpcEl0ZW0ubGFiZWw7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZGF0YUxhYmVsKSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XG4gICAgICAgICAgICBkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGFMYWJlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgIG9wdGlvbnNcbiAgICB9LCBtb2RlKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG5MaW5lQ29udHJvbGxlci5pZCA9ICdsaW5lJztcbkxpbmVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxufTtcbkxpbmVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgIH0sXG4gIH1cbn07XG5cbmNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGFyY3MgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiB0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aDtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpLnIpIDogMDtcbiAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG5Qb2xhckFyZWFDb250cm9sbGVyLmlkID0gJ3BvbGFyQXJlYSc7XG5Qb2xhckFyZWFDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICB9LFxuICB9LFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc3RhcnRBbmdsZTogMCxcbn07XG5Qb2xhckFyZWFDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNoYXJ0LmRhdGEubGFiZWxzW2NvbnRleHQuZGF0YUluZGV4XSArICc6ICcgKyBjb250ZXh0LmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBwb2ludExhYmVsczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xufVxuUGllQ29udHJvbGxlci5pZCA9ICdwaWUnO1xuUGllQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgY3V0b3V0OiAwLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJ1xufTtcblxuY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgdlNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdGhpcy5nZXRQYXJzZWQoaSkucik7XG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG59XG5SYWRhckNvbnRyb2xsZXIuaWQgPSAncmFkYXInO1xuUmFkYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIGVsZW1lbnRzOiB7XG4gICAgbGluZToge1xuICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgIH1cbiAgfSxcbn07XG5SYWRhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gIH1cbiAgZ2V0UHJvcHMocHJvcHMsIGZpbmFsKSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5FbGVtZW50LmRlZmF1bHRzID0ge307XG5FbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcbiAgfSxcbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgbGV0IG5vdGF0aW9uO1xuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTtcbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgbm90YXRpb24gPSAnc2NpZW50aWZpYyc7XG4gICAgICB9XG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG4gIGxvZ2FyaXRobWljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSk7XG4gICAgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1KSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxudmFyIFRpY2tzID0ge2Zvcm1hdHRlcnN9O1xuXG5kZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICBkaXNwbGF5OiB0cnVlLFxuICBvZmZzZXQ6IGZhbHNlLFxuICByZXZlcnNlOiBmYWxzZSxcbiAgYmVnaW5BdFplcm86IGZhbHNlLFxuICBib3VuZHM6ICd0aWNrcycsXG4gIGdyYWNlOiAwLFxuICBncmlkOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgZHJhd0JvcmRlcjogdHJ1ZSxcbiAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXG4gICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcbiAgICBib3JkZXJXaWR0aDogMVxuICB9LFxuICB0aXRsZToge1xuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIHRleHQ6ICcnLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogNCxcbiAgICAgIGJvdHRvbTogNFxuICAgIH1cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgbWlycm9yOiBmYWxzZSxcbiAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgdGV4dFN0cm9rZUNvbG9yOiAnJyxcbiAgICBwYWRkaW5nOiAzLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgYXV0b1NraXA6IHRydWUsXG4gICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICBtaW5vcjoge30sXG4gICAgbWFqb3I6IHt9LFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBjcm9zc0FsaWduOiAnbmVhcicsXG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gIH1cbn0pO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdib3JkZXJDb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZScsIHtcbiAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ3RpY2tCb3JkZXJEYXNoJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgX2ZhbGxiYWNrOiAnc2NhbGUnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnLFxufSk7XG5cbmZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IHRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gIGNvbnN0IG5ld1RpY2tzID0gW107XG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyBNYXRoLnJvdW5kKChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpKSA6IG51bGw7XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JJbmRpY2VzW2ldLCBtYWpvckluZGljZXNbaSArIDFdKTtcbiAgICB9XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gIHJldHVybiBuZXdUaWNrcztcbn1cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cbiAgbmV4dCA9IHN0YXJ0O1xuICB3aGlsZSAobmV4dCA8IDApIHtcbiAgICBjb3VudCsrO1xuICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgfVxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGksIGRpZmY7XG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02O1xuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhbGVDb250ZXh0KHBhcmVudCwgc2NhbGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgc2NhbGUsXG4gICAgdHlwZTogJ3NjYWxlJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY2ZnLmlkO1xuICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmN0eCA9IGNmZy5jdHg7XG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gMDtcbiAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlck1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl91c2VyTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSAwO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gMDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMubWluKTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLm1heCk7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1pbik7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1heCk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIHJldHVybiByYXc7XG4gIH1cbiAgZ2V0VXNlckJvdW5kcygpIHtcbiAgICBsZXQge191c2VyTWluLCBfdXNlck1heCwgX3N1Z2dlc3RlZE1pbiwgX3N1Z2dlc3RlZE1heH0gPSB0aGlzO1xuICAgIF91c2VyTWluID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF91c2VyTWF4ID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWF4ID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBfc3VnZ2VzdGVkTWluKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcbiAgICAgIG1pbkRlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWluKSxcbiAgICAgIG1heERlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWF4KVxuICAgIH07XG4gIH1cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcmFuZ2U7XG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIGNhblN0YWNrKTtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICB9O1xuICB9XG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuICAgIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gdGhpcy53aWR0aCArIG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHRcbiAgICAgIDogdGhpcy5oZWlnaHQgKyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tO1xuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuICAgIHRoaXMudGlja3MgPSB0aGlzLmJ1aWxkVGlja3MoKSB8fCBbXTtcbiAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuICAgIGNvbnN0IHNhbXBsaW5nRW5hYmxlZCA9IHNhbXBsZVNpemUgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGhpcy50aWNrcywgc2FtcGxlU2l6ZSkgOiB0aGlzLnRpY2tzKTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgKHRpY2tPcHRzLmF1dG9Ta2lwIHx8IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy50aWNrcyA9IGF1dG9Ta2lwKHRoaXMsIHRoaXMudGlja3MpO1xuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICB0aGlzLmFmdGVyQXV0b1NraXAoKTtcbiAgICB9XG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgdGhpcy5maXQoKTtcbiAgICB0aGlzLmFmdGVyRml0KCk7XG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLmJvdHRvbTtcbiAgICAgIHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsYmFjayh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHt9XG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtaW5TaXplLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSB0aGlzLmdldFBpeGVsRm9yVGljaygwKSAtIHRoaXMubGVmdDtcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgbGV0IHBhZGRpbmdSaWdodCA9IDA7XG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IHNpbiAqIGZpcnN0LmhlaWdodDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IHRoaXMuX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCB0aWNrcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWxTaXplcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCkge1xuICAgIGNvbnN0IHtjdHgsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXN9ID0gdGhpcztcbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBuZXN0ZWRMYWJlbCA9IGxhYmVsW2pdO1xuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgdmFsdWVBdCA9IChpZHgpID0+ICh7d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsIGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgfVxuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgfVxuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcbiAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9ufSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhbGlnbmVkTGluZVZhbHVlID0gX2FsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcbiAgICB9XG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuICAgICAgICBpZiAodGV4dEFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBsZXQgYmFja2Ryb3A7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcbiAgICAgICAgbGV0IHRvcCA9IHkgKyB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSB4IC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgIGJhY2tkcm9wLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgYWxpZ24gPSAnaW5uZXInO1xuICAgIH1cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgZHJhd0xpbmUgPSAocDEsIHAyLCBzdHlsZSkgPT4ge1xuICAgICAgaWYgKCFzdHlsZS53aWR0aCB8fCAhc3R5bGUuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHN0eWxlLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoZ3JpZC5kcmF3T25DaGFydEFyZWEpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLngyLCB5OiBpdGVtLnkyfSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGdyaWQuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmJvcmRlckNvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgaWYgKGl0ZW0uYmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGl0ZW0uYmFja2Ryb3AuY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpdGVtLmJhY2tkcm9wLmxlZnQsIGl0ZW0uYmFja2Ryb3AudG9wLCBpdGVtLmJhY2tkcm9wLndpZHRoLCBpdGVtLmJhY2tkcm9wLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBsZXQgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gIH1cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBneiArIDEsXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgIHJldHVybiB0b0ZvbnQob3B0cy5mb250KTtcbiAgfVxuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuXG5jbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlICsgJy4nICsgaWQ7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG5cbmNsYXNzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KERhdGFzZXRDb250cm9sbGVyLCAnZGF0YXNldHMnLCB0cnVlKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFR5cGVkUmVnaXN0cnkoRWxlbWVudCwgJ2VsZW1lbnRzJyk7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFR5cGVkUmVnaXN0cnkoU2NhbGUsICdzY2FsZXMnKTtcbiAgICB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICBhZGRQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuICBnZXRTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgfVxuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgfVxuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxufVxudmFyIHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KCk7XG5cbmNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge3Nob3dMaW5lfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG4gICAgc3VwZXIuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuU2NhdHRlckNvbnRyb2xsZXIuaWQgPSAnc2NhdHRlcic7XG5TY2F0dGVyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogZmFsc2UsXG4gIGZpbGw6IGZhbHNlXG59O1xuU2NhdHRlckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBpbnRlcmFjdGlvbjoge1xuICAgIG1vZGU6ICdwb2ludCdcbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gJygnICsgaXRlbS5sYWJlbCArICcsICcgKyBpdGVtLmZvcm1hdHRlZFZhbHVlICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb250cm9sbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXG5CdWJibGVDb250cm9sbGVyOiBCdWJibGVDb250cm9sbGVyLFxuRG91Z2hudXRDb250cm9sbGVyOiBEb3VnaG51dENvbnRyb2xsZXIsXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXG5Qb2xhckFyZWFDb250cm9sbGVyOiBQb2xhckFyZWFDb250cm9sbGVyLFxuUGllQ29udHJvbGxlcjogUGllQ29udHJvbGxlcixcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxuU2NhdHRlckNvbnRyb2xsZXI6IFNjYXR0ZXJDb250cm9sbGVyXG59KTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuY2xhc3MgRGF0ZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuICBpbml0KGNoYXJ0T3B0aW9ucykge31cbiAgZm9ybWF0cygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBwYXJzZSh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZm9ybWF0KHRpbWVzdGFtcCwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgYWRkKHRpbWVzdGFtcCwgYW1vdW50LCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZGlmZihhLCBiLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgc3RhcnRPZih0aW1lc3RhbXAsIHVuaXQsIHdlZWtkYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBlbmRPZih0aW1lc3RhbXAsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuRGF0ZUFkYXB0ZXIub3ZlcnJpZGUgPSBmdW5jdGlvbihtZW1iZXJzKSB7XG4gIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCBtZW1iZXJzKTtcbn07XG52YXIgYWRhcHRlcnMgPSB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlclxufTtcblxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICByZXR1cm4gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5mdW5jdGlvbiBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHBvaW50SW5BcmVhID0gISFpbmNsdWRlSW52aXNpYmxlIHx8IGNoYXJ0LmlzUG9pbnRJbkFyZWEoY2VudGVyKTtcbiAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XG4gICAgPyBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbn1cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG52YXIgSW50ZXJhY3Rpb24gPSB7XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcbiAgbW9kZXM6IHtcbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG4gICAgbmVhcmVzdChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGFycmF5LCBheGlzKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiBTVEFUSUNfUE9TSVRJT05TLmluZGV4T2Yodi5wb3MpID09PSAtMSAmJiB2LmJveC5heGlzID09PSBheGlzKTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGJveCA9IGJveGVzW2ldO1xuICAgICh7cG9zaXRpb246IHBvcywgb3B0aW9uczoge3N0YWNrLCBzdGFja1dlaWdodCA9IDF9fSA9IGJveCk7XG4gICAgbGF5b3V0Qm94ZXMucHVzaCh7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGJveCxcbiAgICAgIHBvcyxcbiAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcbiAgICAgIHdlaWdodDogYm94LndlaWdodCxcbiAgICAgIHN0YWNrOiBzdGFjayAmJiAocG9zICsgc3RhY2spLFxuICAgICAgc3RhY2tXZWlnaHRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGF5b3V0Qm94ZXM7XG59XG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcbiAgY29uc3Qgc3RhY2tzID0gYnVpbGRTdGFja3MobGF5b3V0cyk7XG4gIGNvbnN0IHt2Qm94TWF4V2lkdGgsIGhCb3hNYXhIZWlnaHR9ID0gcGFyYW1zO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBsYXlvdXRzW2ldO1xuICAgIGNvbnN0IHtmdWxsU2l6ZX0gPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja107XG4gICAgY29uc3QgZmFjdG9yID0gc3RhY2sgJiYgbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0O1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgbGF5b3V0LndpZHRoID0gZmFjdG9yID8gZmFjdG9yICogdkJveE1heFdpZHRoIDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGhCb3hNYXhIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dC53aWR0aCA9IHZCb3hNYXhXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBmYWN0b3IgPyBmYWN0b3IgKiBoQm94TWF4SGVpZ2h0IDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xuICByZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBpZiAoIWlzT2JqZWN0KHBvcykpIHtcbiAgICBpZiAobGF5b3V0LnNpemUpIHtcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpKTtcbiAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpKTtcbiAgY29uc3Qgd2lkdGhDaGFuZ2VkID0gbmV3V2lkdGggIT09IGNoYXJ0QXJlYS53O1xuICBjb25zdCBoZWlnaHRDaGFuZ2VkID0gbmV3SGVpZ2h0ICE9PSBjaGFydEFyZWEuaDtcbiAgY2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcbiAgY2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcbiAgY2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG4gIHVwZGF0ZVBvcygncmlnaHQnKTtcbiAgdXBkYXRlUG9zKCdib3R0b20nKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuICByZXR1cm4gaG9yaXpvbnRhbFxuICAgID8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxuICAgIDogbWFyZ2luRm9yUG9zaXRpb25zKFsndG9wJywgJ2JvdHRvbSddKTtcbn1cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcbiAgICBib3gudXBkYXRlKFxuICAgICAgbGF5b3V0LndpZHRoIHx8IGNoYXJ0QXJlYS53LFxuICAgICAgbGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCxcbiAgICAgIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcbiAgICApO1xuICAgIGNvbnN0IHtzYW1lLCBvdGhlcn0gPSB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcyk7XG4gICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcbiAgICBpZiAoIWJveC5mdWxsU2l6ZSkge1xuICAgICAgcmVmaXRCb3hlcy5wdXNoKGxheW91dCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHVzZXJQYWRkaW5nID0gcGFyYW1zLnBhZGRpbmc7XG4gIGxldCB7eCwgeX0gPSBjaGFydEFyZWE7XG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cbmRlZmF1bHRzLnNldCgnbGF5b3V0Jywge1xuICBhdXRvUGFkZGluZzogdHJ1ZSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9XG59KTtcbnZhciBsYXlvdXRzID0ge1xuICBhZGRCb3goY2hhcnQsIGl0ZW0pIHtcbiAgICBpZiAoIWNoYXJ0LmJveGVzKSB7XG4gICAgICBjaGFydC5ib3hlcyA9IFtdO1xuICAgIH1cbiAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgfSxcbiAgcmVtb3ZlQm94KGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSxcbiAgY29uZmlndXJlKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XG4gICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgfSxcbiAgdXBkYXRlKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKGNoYXJ0Lm9wdGlvbnMubGF5b3V0LnBhZGRpbmcpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBwYWRkaW5nLndpZHRoLCAwKTtcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgLSBwYWRkaW5nLmhlaWdodCwgMCk7XG4gICAgY29uc3QgYm94ZXMgPSBidWlsZExheW91dEJveGVzKGNoYXJ0LmJveGVzKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XG4gICAgY29uc3QgaG9yaXpvbnRhbEJveGVzID0gYm94ZXMuaG9yaXpvbnRhbDtcbiAgICBlYWNoKGNoYXJ0LmJveGVzLCBib3ggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJveC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB2aXNpYmxlVmVydGljYWxCb3hDb3VudCA9IHZlcnRpY2FsQm94ZXMucmVkdWNlKCh0b3RhbCwgd3JhcCkgPT5cbiAgICAgIHdyYXAuYm94Lm9wdGlvbnMgJiYgd3JhcC5ib3gub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSA/IHRvdGFsIDogdG90YWwgKyAxLCAwKSB8fCAxO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XG4gICAgZml0Qm94ZXMoYm94ZXMuZnVsbFNpemUsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XG4gICAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICB9XG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5yaWdodEFuZEJvdHRvbSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICBib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCwge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5jbGFzcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggfHwgZWxlbWVudC53aWR0aCk7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgIH07XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gIH1cbn1cblxuY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuICB9XG59XG5cbmNvbnN0IEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuY29uc3QgaXNOdWxsT3JFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJIZWlnaHQpKSB7XG4gICAgaWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cbmNvbnN0IGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hhcnQuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gIGNvbnN0IHt4LCB5fSA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMaXN0KSB7XG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5jb25zdCBkcnBMaXN0ZW5pbmdDaGFydHMgPSBuZXcgTWFwKCk7XG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpIHtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0eXBlID09PSAncmVzaXplJykge1xuICAgIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCwgKGFyZ3MpID0+IHtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIFtldmVudCwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gIH0pO1xuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcbiAgICBpZiAoIXByb3h5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgIGlmIChob29rID09PSAnYWZ0ZXJEZXN0cm95Jykge1xuICAgICAgdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgJ3N0b3AnKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgbG9jYWxJZHMgPSB7fTtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIGxvY2FsSWRzW3BsdWdpbi5pZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3BsdWdpbnMsIGxvY2FsSWRzfTtcbn1cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwge3BsdWdpbnMsIGxvY2FsSWRzfSwgb3B0aW9ucywgYWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge3BsdWdpbiwgbG9jYWw6IGxvY2FsSWRzW2lkXX0sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7cGx1Z2luLCBsb2NhbH0sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgaWYgKGxvY2FsICYmIHBsdWdpbi5kZWZhdWx0cykge1xuICAgIHNjb3Blcy5wdXNoKHBsdWdpbi5kZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtcbiAgICBzY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgIGFsbEtleXM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gIHJldHVybiBheGlzID09PSBpbmRleEF4aXMgPyAnX2luZGV4XycgOiAnX3ZhbHVlXyc7XG59XG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucykge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHJldHVybiBzY2FsZU9wdGlvbnMuYXhpcyB8fCBheGlzRnJvbVBvc2l0aW9uKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgfHwgaWQuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGZpcnN0SURzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYpO1xuICAgIGNvbnN0IGRlZmF1bHRJZCA9IGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgY2hhcnRJbmRleEF4aXMpO1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBmaXJzdElEc1theGlzXSA9IGZpcnN0SURzW2F4aXNdIHx8IGlkO1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuICBjb25maWcuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGRhdGFzZXQgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IG92ZXJyaWRlc1t0eXBlXSB8fCB7fTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0U2NhbGVPcHRpb25zKS5mb3JFYWNoKGRlZmF1bHRJRCA9PiB7XG4gICAgICBjb25zdCBheGlzID0gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChkZWZhdWx0SUQsIGluZGV4QXhpcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSB8fCBmaXJzdElEc1theGlzXSB8fCBheGlzO1xuICAgICAgc2NhbGVzW2lkXSA9IHNjYWxlc1tpZF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG1lcmdlSWYoc2NhbGVzW2lkXSwgW3theGlzfSwgY29uZmlnU2NhbGVzW2lkXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXSk7XG4gICAgfSk7XG4gIH0pO1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuICByZXR1cm4gc2NhbGVzO1xufVxuZnVuY3Rpb24gaW5pdE9wdGlvbnMoY29uZmlnKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb25maWcub3B0aW9ucyB8fCAoY29uZmlnLm9wdGlvbnMgPSB7fSk7XG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLmRhdGEgPSBpbml0RGF0YShjb25maWcuZGF0YSk7XG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIHJldHVybiBjb25maWc7XG59XG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcbmNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9zY29wZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG4gIHNldCB0eXBlKHR5cGUpIHtcbiAgICB0aGlzLl9jb25maWcudHlwZSA9IHR5cGU7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIH1cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG4gIGRhdGFzZXRTY29wZUtleXMoZGF0YXNldFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgJydcbiAgICAgICAgXVxuICAgICAgXSk7XG4gIH1cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cbiAgX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCBfc2NvcGVDYWNoZSA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgaWYgKCFjYWNoZSB8fCByZXNldENhY2hlKSB7XG4gICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIF9zY29wZUNhY2hlLnNldChtYWluU2NvcGUsIGNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG4gIGdldE9wdGlvblNjb3BlcyhtYWluU2NvcGUsIGtleUxpc3RzLCByZXNldENhY2hlKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXlMaXN0cyk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcnJheS5wdXNoKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSxcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIGNvbnN0IHN1YlJlc29sdmVyID0gdGhpcy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHN1YlByZWZpeGVzKTtcbiAgICAgIG9wdGlvbnMgPSBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgc3ViUmVzb2x2ZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgIGNvbnN0IHtyZXNvbHZlcn0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICByZXR1cm4gaXNPYmplY3QoY29udGV4dClcbiAgICAgID8gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHVuZGVmaW5lZCwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICAgICAgOiByZXNvbHZlcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2MgfHwgaXNGdW5jdGlvbih2YWx1ZVtrZXldKSwgZmFsc2UpO1xuZnVuY3Rpb24gbmVlZENvbnRleHQocHJveHksIG5hbWVzKSB7XG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMy45LjFcIjtcblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uc0NvbXBsZXRlKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cbiAgaWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcbiAgICBpdGVtID0gaXRlbS5jYW52YXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIGxhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spIHtcbiAgaWYgKCFpbkNoYXJ0QXJlYSB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNDbGljaykge1xuICAgIHJldHVybiBsYXN0RXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5jbGFzcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmNhbnZhcy5pZCArICdcXCcgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcbiAgICBjYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG4gICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcbiAgICBjb25zdCB7X2FjdGl2ZSwgX2xhc3RFdmVudH0gPSB0aGlzO1xuICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBlYWNoKHRoaXMuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHtfaGlkZGVuSW5kaWNlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHttZXRob2QsIHN0YXJ0LCBjb3VudH0gb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgbW92ZSA9IG1ldGhvZCA9PT0gJ19yZW1vdmVFbGVtZW50cycgPyAtY291bnQgOiBjb3VudDtcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xuICAgIH1cbiAgfVxuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCkgPT4gbmV3IFNldChcbiAgICAgIF9kYXRhQ2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxuICAgICAgICAubWFwKChjLCBpKSA9PiBpICsgJywnICsgYy5zcGxpY2UoMSkuam9pbignLCcpKVxuICAgICk7XG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICB9XG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwge1xuICAgICAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIGNsaXAubGVmdCxcbiAgICAgICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gdGhpcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxuICAgICAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIGNsaXAudG9wLFxuICAgICAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IHRoaXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gIH1cbiAgaXNQb2ludEluQXJlYShwb2ludCkge1xuICAgIHJldHVybiBfaXNQb2ludEluQXJlYShwb2ludCwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpO1xuICB9XG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2Rlc3Ryb3knKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XG4gIH1cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICB9O1xuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICBlYWNoKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICBjYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuY29uc3QgaW52YWxpZGF0ZVBsdWdpbnMgPSAoKSA9PiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xuY29uc3QgZW51bWVyYWJsZSA9IHRydWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFydCwge1xuICBkZWZhdWx0czoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGRlZmF1bHRzXG4gIH0sXG4gIGluc3RhbmNlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGluc3RhbmNlc1xuICB9LFxuICBvdmVycmlkZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBvdmVycmlkZXNcbiAgfSxcbiAgcmVnaXN0cnk6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiByZWdpc3RyeVxuICB9LFxuICB2ZXJzaW9uOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogdmVyc2lvblxuICB9LFxuICBnZXRDaGFydDoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGdldENoYXJ0XG4gIH0sXG4gIHJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSkge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyQxKGFyYywgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBhbmdsZURlbHRhKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuZnVuY3Rpb24gclRoZXRhVG9YWShyLCB0aGV0YSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kLCBjaXJjdWxhcikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZTogc3RhcnQsIHBpeGVsTWFyZ2luLCBpbm5lclJhZGl1czogaW5uZXJSfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcbiAgaWYgKHNwYWNpbmcpIHtcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cbiAgY29uc3QgYmV0YSA9IE1hdGgubWF4KDAuMDAxLCBhbHBoYSAqIG91dGVyUmFkaXVzIC0gb2Zmc2V0IC8gUEkpIC8gb3V0ZXJSYWRpdXM7XG4gIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gKGFscGhhIC0gYmV0YSkgLyAyO1xuICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnQgKyBhbmdsZU9mZnNldCArIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IGVuZEFuZ2xlID0gZW5kIC0gYW5nbGVPZmZzZXQgLSBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCB7b3V0ZXJTdGFydCwgb3V0ZXJFbmQsIGlubmVyU3RhcnQsIGlubmVyRW5kfSA9IHBhcnNlQm9yZGVyUmFkaXVzJDEoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyU3RhcnQ7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyRW5kO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBvdXRlclN0YXJ0IC8gb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIG91dGVyRW5kIC8gb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG4gICAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyRW5kLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIGVuZEFuZ2xlICsgSEFMRl9QSSk7XG4gICAgfVxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcbiAgICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJFbmQsIGVuZEFuZ2xlICsgSEFMRl9QSSwgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSk7XG4gICAgfVxuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuICAgIGlmIChpbm5lclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgICB9XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcbiAgICBpZiAob3V0ZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyU3RhcnRYLCBvdXRlclN0YXJ0WSk7XG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIGRyYXdBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBzdGFydEFuZ2xlICsgVEFVLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlICUgVEFVO1xuICAgICAgaWYgKGNpcmN1bWZlcmVuY2UgJSBUQVUgPT09IDApIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gVEFVO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5mdW5jdGlvbiBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIGZ1bGxDaXJjbGVzfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBlbGVtZW50LmlubmVyUmFkaXVzICsgcGl4ZWxNYXJnaW47XG4gIGxldCBpO1xuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBzdGFydEFuZ2xlICsgVEFVLCBzdGFydEFuZ2xlLCB0cnVlKTtcbiAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcikge1xuICBjb25zdCB7b3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZX0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cbiAgaWYgKGVsZW1lbnQuZnVsbENpcmNsZXMpIHtcbiAgICBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcik7XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKGNoYXJ0WCwgY2hhcnRZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9IHRoaXMub3B0aW9ucy5zcGFjaW5nIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJyxcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDI7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGxldCByYWRpdXNPZmZzZXQgPSAwO1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldCAvIDI7XG4gICAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0KTtcbiAgICAgIGlmICh0aGlzLmNpcmN1bWZlcmVuY2UgPj0gUEkpIHtcbiAgICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IGRyYXdBcmMoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbkFyY0VsZW1lbnQuaWQgPSAnYXJjJztcbkFyY0VsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDIsXG4gIG9mZnNldDogMCxcbiAgc3BhY2luZzogMCxcbiAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgY2lyY3VsYXI6IHRydWUsXG59O1xuQXJjRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXG59O1xuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNhcFN0eWxlLCBvcHRpb25zLmJvcmRlckNhcFN0eWxlKTtcbiAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJKb2luU3R5bGUsIG9wdGlvbnMuYm9yZGVySm9pblN0eWxlKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuICByZXR1cm4gbGluZVRvO1xufVxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtzdGFydDogcGFyYW1zU3RhcnQgPSAwLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMX0gPSBwYXJhbXM7XG4gIGNvbnN0IHtzdGFydDogc2VnbWVudFN0YXJ0LCBlbmQ6IHNlZ21lbnRFbmR9ID0gc2VnbWVudDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgY29uc3Qgb3V0c2lkZSA9IHBhcmFtc1N0YXJ0IDwgc2VnbWVudFN0YXJ0ICYmIHBhcmFtc0VuZCA8IHNlZ21lbnRTdGFydCB8fCBwYXJhbXNTdGFydCA+IHNlZ21lbnRFbmQgJiYgcGFyYW1zRW5kID4gc2VnbWVudEVuZDtcbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHtwb2ludHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgbG9vcCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IGxpbmVNZXRob2QgPSBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpO1xuICBsZXQge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobW92ZSkge1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgIH1cbiAgICBwcmV2ID0gcG9pbnQ7XG4gIH1cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG4gIHJldHVybiAhIWxvb3A7XG59XG5mdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHByZXZYLCBtaW5ZLCBtYXhZLCBsYXN0WTtcbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcbiAgaWYgKG1vdmUpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KDApXTtcbiAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHgpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdYKCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgIH1cbiAgICBsYXN0WSA9IHk7XG4gIH1cbiAgZHJhd1goKTtcbn1cbmZ1bmN0aW9uIF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpIHtcbiAgY29uc3Qgb3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHMuYm9yZGVyRGFzaCAmJiBvcHRzLmJvcmRlckRhc2gubGVuZ3RoO1xuICBjb25zdCB1c2VGYXN0UGF0aCA9ICFsaW5lLl9kZWNpbWF0ZWQgJiYgIWxpbmUuX2xvb3AgJiYgIW9wdHMudGVuc2lvbiAmJiBvcHRzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09ICdtb25vdG9uZScgJiYgIW9wdHMuc3RlcHBlZCAmJiAhYm9yZGVyRGFzaDtcbiAgcmV0dXJuIHVzZUZhc3RQYXRoID8gZmFzdFBhdGhTZWdtZW50IDogcGF0aFNlZ21lbnQ7XG59XG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xuICB9XG4gIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5mdW5jdGlvbiBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtzZWdtZW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QobGluZSk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuZnVuY3Rpb24gZHJhdyhjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBpZiAodXNlUGF0aDJEICYmICFsaW5lLm9wdGlvbnMuc2VnbWVudCkge1xuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9XG59XG5jbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGhpcywge3Byb3BlcnR5LCBzdGFydDogdmFsdWUsIGVuZDogdmFsdWV9KTtcbiAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cbiAgcGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgcmV0dXJuIHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCBwYXJhbXMpO1xuICB9XG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSk7XG4gICAgfVxuICAgIHJldHVybiAhIWxvb3A7XG4gIH1cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmltYXRlZCkge1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbkxpbmVFbGVtZW50LmlkID0gJ2xpbmUnO1xuTGluZUVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gIGJvcmRlckRhc2g6IFtdLFxuICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gIGJvcmRlcldpZHRoOiAzLFxuICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcbiAgZmlsbDogZmFsc2UsXG4gIHNwYW5HYXBzOiBmYWxzZSxcbiAgc3RlcHBlZDogZmFsc2UsXG4gIHRlbnNpb246IDAsXG59O1xuTGluZUVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5MaW5lRWxlbWVudC5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IHRydWUsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxufTtcblxuZnVuY3Rpb24gaW5SYW5nZSQxKGVsLCBwb3MsIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5jbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBzaXplKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgbGV0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XG4gICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCByYWRpdXMgJiYgb3B0aW9ucy5ob3ZlclJhZGl1cyB8fCAwKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IHJhZGl1cyAmJiBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgcmV0dXJuIChyYWRpdXMgKyBib3JkZXJXaWR0aCkgKiAyO1xuICB9XG4gIGRyYXcoY3R4LCBhcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuUG9pbnRFbGVtZW50LmlkID0gJ3BvaW50JztcblBvaW50RWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyV2lkdGg6IDEsXG4gIGhpdFJhZGl1czogMSxcbiAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgaG92ZXJSYWRpdXM6IDQsXG4gIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICByYWRpdXM6IDMsXG4gIHJvdGF0aW9uOiAwXG59O1xuUG9pbnRFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBudWxsLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgYmFzZSwgaG9yaXpvbnRhbH0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnaG9yaXpvbnRhbCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG4gIGdldFJhbmdlKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbkJhckVsZW1lbnQuaWQgPSAnYmFyJztcbkJhckVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG59O1xuQmFyRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxudmFyIGVsZW1lbnRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQXJjRWxlbWVudDogQXJjRWxlbWVudCxcbkxpbmVFbGVtZW50OiBMaW5lRWxlbWVudCxcblBvaW50RWxlbWVudDogUG9pbnRFbGVtZW50LFxuQmFyRWxlbWVudDogQmFyRWxlbWVudFxufSk7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgaWYgKHNhbXBsZXMgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIH1cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2FdO1xuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cbiAgICBhdmdYIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGF2Z1kgLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgY29uc3QgcmFuZ2VPZmZzID0gTWF0aC5mbG9vcihpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IHJhbmdlVG8gPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCB7eDogcG9pbnRBeCwgeTogcG9pbnRBeX0gPSBkYXRhW2FdO1xuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuICAgICAgaWYgKGFyZWEgPiBtYXhBcmVhKSB7XG4gICAgICAgIG1heEFyZWEgPSBhcmVhO1xuICAgICAgICBtYXhBcmVhUG9pbnQgPSBkYXRhW2pdO1xuICAgICAgICBuZXh0QSA9IGo7XG4gICAgICB9XG4gICAgfVxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2VuZEluZGV4XTtcbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBjb25zdCB4TWluID0gZGF0YVtzdGFydF0ueDtcbiAgY29uc3QgeE1heCA9IGRhdGFbZW5kSW5kZXhdLng7XG4gIGNvbnN0IGR4ID0geE1heCAtIHhNaW47XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDEgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4MV0sXG4gICAgICAgICAgICB4OiBhdmdYLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDIgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4Ml0sXG4gICAgICAgICAgICB4OiBhdmdYXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCAmJiBsYXN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgZGVjaW1hdGVkLnB1c2goZGF0YVtsYXN0SW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0Ll9kZWNpbWF0ZWQpIHtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5fZGF0YTtcbiAgICBkZWxldGUgZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kYXRhO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHt2YWx1ZTogZGF0YX0pO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50O1xuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG52YXIgcGx1Z2luX2RlY2ltYXRpb24gPSB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG4gIGJlZm9yZUVsZW1lbnRzVXBkYXRlOiAoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBjaGFydC53aWR0aDtcbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeEF4aXMgPSBjaGFydC5zY2FsZXNbbWV0YS54QXhpc0lEXTtcbiAgICAgIGlmICh4QXhpcy50eXBlICE9PSAnbGluZWFyJyAmJiB4QXhpcy50eXBlICE9PSAndGltZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBkYXRhKTtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDQgKiBhdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmIChjb3VudCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBkZWNpbWF0ZWQ7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdsdHRiJzpcbiAgICAgICAgZGVjaW1hdGVkID0gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWluLW1heCc6XG4gICAgICAgIGRlY2ltYXRlZCA9IG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNpbWF0aW9uIGFsZ29yaXRobSAnJHtvcHRpb25zLmFsZ29yaXRobX0nYCk7XG4gICAgICB9XG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5mdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBsaW5lUG9pbnRzKTtcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XG4gICAgICBwb2ludHMucHVzaCh7eDogbGFzdC54LCB5fSk7XG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGxhc3QueX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcbiAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gIGxldCBmaWxsID0gc291cmNlLmZpbGw7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbaW5kZXhdO1xuICBsZXQgdGFyZ2V0O1xuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgIHJldHVybiBkZWNvZGVUYXJnZXRJbmRleChmaWxsWzBdLCBpbmRleCwgdGFyZ2V0LCBjb3VudCk7XG4gIH1cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cbmZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWUgPSBzdGFydFZhbHVlO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdmFsdWUgPSBzY2FsZS5vcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG5cbmZ1bmN0aW9uIF9idWlsZFN0YWNrTGluZShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cblxuY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBjb25zdCBhbmdsZSA9IHBvaW50LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG4gIGlmIChpc051bWJlckZpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyBwaXhlbCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHBpeGVsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG4gIGN0eC5zYXZlKCk7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgY2xpcFkpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBwb2ludHN9ID0gdGFyZ2V0O1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBsZXQgbGluZUxvb3AgPSBmYWxzZTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiBmaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIHByb3BlcnR5LCBjb2xvciwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBub3RTaGFwZSAmJiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBzdGFydCwgZW5kKSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcbiAgICBsZXQgbG9vcDtcbiAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIGVuZCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cblxudmFyIGluZGV4ID0ge1xuICBpZDogJ2ZpbGxlcicsXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgc291cmNlID0gbnVsbDtcbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3ICYmIHNvdXJjZS5maWxsKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmIChfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XG4gIGxldCB7Ym94SGVpZ2h0ID0gZm9udFNpemUsIGJveFdpZHRoID0gZm9udFNpemV9ID0gbGFiZWxPcHRzO1xuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcbmNvbnN0IGl0ZW1zRXF1YWwgPSAoYSwgYikgPT4gYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuZGF0YXNldEluZGV4ID09PSBiLmRhdGFzZXRJbmRleCAmJiBhLmluZGV4ID09PSBiLmluZGV4O1xuY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbHVtblNpemVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSB0aGlzLl9tYXJnaW5zLmxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gdGhpcy5fbWFyZ2lucy50b3A7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgfVxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGxiYWNrKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcbiAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHRoaXMubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cbiAgX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heFdpZHRoLCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgbGluZVdpZHRocyA9IHRoaXMubGluZVdpZHRocyA9IFswXTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgbGV0IHRvdGFsSGVpZ2h0ID0gdGl0bGVIZWlnaHQ7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIGl0ZW1XaWR0aCArIDIgKiBwYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3RhbEhlaWdodDtcbiAgfVxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcbiAgICBsZXQgdG90YWxXaWR0aCA9IHBhZGRpbmc7XG4gICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XG4gICAgbGV0IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG4gICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG4gICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7Y29sb3I6IGZvbnRDb2xvciwgcGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCAxKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lQ2FwLCAnYnV0dCcpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgMCk7XG4gICAgICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVKb2luLCAnbWl0ZXInKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuICAgICAgICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSwgbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCAmJiBib3hXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKHRoaXMud2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG4gICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG4gICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KVxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIGhpdEJveC5sZWZ0LCBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aClcbiAgICAgICAgICAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkxlYXZlLCBbZSwgcHJldmlvdXMsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25Ib3ZlciwgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgY2FsbGJhY2sob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBwbHVnaW5fbGVnZW5kID0ge1xuICBpZDogJ2xlZ2VuZCcsXG4gIF9lbGVtZW50OiBMZWdlbmQsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsZWdlbmQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGFmdGVyVXBkYXRlKGNoYXJ0KSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxlZ2VuZC5idWlsZExhYmVscygpO1xuICAgIGxlZ2VuZC5hZGp1c3RIaXRCb3hlcygpO1xuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgd2VpZ2h0OiAxMDAwLFxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgcGFkZGluZzogMTAsXG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG5cbmNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBsaW5lQ291bnQgKiB0b0ZvbnQob3B0cy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICBvcHRpb25zOiB0aXRsZU9wdHMsXG4gICAgY2hhcnRcbiAgfSk7XG4gIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxudmFyIHBsdWdpbl90aXRsZSA9IHtcbiAgaWQ6ICd0aXRsZScsXG4gIF9lbGVtZW50OiBUaXRsZSxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMFxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgcGx1Z2luX3N1YnRpdGxlID0ge1xuICBpZDogJ3N1YnRpdGxlJyxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhcnRcbiAgICB9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIG1hcC5nZXQoY2hhcnQpKTtcbiAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMFxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG5cbmNvbnN0IHBvc2l0aW9uZXJzID0ge1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4ICs9IHBvcy54O1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAvIGNvdW50LFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcbiAgbmVhcmVzdChpdGVtcywgZXZlbnRQb3NpdGlvbikge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuICAgICAgICBpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgIG5lYXJlc3RFbGVtZW50ID0gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcbiAgaWYgKHRvUHVzaCkge1xuICAgIGlmIChpc0FycmF5KHRvUHVzaCkpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZTtcbn1cbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XG4gIGlmICgodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG4gIHJldHVybiB7XG4gICAgY2hhcnQsXG4gICAgbGFiZWwsXG4gICAgcGFyc2VkOiBjb250cm9sbGVyLmdldFBhcnNlZChpbmRleCksXG4gICAgcmF3OiBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0sXG4gICAgZm9ybWF0dGVkVmFsdWU6IHZhbHVlLFxuICAgIGRhdGFzZXQ6IGNvbnRyb2xsZXIuZ2V0RGF0YXNldCgpLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgZGF0YXNldEluZGV4LFxuICAgIGVsZW1lbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuICBpZiAodGl0bGVMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMudGl0bGVTcGFjaW5nXG5cdFx0XHQrIG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b207XG4gIH1cbiAgaWYgKGNvbWJpbmVkQm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGJvZHlMaW5lSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYm94SGVpZ2h0LCBib2R5Rm9udC5saW5lSGVpZ2h0KSA6IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIGJvZHlMaW5lSXRlbUNvdW50KSAqIGJvZHlGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogb3B0aW9ucy5ib2R5U3BhY2luZztcbiAgfVxuICBpZiAoZm9vdGVyTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wXG5cdFx0XHQrIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gIH1cbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC50aXRsZSwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuICB3aWR0aFBhZGRpbmcgPSAwO1xuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuICBjdHgucmVzdG9yZSgpO1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKSB7XG4gIGNvbnN0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0JyAmJiB4IC0gd2lkdGggLSBjYXJldCA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cbiAgaWYgKGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkpIHtcbiAgICB4QWxpZ24gPSAnY2VudGVyJztcbiAgfVxuICByZXR1cm4geEFsaWduO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5mdW5jdGlvbiBhbGlnblgoc2l6ZSwgeEFsaWduKSB7XG4gIGxldCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB4ICs9IHBhZGRpbmdBbmRTaXplO1xuICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB4IC09IHBhZGRpbmdBbmRTaXplO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgIHggLT0gTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyBjYXJldFNpemU7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpICsgY2FyZXRTaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAvIDJcbiAgICA6IGFsaWduID09PSAncmlnaHQnXG4gICAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLSBwYWRkaW5nLnJpZ2h0XG4gICAgICA6IHRvb2x0aXAueCArIHBhZGRpbmcubGVmdDtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0IHx8IGNvbmZpZy5fY2hhcnQ7XG4gICAgdGhpcy5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZWRBbmltYXRpb25zO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gIH1cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IHRpdGxlID0gY2FsbGJhY2tzLnRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyh0aXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgYm9keUl0ZW0gPSB7XG4gICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmJlZm9yZUxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgc2NvcGVkLmxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5hZnRlckxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpKTtcbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG4gIGdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBjb25zdCBmb290ZXIgPSBjYWxsYmFja3MuZm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBjb25zdCBhZnRlckZvb3RlciA9IGNhbGxiYWNrcy5hZnRlckZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKHRoaXMuY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydCgoYSwgYikgPT4gb3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgfVxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChzY29wZWQubGFiZWxDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsUG9pbnRTdHlsZXMucHVzaChzY29wZWQubGFiZWxQb2ludFN0eWxlLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goc2NvcGVkLmxhYmVsVGV4dENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcbiAgICByZXR1cm4gdG9vbHRpcEl0ZW1zO1xuICB9XG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXG4gICAgICAgIHk6IGJhY2tncm91bmRQb2ludC55LFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgY2FyZXRYOiBwb3NpdGlvbi54LFxuICAgICAgICBjYXJldFk6IHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWQgJiYgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgb3B0aW9ucy5leHRlcm5hbC5jYWxsKHRoaXMsIHtjaGFydDogdGhpcy5jaGFydCwgdG9vbHRpcDogdGhpcywgcmVwbGF5fSk7XG4gICAgfVxuICB9XG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHtjYXJldFNpemUsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcbiAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB5MyA9IHkxO1xuICAgIH1cbiAgICByZXR1cm4ge3gxLCB4MiwgeDMsIHkxLCB5MiwgeTN9O1xuICB9XG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLnRpdGxlQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XG4gICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMixcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGlzT2JqZWN0KGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCB8fCAxKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxhYmVsQ29sb3JzLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvcnMuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCAtIGJveFBhZGRpbmcpO1xuICAgICAgY29uc3QgaW5uZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJveFdpZHRoIC0gYm94UGFkZGluZyAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9ycy5ib3JkZXJSYWRpdXMpO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBvdXRlclgsXG4gICAgICAgICAgeTogY29sb3JZLFxuICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgfVxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlMaW5lSGVpZ2h0IC8gMik7XG4gICAgICBwdC55ICs9IGJvZHlMaW5lSGVpZ2h0ICsgYm9keVNwYWNpbmc7XG4gICAgfTtcbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXG4gICAgICA/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm94V2lkdGggLyAyICsgYm94UGFkZGluZykgOiAoYm94V2lkdGggKyAyICsgYm94UGFkZGluZylcbiAgICAgIDogMDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGJvZHlJdGVtID0gYm9keVtpXTtcbiAgICAgIHRleHRDb2xvciA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuICAgIH1cbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZztcbiAgfVxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBsZXQgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuICAgIGNvbnN0IHRvb2x0aXBTaXplID0ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwdCA9IHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueVxuICAgIH07XG4gICAgb3BhY2l0eSA9IE1hdGguYWJzKG9wYWNpdHkpIDwgMWUtMyA/IDAgOiBvcGFjaXR5O1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgcHQueSArPSBwYWRkaW5nLnRvcDtcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGV2ZW50UG9zaXRpb24pO1xuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEgPSB0cnVlKSB7XG4gICAgaWYgKHJlcGxheSAmJiB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gZmFsc2U7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuICAgIGNvbnN0IGNoYW5nZWQgPSByZXBsYXkgfHwgIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSkgfHwgcG9zaXRpb25DaGFuZ2VkO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUsIHJlcGxheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmU7XG4gIH1cbiAgX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpIHtcbiAgICBjb25zdCB7Y2FyZXRYLCBjYXJldFksIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCBlKTtcbiAgICByZXR1cm4gcG9zaXRpb24gIT09IGZhbHNlICYmIChjYXJldFggIT09IHBvc2l0aW9uLnggfHwgY2FyZXRZICE9PSBwb3NpdGlvbi55KTtcbiAgfVxufVxuVG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xudmFyIHBsdWdpbl90b29sdGlwID0ge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG4gICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5fd2lsbFJlbmRlcigpKSB7XG4gICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICB0b29sdGlwXG4gICAgICB9O1xuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XG4gICAgICBpZiAoY2hhcnQudG9vbHRpcC5oYW5kbGVFdmVudChhcmdzLmV2ZW50LCB1c2VGaW5hbFBvc2l0aW9uLCBhcmdzLmluQ2hhcnRBcmVhKSkge1xuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiAnYXZlcmFnZScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICB0aXRsZUNvbG9yOiAnI2ZmZicsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIHRpdGxlU3BhY2luZzogMixcbiAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICB0aXRsZUFsaWduOiAnbGVmdCcsXG4gICAgYm9keUNvbG9yOiAnI2ZmZicsXG4gICAgYm9keVNwYWNpbmc6IDIsXG4gICAgYm9keUZvbnQ6IHtcbiAgICB9LFxuICAgIGJvZHlBbGlnbjogJ2xlZnQnLFxuICAgIGZvb3RlckNvbG9yOiAnI2ZmZicsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmb290ZXJBbGlnbjogJ2xlZnQnLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgYm94V2lkdGg6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBkaXNwbGF5Q29sb3JzOiB0cnVlLFxuICAgIGJveFBhZGRpbmc6IDAsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gICAgICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSxcbiAgICAgIGFmdGVyVGl0bGU6IG5vb3AsXG4gICAgICBiZWZvcmVCb2R5OiBub29wLFxuICAgICAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICBsYWJlbCArPSAnOiAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuICAgICAgbGFiZWxDb2xvcih0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICAgICAgfSxcbiAgICAgIGxhYmVsUG9pbnRTdHlsZSh0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxhYmVsOiBub29wLFxuICAgICAgYWZ0ZXJCb2R5OiBub29wLFxuICAgICAgYmVmb3JlRm9vdGVyOiBub29wLFxuICAgICAgZm9vdGVyOiBub29wLFxuICAgICAgYWZ0ZXJGb290ZXI6IG5vb3BcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICB0aXRsZUZvbnQ6ICdmb250J1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxufTtcblxudmFyIHBsdWdpbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5EZWNpbWF0aW9uOiBwbHVnaW5fZGVjaW1hdGlvbixcbkZpbGxlcjogaW5kZXgsXG5MZWdlbmQ6IHBsdWdpbl9sZWdlbmQsXG5TdWJUaXRsZTogcGx1Z2luX3N1YnRpdGxlLFxuVGl0bGU6IHBsdWdpbl90aXRsZSxcblRvb2x0aXA6IHBsdWdpbl90b29sdGlwXG59KTtcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcbmNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG5DYXRlZ29yeVNjYWxlLmlkID0gJ2NhdGVnb3J5JztcbkNhdGVnb3J5U2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IENhdGVnb3J5U2NhbGUucHJvdG90eXBlLmdldExhYmVsRm9yVmFsdWVcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yfSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICAgIGlmIChtYXggPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbWluIDw9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuICAgICAgfVxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG4gICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgbWF4VGlja3MgPSAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgfVxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cblxuY2xhc3MgTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IG1heCA6IDE7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBsZW5ndGggPSBob3Jpem9udGFsID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgY29uc3QgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApO1xuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbkxpbmVhclNjYWxlLmlkID0gJ2xpbmVhcic7XG5MaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IGVuZEV4cCA9IE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1heCkpO1xuICBjb25zdCBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBsZXQgdGlja1ZhbCA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuICBsZXQgZXhwID0gTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSk7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBkbyB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWwsIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gICAgKytzaWduaWZpY2FuZDtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IDE7XG4gICAgICArK2V4cDtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gIHJldHVybiB0aWNrcztcbn1cbmNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGNvbnN0IGV4cCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh2KSkgKyBtKTtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGV4cChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGV4cChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuICAgICAgc2V0TWF4KGV4cChtaW4sICsxKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgbWluID09PSBleHAodGhpcy5taW4sIDApKSB7XG4gICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG5Mb2dhcml0aG1pY1NjYWxlLmlkID0gJ2xvZ2FyaXRobWljJztcbkxvZ2FyaXRobWljU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgfVxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGV4dHJhID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMjtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBvcHRzLnBvaW50TGFiZWxzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgICBjb25zdCBzaXplID0gbGFiZWxTaXplc1tpXTtcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgICBpdGVtcy5wdXNoKHtcbiAgICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgICAgeSxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIGxlZnQsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICAgIGJvdHRvbTogeSArIHNpemUuaFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbiwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0c0F0SW5kZXg7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKG9wdHNBdEluZGV4LmJvcmRlclJhZGl1cyk7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcbiAgICAgIGNvbnN0IGJhY2tkcm9wTGVmdCA9IGxlZnQgLSBwYWRkaW5nLmxlZnQ7XG4gICAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgICBjb25zdCBiYWNrZHJvcEhlaWdodCA9IGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0O1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxuICAgICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGJhY2tkcm9wTGVmdCwgYmFja2Ryb3BUb3AsIGJhY2tkcm9wV2lkdGgsIGJhY2tkcm9wSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0O1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChwYXJlbnQsIGluZGV4LCBsYWJlbCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBsYWJlbCxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgfSk7XG59XG5jbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkpO1xuICB9XG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAodGhpcy5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgfVxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXggLSAxKSk7XG4gICAgICAgICAgZHJhd1JhZGl1c0xpbmUodGhpcywgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHt9XG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdUaXRsZSgpIHt9XG59XG5SYWRpYWxMaW5lYXJTY2FsZS5pZCA9ICdyYWRpYWxMaW5lYXInO1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIGFuaW1hdGU6IHRydWUsXG4gIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcbiAgYW5nbGVMaW5lczoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICB9LFxuICBncmlkOiB7XG4gICAgY2lyY3VsYXI6IGZhbHNlXG4gIH0sXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIHRpY2tzOiB7XG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9LFxuICBwb2ludExhYmVsczoge1xuICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBmb250OiB7XG4gICAgICBzaXplOiAxMFxuICAgIH0sXG4gICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIHBhZGRpbmc6IDUsXG4gICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gIH1cbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0Um91dGVzID0ge1xuICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZXNjcmlwdG9ycyA9IHtcbiAgYW5nbGVMaW5lczoge1xuICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gIH1cbn07XG5cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5jb25zdCBVTklUUyA9IChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuICBpZiAoIWlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuICByZXR1cm4gK3ZhbHVlO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cbmNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzKSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgYWRhcHRlci5pbml0KG9wdHMpO1xuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdHMpO1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChyYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZSh0aGlzLCByYXcpO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuX2dldExhYmVsQm91bmRzKCkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCk7XG4gICAgbWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcbiAgICB0aGlzLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4IC0gMSk7XG4gICAgdGhpcy5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuICB9XG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgbWluID0gYXJyWzBdO1xuICAgICAgbWF4ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHttaW4sIG1heH07XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCB0aWNrcyA9IF9maWx0ZXJCZXR3ZWVuKHRpbWVzdGFtcHMsIG1pbiwgbWF4KTtcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KHRpbWVPcHRzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5tYXAoeCA9PiAreCk7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcbiAgICByZXR1cm4gZm9ybWF0dGVyID8gY2FsbGJhY2soZm9ybWF0dGVyLCBbbGFiZWwsIGluZGV4LCB0aWNrc10sIHRoaXMpIDogbGFiZWw7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cblRpbWVTY2FsZS5pZCA9ICd0aW1lJztcblRpbWVTY2FsZS5kZWZhdWx0cyA9IHtcbiAgYm91bmRzOiAnZGF0YScsXG4gIGFkYXB0ZXJzOiB7fSxcbiAgdGltZToge1xuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdW5pdDogZmFsc2UsXG4gICAgcm91bmQ6IGZhbHNlLFxuICAgIGlzb1dlZWtkYXk6IGZhbHNlLFxuICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgc291cmNlOiAnYXV0bycsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5UaW1lU2VyaWVzU2NhbGUuaWQgPSAndGltZXNlcmllcyc7XG5UaW1lU2VyaWVzU2NhbGUuZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbnZhciBzY2FsZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5DYXRlZ29yeVNjYWxlOiBDYXRlZ29yeVNjYWxlLFxuTGluZWFyU2NhbGU6IExpbmVhclNjYWxlLFxuTG9nYXJpdGhtaWNTY2FsZTogTG9nYXJpdGhtaWNTY2FsZSxcblJhZGlhbExpbmVhclNjYWxlOiBSYWRpYWxMaW5lYXJTY2FsZSxcblRpbWVTY2FsZTogVGltZVNjYWxlLFxuVGltZVNlcmllc1NjYWxlOiBUaW1lU2VyaWVzU2NhbGVcbn0pO1xuXG5jb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG5cbmV4cG9ydCB7IEFuaW1hdGlvbiwgQW5pbWF0aW9ucywgQXJjRWxlbWVudCwgQmFyQ29udHJvbGxlciwgQmFyRWxlbWVudCwgQmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBCdWJibGVDb250cm9sbGVyLCBDYXRlZ29yeVNjYWxlLCBDaGFydCwgRGF0YXNldENvbnRyb2xsZXIsIHBsdWdpbl9kZWNpbWF0aW9uIGFzIERlY2ltYXRpb24sIERvbVBsYXRmb3JtLCBEb3VnaG51dENvbnRyb2xsZXIsIEVsZW1lbnQsIGluZGV4IGFzIEZpbGxlciwgSW50ZXJhY3Rpb24sIHBsdWdpbl9sZWdlbmQgYXMgTGVnZW5kLCBMaW5lQ29udHJvbGxlciwgTGluZUVsZW1lbnQsIExpbmVhclNjYWxlLCBMb2dhcml0aG1pY1NjYWxlLCBQaWVDb250cm9sbGVyLCBQb2ludEVsZW1lbnQsIFBvbGFyQXJlYUNvbnRyb2xsZXIsIFJhZGFyQ29udHJvbGxlciwgUmFkaWFsTGluZWFyU2NhbGUsIFNjYWxlLCBTY2F0dGVyQ29udHJvbGxlciwgcGx1Z2luX3N1YnRpdGxlIGFzIFN1YlRpdGxlLCBUaWNrcywgVGltZVNjYWxlLCBUaW1lU2VyaWVzU2NhbGUsIHBsdWdpbl90aXRsZSBhcyBUaXRsZSwgcGx1Z2luX3Rvb2x0aXAgYXMgVG9vbHRpcCwgYWRhcHRlcnMgYXMgX2FkYXB0ZXJzLCBfZGV0ZWN0UGxhdGZvcm0sIGFuaW1hdG9yLCBjb250cm9sbGVycywgZWxlbWVudHMsIGxheW91dHMsIHBsdWdpbnMsIHJlZ2lzdGVyYWJsZXMsIHJlZ2lzdHJ5LCBzY2FsZXMgfTtcbiIsImltcG9ydCB7Q2hhcnQsIHJlZ2lzdGVyYWJsZXN9IGZyb20gJy4uL2Rpc3QvY2hhcnQubWpzJztcblxuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8597\n")}},__webpack_module_cache__={};function __webpack_require__(t){var n=__webpack_module_cache__[t];if(void 0!==n)return n.exports;var Q=__webpack_module_cache__[t]={id:t,exports:{}};return __webpack_modules__[t].call(Q.exports,Q,Q.exports,__webpack_require__),Q.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.n=t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(t,n)=>{for(var Q in n)__webpack_require__.o(n,Q)&&!__webpack_require__.o(t,Q)&&Object.defineProperty(t,Q,{enumerable:!0,get:n[Q]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),__webpack_require__.o=(t,n)=>Object.prototype.hasOwnProperty.call(t,n),__webpack_require__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{var t;__webpack_require__.g.importScripts&&(t=__webpack_require__.g.location+"");var n=__webpack_require__.g.document;if(!t&&n&&(n.currentScript&&(t=n.currentScript.src),!t)){var Q=n.getElementsByTagName("script");Q.length&&(t=Q[Q.length-1].src)}if(!t)throw new Error("Automatic publicPath is not supported in this browser");t=t.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=t})(),__webpack_require__.b=document.baseURI||self.location.href,__webpack_require__.nc=void 0;var __webpack_exports__=__webpack_require__(3607)})();